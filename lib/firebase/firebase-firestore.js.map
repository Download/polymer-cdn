{"version":3,"sources":["webpack:///firebase-firestore.js","webpack:///./firestore/index.js","webpack:///../firestore/dist/esm/src/util/log.js","webpack:///../firestore/dist/esm/src/util/assert.js","webpack:///../firestore/dist/esm/src/platform/platform.js","webpack:///../firestore/dist/esm/src/util/api.js","webpack:///../firestore/dist/esm/src/util/obj.js","webpack:///../firestore/dist/esm/src/util/input_validation.js","webpack:///../firestore/dist/esm/src/util/misc.js","webpack:///../firestore/dist/esm/src/api/blob.js","webpack:///../firestore/dist/esm/src/model/field_value.js","webpack:///../firestore/dist/esm/src/util/types.js","webpack:///../firestore/dist/esm/src/core/query.js","webpack:///../firestore/dist/esm/src/remote/rpc_error.js","webpack:///../firestore/dist/esm/src/model/collections.js","webpack:///../firestore/dist/esm/src/remote/watch_change.js","webpack:///../firestore/dist/esm/src/remote/serializer.js","webpack:///../firestore/dist/esm/src/api/field_path.js","webpack:///../firestore/dist/esm/src/core/view.js","webpack:///../firestore/dist/esm/src/local/encoded_resource_path.js","webpack:///../firestore/dist/esm/src/local/indexeddb_schema.js","webpack:///../firestore/dist/esm/src/local/simple_db.js","webpack:///../firestore/dist/esm/src/local/indexeddb_mutation_queue.js","webpack:///../firestore/dist/esm/src/local/indexeddb_query_cache.js","webpack:///../firestore/dist/esm/src/local/indexeddb_remote_document_cache.js","webpack:///../firestore/dist/esm/src/local/local_serializer.js","webpack:///../firestore/dist/esm/src/api/credentials.js","webpack:///../firestore/dist/esm/src/api/observer.js","webpack:///../firestore/dist/esm/src/api/user_data_converter.js","webpack:///../firestore/dist/esm/src/api/database.js","webpack:///../firestore/dist/esm/src/platform/config.js","webpack:///../firestore/dist/esm/index.js","webpack:///../firestore/dist/esm/src/core/version.js","webpack:///../firestore/dist/esm/src/util/error.js","webpack:///../firestore/dist/esm/src/api/geo_point.js","webpack:///../firestore/dist/esm/src/core/database_info.js","webpack:///../firestore/dist/esm/src/model/path.js","webpack:///../firestore/dist/esm/src/model/document_key.js","webpack:///../firestore/dist/esm/src/model/document.js","webpack:///../firestore/dist/esm/src/util/sorted_map.js","webpack:///../firestore/dist/esm/src/local/query_data.js","webpack:///../firestore/dist/esm/src/core/timestamp.js","webpack:///../firestore/dist/esm/src/core/snapshot_version.js","webpack:///../firestore/dist/esm/src/model/mutation.js","webpack:///../firestore/dist/esm/src/remote/existence_filter.js","webpack:///../firestore/dist/esm/src/util/sorted_set.js","webpack:///../firestore/dist/esm/src/remote/remote_event.js","webpack:///../firestore/dist/esm/src/remote/stream_bridge.js","webpack:///../firestore/dist/esm/src/platform_browser/webchannel_connection.js","webpack:///../firestore/dist/esm/src/platform_browser/browser_platform.js","webpack:///../firestore/dist/esm/src/platform_browser/browser_init.js","webpack:///../firestore/dist/esm/src/core/types.js","webpack:///../firestore/dist/esm/src/core/view_snapshot.js","webpack:///../firestore/dist/esm/src/core/target_id_generator.js","webpack:///../firestore/dist/esm/src/model/document_set.js","webpack:///../firestore/dist/esm/src/util/obj_map.js","webpack:///../firestore/dist/esm/src/core/event_manager.js","webpack:///../firestore/dist/esm/src/local/persistence_promise.js","webpack:///../firestore/dist/esm/src/local/eager_garbage_collector.js","webpack:///../firestore/dist/esm/src/local/local_view_changes.js","webpack:///../firestore/dist/esm/src/local/reference_set.js","webpack:///../firestore/dist/esm/src/remote/persistent_stream.js","webpack:///../firestore/dist/esm/src/core/sync_engine.js","webpack:///../firestore/dist/esm/src/model/mutation_batch.js","webpack:///../firestore/dist/esm/src/local/indexeddb_persistence.js","webpack:///../firestore/dist/esm/src/local/local_documents_view.js","webpack:///../firestore/dist/esm/src/local/remote_document_change_buffer.js","webpack:///../firestore/dist/esm/src/local/local_store.js","webpack:///../firestore/dist/esm/src/local/memory_mutation_queue.js","webpack:///../firestore/dist/esm/src/local/memory_query_cache.js","webpack:///../firestore/dist/esm/src/local/memory_remote_document_cache.js","webpack:///../firestore/dist/esm/src/local/memory_persistence.js","webpack:///../firestore/dist/esm/src/local/no_op_garbage_collector.js","webpack:///../firestore/dist/esm/src/util/promise.js","webpack:///../firestore/dist/esm/src/remote/backoff.js","webpack:///../firestore/dist/esm/src/remote/datastore.js","webpack:///../firestore/dist/esm/src/core/transaction.js","webpack:///../firestore/dist/esm/src/remote/remote_store.js","webpack:///../firestore/dist/esm/src/core/firestore_client.js","webpack:///../firestore/dist/esm/src/util/async_observer.js","webpack:///../firestore/dist/esm/src/util/async_queue.js","webpack:///../firestore/dist/esm/src/auth/user.js","webpack:///../firestore/dist/esm/src/api/field_value.js","webpack:///../webchannel-wrapper/dist/index.js"],"names":["webpackJsonpFirebase","113","module","exports","__webpack_require__","114","__webpack_exports__","getLogLevel","logLevel","setLogLevel","newLevel","debug","tag","msg","obj","_i","arguments","length","LogLevel","DEBUG","time","Date","toISOString","args","map","argToString","console","log","apply","SDK_VERSION","concat","log_error","ERROR","error","JSON","stringify","e","fail","failure","message","Error","assert","assertion","emptyByteString","platform_PlatformSupport","getPlatform","makeConstructorPrivate","cls","optionalMessage","PublicConstructor","FirestoreError","Code","INVALID_ARGUMENT","prototype","staticProperty","hasOwnProperty","contains","key","Object","call","defaulted","value","defaultValue","undefined","forEachNumber","fn","num","parseInt","isNaN","forEach","isEmpty","shallowCopy","result","validateExactNumberOfArgs","functionName","numberOfArgs","formatPlural","validateAtLeastNumberOfArgs","minNumberOfArgs","validateBetweenNumberOfArgs","maxNumberOfArgs","validateNamedArrayAtLeastNumberOfElements","name","minNumberOfElements","Array","validateArgType","type","position","argument","validateType","ordinal","validateOptionalArgType","validateNamedType","optionName","validateNamedOptionalType","inputName","input","isPlainObject","description","valueDescription","getPrototypeOf","substring","customObjectName","tryGetCustomObjectType","constructor","funcNameRegex","results","exec","validateDefined","validateOptionNames","options","optionNames","_","indexOf","join","invalidClassError","str","primitiveComparator","left","right","equals","arrayEquals","i","immediatePredecessor","s","lastIndex","charAt","String","fromCharCode","charCodeAt","immediateSuccessor","assertUint8ArrayAvailable","Uint8Array","UNIMPLEMENTED","assertBase64Available","base64Available","numericComparator","numericEquals","isNullOrUndefined","isSafeInteger","isInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","fieldFilter","field","op","NullValue","INSTANCE","query_RelationOp","EQUAL","NullFilter","DoubleValue","NAN","NanFilter","query_RelationFilter","isPermanentError","code","OK","CANCELLED","UNKNOWN","DEADLINE_EXCEEDED","RESOURCE_EXHAUSTED","INTERNAL","UNAVAILABLE","UNAUTHENTICATED","NOT_FOUND","ALREADY_EXISTS","PERMISSION_DENIED","FAILED_PRECONDITION","ABORTED","OUT_OF_RANGE","DATA_LOSS","mapCodeFromRpcStatus","status","RpcCode","mapCodeFromRpcCode","mapRpcCodeFromCode","mapCodeFromHttpStatus","maybeDocumentMap","EMPTY_MAYBE_DOCUMENT_MAP","documentMap","EMPTY_DOCUMENT_MAP","documentVersionMap","EMPTY_DOCUMENT_VERSION_MAP","documentKeySet","EMPTY_DOCUMENT_KEY_SET","applyResumeToken","change","resumeToken","assertPresent","parseInt64","hasTag","fromDotSeparatedString","path","search","RESERVED","field_path_FieldPath","bind","split","compareChangeType","c1","c2","order","ChangeType","Added","Modified","Metadata","Removed","encode","encodeSeparator","encodeSegment","get","segment","resultBuf","c","escapeChar","encodedNul","encodedEscape","encodedSeparatorChar","decode","path_ResourcePath","EMPTY_PATH","lastReasonableEscapeIndex","segments","segmentBuilder","start","end","currentPiece","push","createOrUpgradeDb","db","oldVersion","createObjectStore","DbMutationQueue","store","keyPath","DbMutationBatch","DbTargetDocument","createIndex","documentTargetsIndex","documentTargetsKeyPath","unique","DbTarget","queryTargetsIndexName","queryTargetsKeyPath","indexeddb_schema_DbDocumentMutation","DbRemoteDocument","DbOwner","DbTargetGlobal","wrapRequest","request","persistence_promise_PersistencePromise","resolve","reject","onsuccess","event","target","onerror","validateStreamToken","token","mutationsStore","txn","getStore","documentMutationsStore","mutationQueuesStore","simple_db_SimpleDbTransaction","targetsStore","indexeddb_query_cache_getStore","globalTargetStore","documentTargetStore","remoteDocumentsStore","dbKey","docKey","toArray","isDocumentQuery","dbQuery","documents","makeCredentialsProvider","credentials","credentials_EmptyCredentialsProvider","credentials_GoogleCredentialsProvider","client","credentials_FirstPartyCredentialsProvider","sessionIndex","isPartialObserver","implementsAnyMethods","methods","object","methods_1","method","isWrite","dataSource","UserDataSource","Set","MergeSet","Update","QueryValue","looksLikeJsonObject","geo_point_GeoPoint","blob_Blob","DocumentKeyReference","FieldValueImpl","validatePlainObject","context","createError","fieldPathFromArgument","methodName","_internalPath","fieldPathFromDotSeparatedString","errorMessage","validateSetOptions","merge","validateReference","documentRef","firestore","database_DocumentReference","changesFromSnapshot","snapshot","oldDocs","lastDoc_1","index_1","docChanges","doc","database_DocumentSnapshot","fromCache","query","docComparator","oldIndex","newIndex","indexTracker_1","delete","add","resultChangeType","configureForFirebase","firebase","registerService","app","database_Firestore","firestoreNamespace","registerFirestore","instance","defineProperty","esm","PlatformSupport","setPlatform","platform","__extends","this","extendStatics","setPrototypeOf","__proto__","d","b","p","__","create","_super","_this","toString","misc_AutoId","AutoId","newId","chars","autoId","Math","floor","random","Blob","binaryString","_binaryString","fromBase64String","base64","atob","fromUint8Array","array","char","toBase64","btoa","toUint8Array","buffer","_equals","other","_compareTo","PublicBlob","GeoPoint","latitude","longitude","isFinite","_lat","_long","enumerable","configurable","DatabaseInfo","databaseId","persistenceKey","host","ssl","DEFAULT_DATABASE_NAME","database_info_DatabaseId","DatabaseId","projectId","database","compareTo","path___extends","path_Path","Path","offset","init","len","construct","comparator","child","nameOrPath","slice","limit","popFirst","size","popLast","firstSegment","lastSegment","index","isPrefixOf","p1","p2","min","ResourcePath","canonicalString","fromString","filter","identifierRegExp","path_FieldPath","FieldPath","isValidIdentifier","test","replace","isKeyField","keyField","fromServerFormat","current","addCurrentSegment","inBackticks","next","document_key_DocumentKey","DocumentKey","isDocumentKey","k1","k2","fromSegments","fromPathString","EMPTY","document_Document","Document","version","data","hasLocalMutations","fieldValue","compareByKey","d1","d2","compareByField","v1","v2","document_NoDocument","NoDocument","sorted_map_SortedMap","SortedMap","root","sorted_map_LLRBNode","insert","copy","BLACK","remove","node","cmp","getPredecessorKey","rightParent","prunedNodes","minKey","maxKey","inorderTraversal","action","k","v","reverseTraversal","getIterator","resultGenerator","sorted_map_SortedMapIterator","getIteratorFrom","getReverseIterator","getReverseIteratorFrom","SortedMapIterator","startKey","isReverse","nodeStack","getNext","pop","hasNext","peek","LLRBNode","color","RED","n","fixUp","removeMin","isRed","moveRedLeft","smallest","rotateRight","moveRedRight","rotateLeft","colorFlip","nl","nr","checkMaxDepth","blackDepth","check","pow","LLRBEmptyNode","TypeOrder","field_value___extends","QueryPurpose","field_value_FieldValue","FieldValue","val","defaultCompareTo","typeOrder","internalValue","field_value_BooleanValue","BooleanValue","of","TRUE","FALSE","NumberValue","IntegerValue","NaN","POSITIVE_INFINITY","Infinity","NEGATIVE_INFINITY","field_value_StringValue","StringValue","TimestampValue","toDate","ServerTimestampValue","localWriteTime","BlobValue","field_value_RefValue","RefValue","GeoPointValue","field_value_ObjectValue","ObjectValue","it1","it2","next1","next2","set","to","setChild","newChild","pathSegment","childName","field_value_ArrayValue","ArrayValue","minLength","NumberAsAny","Number","query_Query","Query","explicitOrderBy","filters","startAt","endAt","memoizedCanonicalId","memoizedOrderBy","assertValidBound","atPath","inequalityField","getInequalityFilterField","firstOrderByField","getFirstOrderByField","KEY_ORDERING_ASC","query_OrderBy","foundKeyOrdering","_a","orderBy","lastDirection","dir","Direction","ASCENDING","KEY_ORDERING_DESC","addFilter","isInequality","newFilters","addOrderBy","newOrderBy","withLimit","withStartAt","bound","withEndAt","canonicalId","_b","_c","comparedOnKeyField","comp","compare","matches","matchesAncestor","matchesOrderBy","matchesFilters","matchesBounds","hasLimit","docPath","sortsBeforeDocument","RelationOp","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN_OR_EQUAL","GREATER_THAN","RelationFilter","refValue","comparison","matchesComparison","matchesValue","DESCENDING","query_Bound","Bound","before","component","orderByComponent","docValue","thisPosition","otherPosition","OrderBy","isKeyOrderBy","isoRegExp","RegExp","timestamp_Timestamp","Timestamp","seconds","nanos","now","fromEpochMilliseconds","fromDate","date","getTime","milliseconds","fromISOString","utc","fraction","nanoStr","substr","toEpochMilliseconds","snapshot_version_SnapshotVersion","SnapshotVersion","timestamp","fromMicroseconds","fromTimestamp","forDeletedDoc","MIN","toMicroseconds","toTimestamp","MutationType","query_data_QueryData","QueryData","targetId","purpose","snapshotVersion","update","updated","mutation___extends","mutation_FieldMask","FieldMask","fields","ServerTimestampTransform","FieldTransform","transform","MutationResult","transformResults","mutation_Precondition","Precondition","updateTime","exists","isValidFor","maybeDoc","isNone","NONE","mutation_Mutation","Mutation","verifyKeyMatches","getPostMutationVersion","mutation_SetMutation","SetMutation","precondition","applyToRemoteDocument","mutationResult","applyToLocalView","mutation_PatchMutation","PatchMutation","fieldMask","Patch","newData","patchDocument","patchObject","fieldPath","newValue","mutation_TransformMutation","TransformMutation","fieldTransforms","Transform","requireDocument","transformObject","localTransformResults","fieldTransform","mutation_DeleteMutation","DeleteMutation","Delete","ExistenceFilter","count","CurrentStatusUpdate","sorted_set_SortedSet","SortedSet","fromMapKeys","keys","has","elem","first","last","cb","forEachInRange","range","iter","forEachWhile","firstAfterOrEqual","unionWith","thisIt","otherIt","thisElem","otherElem","remote_event_RemoteEvent","RemoteEvent","targetChanges","documentUpdates","addDocumentUpdate","handleExistenceFilterMismatch","mapping","ResetMapping","currentStatusUpdate","MarkNotCurrent","WatchTargetChangeState","EMPTY_KEY_SET","docs","UpdateMapping","addedDocuments","removedDocuments","applyToKeySet","DocumentWatchChange","updatedTargetIds","removedTargetIds","newDoc","ExistenceFilterChange","existenceFilter","watch_change_WatchTargetChange","WatchTargetChange","state","targetIds","cause","watch_change_WatchChangeAggregator","WatchChangeAggregator","listenTargets","pendingTargetResponses","existenceFilters","frozen","watchChange","addDocumentChange","addTargetChange","addExistenceFilterChange","addChanges","watchChanges","createRemoteEvent","isActiveTarget","ensureTargetChange","None","docChange","relevant","targetChange","NoChange","recordTargetResponse","Current","MarkCurrent","Reset","newCount","DIRECTIONS","dirs","OPERATORS","ops","serializer_JsonProtoSerializer","JsonProtoSerializer","useProto3Json","unsafeCastProtoByteString","byteString","fromRpcStatus","toBytes","bytes","fromBlob","blob","toVersion","fromVersion","toResourceName","fullyQualifiedPrefixPath","fromResourceName","resource","isValidResourceName","toName","fromName","extractLocalPathFromResourceName","toQueryPath","encodedDatabaseId","fromQueryPath","resourceName","toValue","nullValue","booleanValue","integerValue","doubleValue","stringValue","mapValue","toMapValue","arrayValue","toArrayValue","timestampValue","geoPointValue","bytesValue","referenceValue","fromValue","fromFields","values","dbId","toMutationDocument","toFields","toDocument","document","fromDocument","fromFound","found","fromMissing","missing","readTime","fromMaybeDocument","toWatchTargetChangeState","toTestWatchChange","documentChange","documentDelete","documentRemove","targetChangeType","fromWatchChange","fromWatchTargetChangeState","causeProto","entityChange","docDelete","docRemove","versionFromListenResponse","toMutation","mutation","updateMask","toDocumentMask","toFieldTransform","currentDocument","toPrecondition","fromMutation","proto","fromPrecondition","fromDocumentMask","fromFieldTransform","fromWriteResult","fromWriteResults","protos","setToServerValue","toDocumentsTarget","fromDocumentsTarget","documentsTarget","toQueryTarget","structuredQuery","parent","from","collectionId","where","toFilter","toOrder","toLimit","toCursor","fromQueryTarget","fromCount","filterBy","fromFilter","fromOrder","fromCursor","toListenRequestLabels","queryData","toLabel","goog-listen-tags","Listen","ExistenceFilterMismatch","LimboResolution","toTarget","toRelationFilter","toUnaryFilter","compositeFilter","unaryFilter","fromUnaryFilter","fromRelationFilter","f","reduce","accum","orderBys","toPropertyOrder","fromPropertyOrder","cursor","toDirection","fromDirection","toOperatorName","fromOperatorName","toFieldPathReference","fromFieldPathReference","fieldReference","direction","nanField","nullField","fieldPaths","paths","dist","stream_bridge_StreamBridge","StreamBridge","wrappedOnOpen","wrappedOnClose","wrappedOnMessage","sendFn","closeFn","onOpen","callback","onClose","onMessage","close","send","callOnOpen","callOnClose","err","callOnMessage","LOG_TAG","X_GOOG_API_CLIENT_VALUE","webchannel_connection_WebChannelConnection","WebChannelConnection","info","pool","baseUrl","modifyHeadersForRequest","headers","header","authHeaders","invoke","rpcName","url","makeUrl","Promise","getObject","xhr","listenOnce","COMPLETE","getLastErrorCode","NO_ERROR","json","getResponseJson","TIMEOUT","HTTP_ERROR","status_1","getStatus","getResponseText","getStatusText","getLastError","releaseObject","requestString","Content-Type","openStream","rpcService","RPC_STREAM_SERVICE_MAPPING","rpcUrlName","RPC_STREAM_NAME_MAPPING","urlParts","webchannelTransport","backgroundChannelTest","httpSessionIdParam","initMessageHeaders","sendRawJson","supportsCrossDomainXhr","channel","createWebChannel","opened","closed","streamBridge","open","unguardedEventListen","listen","param","setTimeout","EventType","OPEN","CLOSE","MESSAGE","msgData","status_2","Write","browser_platform_BrowserPlatform","BrowserPlatform","loadConnection","databaseInfo","newSerializer","encoded","raw","OnlineState","fieldNames","documentId","_DOCUMENT_ID","SyncState","GeneratorIds","view_snapshot_DocumentChangeSet","DocumentChangeSet","changeMap","track","oldChange","getChanges","changes","document_set_DocumentSet","DocumentSet","keyedMap","sortedSet","emptySet","oldSet","prevDoc","thisDoc","otherDoc","docStrings","newSet","obj_map_ObjectMap","ObjectMap","mapKeyFn","inner","id","matches_1","otherKey","splice","entries","entries_1","QueryListenersInfo","listeners","event_manager_EventManager","EventManager","syncEngine","queries","q","onlineState","Unknown","subscribe","onChange","onError","listener","firstListen","queryInfo","onOnlineStateChanged","viewSnap","onViewSnapshot","then","unlisten","lastListen","viewSnaps","viewSnaps_1","event_manager_QueryListener","QueryListener","queryObserver","raisedInitialEvent","snap","syncStateChanged","includeDocumentMetadataChanges","hasPendingWrites","shouldRaiseEvent","shouldRaiseInitialEvent","raiseInitialEvent","maybeOnline","Failed","waitForSyncWhenOnline","hasPendingWritesChanged","includeQueryMetadataChanges","getInitialViewChanges","PersistencePromise","nextCallback","catchCallback","isDone","callbackAttached","catch","nextFn","catchFn","wrapFailure","wrapSuccess","toPromise","wrapUserFunction","waitFor","all","promise","nextPromise","idx","initial","eager_garbage_collector_EagerGarbageCollector","EagerGarbageCollector","isEager","sources","potentialGarbage","addGarbageSource","garbageSource","setGarbageCollector","removeGarbageSource","addPotentialGarbageKey","collectGarbage","promises","garbageKeys","hasRefsPromise","documentHasAnyReferences","hasRefs","source","containsKey","local_view_changes_LocalViewChanges","LocalViewChanges","addedKeys","removedKeys","fromSnapshot","viewSnapshot","reference_set_ReferenceSet","ReferenceSet","refsByKey","reference_set_DocReference","refsByTarget","compareByTargetId","garbageCollector","addReference","ref","addReferences","removeReference","removeRef","removeReferences","removeReferencesForId","emptyKey","startRef","endRef","removeAllReferences","referencesForId","firstRef","DocReference","targetOrBatchId","RESERVED_BITS","PersistentStreamState","TargetIdGenerator","generatorId","initAfter","afterWithoutGenerator","afterGenerator","previousId","forLocalStore","LocalStore","forSyncEngine","SyncEngine","AddedLimboDocument","RemovedLimboDocument","view_View","View","syncedDocuments","syncState","limboDocuments","mutatedKeys","documentSet","computeDocChanges","previousChanges","changeSet","oldDocumentSet","newMutatedKeys","newDocumentSet","needsRefill","lastDocInLimit","newMaybeDoc","oldDoc","docsEqual","applyChanges","sort","limboChanges","applyTargetChange","synced","newSyncState","Synced","Local","shouldBeInLimbo","targetMapping","oldLimboDocuments","QueryView","view","sync_engine_SyncEngine","localStore","remoteStore","currentUser","viewHandler","errorHandler","queryViewsByQuery","queryViewsByTarget","limboTargetsByKey","limboKeysByTarget","limboDocumentRefs","limboCollector","mutationUserCallbacks","targetIdGenerator","assertSubscribed","allocateQuery","executeQuery","remoteDocumentKeys","remoteKeys","viewDocChanges","viewChange","queryView","releaseQuery","removeAndCleanupQuery","write","batch","userCallback","localWrite","addMutationCallback","batchId","emitNewSnapsAndNotifyLocalStore","fillWritePipeline","wrapUpdateFunctionError","runTransaction","updateFunction","retries","transaction","createTransaction","userPromise","commit","applyRemoteEvent","remoteEvent","limboKey","rejectListen","docMap","event_1","queryView_1","applySuccessfulWrite","mutationBatchResult","processUserCallback","acknowledgeBatch","rejectFailedWrite","rejectBatch","newCallbacks","toKey","gcLimboDocuments","updateTrackedLimbos","limboChanges_1","limboChange","trackLimboChange","limboTargetId","currentLimboDocs","newSnaps","docChangesInAllViews","queriesProcessed","notifyLocalViewChanges","fnName","handleUserChange","user","BATCHID_UNKNOWN","mutation_batch_MutationBatch","MutationBatch","mutations","batchResult","mutationResults","keySet","isTombstone","toTombstone","mutation_batch_MutationBatchResult","MutationBatchResult","commitVersion","streamToken","docVersions","versionMap","DbTimestamp","ownerId","leaseTimestampMs","userId","lastAcknowledgedBatchId","lastStreamToken","localWriteTimeMs","DbDocumentMutation","prefixForUser","prefixForPath","PLACEHOLDER","DbNoDocument","noDocument","lastListenSequenceNumber","highestTargetId","highestListenSequenceNumber","lastRemoteSnapshotVersion","ALL_STORES","simple_db_SimpleDb","SimpleDb","openOrCreate","runUpgrade","isAvailable","window","indexedDB","onupgradeneeded","deleteDatabase","ua","navigator","userAgent","mode","objectStores","transactionFn","transactionFnResult","abort","completionPromise","IterationController","dbCursor","shouldStop","nextKey","done","skip","SimpleDbTransaction","objectStoresNames","aborted","onabort","oncomplete","storeName","objectStore","simple_db_SimpleDbStore","SimpleDbStore","put","keyOrValue","loadAll","indexOrRange","iterateCursor","deleteAll","keysOnly","control","iterate","optionsOrCallback","cursorRequest","controller","userResult","primaryKey","skipToKey","continue","indexName","reverse","openKeyCursor","openCursor","indexeddb_mutation_queue_IndexedDbMutationQueue","IndexedDbMutationQueue","serializer","forUser","uid","isUnauthenticated","loadNextBatchIdFromDb","nextBatchId","metadata","checkEmpty","empty","maxBatchId","nextUser","IDBKeyRange","keyForBatchId","getNextBatchId","getHighestAcknowledgedBatchId","getLastStreamToken","setLastStreamToken","addMutationBatch","dbBatch","toDbMutationBatch","mutations_1","indexKey","lookupMutationBatch","fromDbMutationBatch","getNextMutationBatchAfterBatchId","lowerBound","foundBatch","getAllMutationBatches","dbBatches","getAllMutationBatchesThroughBatchId","getAllMutationBatchesAffectingDocumentKey","documentKey","indexPrefix","indexStart","userID","encodedPath","batchID","mutationKey","getAllMutationBatchesAffectingQuery","queryPath","immediateChildrenLength","uniqueBatchIDs","removeMutationBatches","batches","indexTxn","this_1","batches_1","only","numDeleted","removePromise","performConsistencyCheck","startRange","danglingMutationReferences","gc","indexeddb_query_cache_IndexedDbQueryCache","IndexedDbQueryCache","lastSavedVersion","getHighestTargetId","getLastRemoteSnapshotVersion","setLastRemoteSnapshotVersion","addQueryData","addedQueryPromise","toDbTarget","removeQueryData","removeMatchingKeysForTargetId","getQueryData","fromDbTarget","addMatchingKeys","removeMatchingKeys","notifyGCForRemovedKeys","getMatchingKeysForTargetId","indexeddb_remote_document_cache_IndexedDbRemoteDocumentCache","IndexedDbRemoteDocumentCache","addEntry","maybeDocument","toDbRemoteDocument","removeEntry","getEntry","dbRemoteDoc","fromDbRemoteDocument","getDocumentsMatchingQuery","local_serializer_LocalSerializer","LocalSerializer","remoteSerializer","remoteDoc","serializedMutations","m","dbTarget","queryProto","dbTimestamp","EXISTING_OWNER_ERROR_MSG","indexeddb_persistence_IndexedDbPersistence","IndexedDbPersistence","prefix","generateOwnerId","dbName","MAIN_DATABASE","localStoragePrefix","started","simpleDb","tryAcquireOwnerLease","scheduleOwnerLeaseRefreshes","attachWindowUnloadHook","persistenceError","shutdown","detachWindowUnloadHook","stopOwnerLeaseRefreshes","releaseOwnerLease","getMutationQueue","getQueryCache","getRemoteDocumentCache","operation","ensureOwnerLease","buildStoragePrefix","isDefaultDatabase","dbOwner","validOwner","newDbOwner","minAcceptable","maxAcceptable","getZombiedOwnerId","ownerLeaseRefreshHandle","setInterval","reason","clearInterval","windowUnloadHandler","setZombiedOwnerId","addEventListener","removeEventListener","zombiedOwnerId","localStorage","getItem","zombiedOwnerLocalStorageKey","zombieOwnerId","removeItem","setItem","local_documents_view_LocalDocumentsView","LocalDocumentsView","remoteDocumentCache","mutationQueue","getDocument","computeLocalDocument","getDocuments","getDocumentsMatchingDocumentQuery","getDocumentsMatchingCollectionQuery","queryResults","computeLocalDocuments","promisedResults","matchingMutationBatches","matchingKeys","matchingMutationBatches_1","mutatedDoc","remote_document_change_buffer_RemoteDocumentChangeBuffer","RemoteDocumentChangeBuffer","assertChanges","bufferedEntry","local_store_LocalStore","persistence","initialUser","localViewReferences","heldBatchResults","remoteDocuments","queryCache","localDocuments","startMutationQueue","startQueryCache","oldBatches","promisedOldBatches","newBatches","changedKeys","_d","highestAck","ackedBatches","promisedBatch","changedDocuments","affected","shouldHoldBatchResult","documentBuffer_1","releaseBatchResults","promisedAffectedKeys","toReject","affectedKeys","promisedToReject","lastAcked","removeMutationBatch","documentBuffer","changedDocKeys","existingDoc","lastRemoteVersion","remoteVersion","releasedWriteKeys","releaseHeldBatchResults","promisedReleasedWriteKeys","viewChanges","viewChanges_1","nextMutationBatch","afterBatchId","readDocument","cached","documentBuffer_2","garbage","toRelease","isRemoteUpToVersion","batchResults","promiseChain","batchResults_1","applyWriteToRemoteDocuments","affectedDocs","batches_2","docKeys","ackVersion","memory_mutation_queue_MemoryMutationQueue","MemoryMutationQueue","highestAcknowledgedBatchId","batchesByDocumentKey","batchIndex","indexOfExistingBatchId","findMutationBatch","max","rawIndex","indexOfBatchId","getAllLiveMutationBatchesBeforeIndex","endIndex","immediateChildrenPathLength","startPath","rowKeyPath","batchCount","firstBatchId","queueCount","startIndex","queueIndex","length_1","references","memory_query_cache_MemoryQueryCache","MemoryQueryCache","memory_remote_document_cache_MemoryRemoteDocumentCache","MemoryRemoteDocumentCache","iterator","memory_persistence_MemoryPersistence","MemoryPersistence","mutationQueues","queue","MemoryPersistenceTransaction","no_op_garbage_collector_NoOpGarbageCollector","NoOpGarbageCollector","Deferred","backoff_ExponentialBackoff","ExponentialBackoff","initialDelayMs","backoffFactor","maxDelayMs","reset","currentBaseMs","resetToMax","backoffAndWait","def","delayWithJitterMs","jitterDelayMs","persistent_stream___extends","BACKOFF_INITIAL_DELAY_MS","BACKOFF_MAX_DELAY_MS","BACKOFF_FACTOR","persistent_stream_PersistentStream","PersistentStream","connection","credentialsProvider","initialBackoffDelay","stream","backoff","Initial","isStarted","Backoff","Auth","Open","isOpen","performBackoff","auth","stop","Stopped","inhibitBackoff","getToken","startStream","schedule","rpcError","handleStreamClose","dispatchIfNotStopped","startRpc","PersistentListenStream","watchChangeProto","onWatchChange","watch","addTarget","labels","unwatch","removeTarget","persistent_stream_PersistentWriteStream","PersistentWriteStream","handshakeComplete_","responseProto","writeResults","commitTime","onMutationResult","onHandshakeComplete","writeHandshake","writeMutations","writes","datastore_Datastore","Datastore","newPersistentWriteStream","newPersistentWatchStream","params","invokeRPC","response","lookup","transaction_Transaction","Transaction","datastore","readVersions","committed","recordVersion","docVersion","existingVersion","preconditionForUpdate","toMutations","unwritten","remote_store_RemoteStore","RemoteStore","asyncQueue","onlineStateHandler","pendingWrites","lastBatchSeen","accumulatedWatchChanges","watchStream","writeStream","watchStreamOnlineState","watchStreamFailures","enableNetwork","setOnlineStateToHealthy","updateAndBroadcastOnlineState","Healthy","setOnlineStateToUnknown","updateOnlineStateAfterFailure","didChange","isNetworkEnabled","onWatchStreamOpen","onWatchStreamClose","onWatchStreamChange","onWriteStreamOpen","onWriteStreamClose","onWriteHandshakeComplete","shouldStartWatchStream","startWatchStream","disableNetwork","cleanUpWatchStreamState","cleanUpWriteStreamState","sendWatchRequest","sendUnwatchRequest","recordPendingTargetRequest","handleTargetError","handleWatchChangeBatch","aggregator","deletedDoc","trackedRemote","newQueryData","requestQueryData","canWriteMutations","outstandingWrites","shouldStartWriteStream","startWriteStream","handshakeComplete","shift","success","errorHandling","handleWriteError","handleHandshakeError","firestore_client_FirestoreClient","FirestoreClient","usePersistence","initializationDone","persistenceResult","initialized","setUserChangeListener","initializePersistence","initializeRest","startIndexedDbPersistence","canFallback","warn","startMemoryPersistence","storagePrefix","onlineStateChangedHandler","eventMgr","verifyOperationInProgress","removeUserChangeListener","observer","deferred","AsyncObserver","muted","scheduleEvent","mute","eventHandler","async_queue_AsyncQueue","AsyncQueue","tail","delayedOpCount","operationInProgress","delay","deferred_1","scheduleInternal","stack","drain","User","otherUser","GOOGLE_CREDENTIALS","FIRST_PARTY","OAuthToken","Authorization","EmptyCredentialsProvider","userListener","forceRefresh","credentials_FirebaseCredentialsProvider","FirebaseCredentialsProvider","tokenListener","userCounter","newUser","getUser","addAuthTokenListener","initialUserCounter","tokenData","accessToken","removeAuthTokenListener","getUid","currentUid","GoogleCredentialsProvider","authClient","tokenLiteral","credentials_FirstPartyToken","FirstPartyToken","gapi","X-Goog-AuthUser","FirstPartyCredentialsProvider","api_field_value___extends","DeleteFieldValueImpl","serverTimestamp","ServerTimestampFieldValueImpl","PublicFieldValue","RESERVED_FIELD_REGEX","user_data_converter_ParsedSetData","ParsedSetData","user_data_converter_ParsedUpdateData","ParsedUpdateData","user_data_converter_ParseContext","ParseContext","arrayElement","validatePath","childContextForField","childPath","validatePathSegment","childContextForFieldPath","childContextForArray","fieldDescription","user_data_converter_UserDataConverter","UserDataConverter","preConverter","parseSetData","updateData","parseData","parseMergeData","parseUpdateData","fieldMaskPaths","childContext","runPreConverter","parsedValue","mask","parseUpdateVarargs","moreFieldsAndValues","value_1","parseQueryValue","parsed","parseArray","parseObject","parseScalarValue","entryIndex","array_1","entry","parsedEntry","database___extends","DEFAULT_HOST","DEFAULT_SSL","database_FirestoreSettings","FirestoreSettings","settings","FirestoreConfig","Firestore","databaseIdOrApp","_firestoreClient","config","firebaseApp","databaseIdFromApp","external_1","_config","_databaseId","settingsLiteral","newSettings","enablePersistence","configureClient","ensureClientConfigured","thisDb","otherDb","_key","_dataConverter","collection","pathString","database_CollectionReference","forPath","database_Transaction","database_WriteBatch","SILENT","level","_firestore","_transaction","fieldOrUpdateData","WriteBatch","_mutations","_committed","verifyNotCommitted","DocumentReference","isEqual","onSnapshot","includeMetadataChanges","currArg","internalOptions","complete","onSnapshotInternal","errHandler","asyncObserver","internalListener","DocumentSnapshot","_document","_fromCache","convertObject","convertValue","convertArray","database_Query","_query","opStr","validateNewFilter","directionStr","validateNewOrderBy","docOrField","boundFromDocOrFields","startAfter","endBefore","boundFromDocument","allFields","boundFromFields","components","rawValue","wrapped","database_QuerySnapshot","firestoreClient","existingField","validateOrderByAndInequalityMatch","inequality","QuerySnapshot","_originalQuery","_snapshot","_cachedChanges","thisArg","convertToDocumentImpl","CollectionReference","parentPath","docRef","PublicFirestore","PublicTransaction","PublicWriteBatch","PublicDocumentReference","PublicDocumentSnapshot","PublicQuery","PublicQuerySnapshot","PublicCollectionReference","115","l","a","aa","ba","propertyIsEnumerable","ca","da","fa","ha","unshift","r","Function","ia","u","L","Bb","ja","captureStackTrace","ka","ma","na","oa","w","qa","ra","ea","va","wa","xa","ya","y","x","Ba","Ca","Da","Ea","Ga","Fa","Ha","Ia","Ja","Oa","documentMode","Ua","la","Pa","h","A","Qa","ab","relatedTarget","button","screenY","screenX","clientY","clientX","metaKey","shiftKey","altKey","ctrlKey","pointerId","pointerType","changedTouches","srcElement","Ma","nodeName","fromElement","toElement","pageX","pageY","bb","defaultPrevented","fb","src","capture","eb","X","gb","hb","jb","sa","kb","ib","ob","once","pb","qb","$","rb","sb","lb","tb","$a","attachEvent","ub","nb","vb","Ya","wb","xb","detachEvent","mb","yb","zb","keyCode","returnValue","parentNode","Ab","handleEvent","B","P","J","Cb","Db","eval","Eb","Fb","Gb","Boolean","Hb","valueOf","Kb","Ib","Lb","g","Mb","Ob","Pb","Nb","Qb","Sb","MessageChannel","postMessage","createElement","style","display","documentElement","appendChild","contentWindow","location","protocol","origin","port1","onmessage","port2","onreadystatechange","removeChild","Ub","Tb","Vb","setImmediate","Window","Rb","C","Wb","Xb","t","Yb","Z","K","clearTimeout","Zb","$b","ac","W","D","cc","dc","fc","E","lc","F","G","hc","oc","nc","mc","jc","lastIndexOf","pc","ic","H","kc","qc","rc","parse","Sa","Jb","Pe","I","sc","tc","uc","dispatchEvent","vc","wc","xc","Ac","Bc","Cc","Ec","Fc","ActiveXObject","XMLHttpRequest","S","M","Gc","Hc","T","o","j","N","Ic","Lc","Mc","Nc","Oc","Pc","Qc","Ra","ta","Sc","Wc","Kc","Jc","Tc","Uc","Vc","Xc","Rc","Ka","Y","Na","Yc","Zc","O","ad","bd","$c","dd","decodeURIComponent","Q","ed","fd","gd","hd","match","cd","jd","kd","qd","ld","rd","R","sd","abs","td","ud","decodeURI","encodeURI","vd","xd","wd","yd","toLowerCase","zd","Bd","Ad","Cd","Dd","Fd","Gd","Hd","Id","Jd","Kd","Md","Nd","Od","Pd","pa","La","Qd","Rd","Sd","Td","Ud","Vd","Wd","Xd","encodeURIComponent","Yd","Image","onload","Zd","ontimeout","U","$d","ee","z","timeout","ce","fe","ge","he","goog","V","self","ae","de","readyState","ie","je","ke","za","Va","Aa","ga","concurrentRequestLimit","fastHandshake","le","me","ne","sendBeacon","oe","cancel","pe","qe","re","te","se","round","Wa","ue","ve","we","xe","Ld","ye","hostname","port","ze","Ae","Be","testUrl","messageUrlParams","messageHeaders","clientProtocolHeaderRequired","X-Client-Protocol","httpHeadersOverwriteParam","Ce","De","Ee","Ge","He","Ie","Je","Ke","Le","Me","Ne","Oe","trim","Ta","parseFloat","compatMode","Xa","freeze","Za","2","3","4","preventDefault","\"","\\","/","\b","\f","\n","\r","\t","\u000b","bc","ec","timeStamp","msWriteProfilerMark","yc","zc","Dc","md","nd","od","pd","Ed","getResponseHeader","be","toUpperCase","FormData","setRequestHeader","responseType","withCredentials","statusText","responseText","__data__","Fe","createWebChannelTransport","ErrorCode","WebChannel","XhrIoPool"],"mappings":"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","file":"firebase-firestore.js","sourcesContent":["/*!\n * @license Firebase v4.6.1\n * Build: rev-0ea11f2\n * Terms: https://firebase.google.com/terms/\n */\ntry {\n        webpackJsonpFirebase([1],{\n\n/***/ 113:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n__webpack_require__(114);\n\n\n/***/ }),\n\n/***/ 114:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ../app/dist/esm/index.js + 1 modules\nvar esm = __webpack_require__(6);\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/version.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** The semver (www.semver.org) version of the SDK. */\nvar SDK_VERSION = esm[\"default\"].SDK_VERSION;\n\n//# sourceMappingURL=version.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/log.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* tslint:disable:no-console */\n\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"ERROR\"] = 1] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 2] = \"SILENT\";\n})(LogLevel = LogLevel || (LogLevel = {}));\nvar logLevel = LogLevel.ERROR;\n// Helper methods are needed because variables can't be exported as read/write\nfunction getLogLevel() {\n    return logLevel;\n}\nfunction setLogLevel(newLevel) {\n    logLevel = newLevel;\n}\nfunction debug(tag, msg) {\n    var obj = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        obj[_i - 2] = arguments[_i];\n    }\n    if (logLevel <= LogLevel.DEBUG) {\n        var time = new Date().toISOString();\n        var args = obj.map(argToString);\n        console.log.apply(console, [\"Firestore (\" + SDK_VERSION + \") \" + time + \" [\" + tag + \"]: \" + msg].concat(args));\n    }\n}\nfunction log_error(msg) {\n    var obj = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        obj[_i - 1] = arguments[_i];\n    }\n    if (logLevel <= LogLevel.ERROR) {\n        var time = new Date().toISOString();\n        var args = obj.map(argToString);\n        console.error.apply(console, [\"Firestore (\" + SDK_VERSION + \") \" + time + \": \" + msg].concat(args));\n    }\n}\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj) {\n    if (typeof obj === 'string') {\n        return obj;\n    }\n    else {\n        try {\n            return JSON.stringify(obj);\n        }\n        catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n\n//# sourceMappingURL=log.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/assert.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Unconditionally fails, throwing an Error with the given message.\n *\n * Returns any so it can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nfunction fail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    var message = \"FIRESTORE (\" + SDK_VERSION + \") INTERNAL ASSERTION FAILED: \" + failure;\n    log_error(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n */\nfunction assert(assertion, message) {\n    if (!assertion) {\n        fail(message);\n    }\n}\n\n//# sourceMappingURL=assert.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform/platform.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Provides singleton helpers where setup code can inject a platform at runtime.\n * setPlatform needs to be set before Firestore is used and must be set exactly\n * once.\n */\nvar platform_PlatformSupport = /** @class */ (function () {\n    function PlatformSupport() {\n    }\n    PlatformSupport.setPlatform = function (platform) {\n        if (PlatformSupport.platform) {\n            fail('Platform already defined');\n        }\n        PlatformSupport.platform = platform;\n    };\n    PlatformSupport.getPlatform = function () {\n        if (!PlatformSupport.platform) {\n            fail('Platform not set');\n        }\n        return PlatformSupport.platform;\n    };\n    return PlatformSupport;\n}());\n\n/**\n * Returns the representation of an empty \"proto\" byte string for the\n * platform.\n */\nfunction emptyByteString() {\n    return platform_PlatformSupport.getPlatform().emptyByteString;\n}\n\n//# sourceMappingURL=platform.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/error.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n// TODO(mcg): Change to a string enum once we've upgraded to typescript 2.4.\n//  tslint:disable-next-line:variable-name Intended to look like a TS 2.4 enum\nvar Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */\n    OK: 'ok',\n    /** The operation was cancelled (typically by the caller). */\n    CANCELLED: 'cancelled',\n    /** Unknown error or an error from a different error domain. */\n    UNKNOWN: 'unknown',\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    INVALID_ARGUMENT: 'invalid-argument',\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\n    /** Some requested entity (e.g., file or directory) was not found. */\n    NOT_FOUND: 'not-found',\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    ALREADY_EXISTS: 'already-exists',\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller can not be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    PERMISSION_DENIED: 'permission-denied',\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    UNAUTHENTICATED: 'unauthenticated',\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operation's execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    FAILED_PRECONDITION: 'failed-precondition',\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    ABORTED: 'aborted',\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    OUT_OF_RANGE: 'out-of-range',\n    /** Operation is not implemented or not supported/enabled in this service. */\n    UNIMPLEMENTED: 'unimplemented',\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    INTERNAL: 'internal',\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    UNAVAILABLE: 'unavailable',\n    /** Unrecoverable data loss or corruption. */\n    DATA_LOSS: 'data-loss'\n};\n/**\n * An error class used for Firestore-generated errors. Ideally we should be\n * using FirebaseError, but integrating with it is overly arduous at the moment,\n * so we define our own compatible error class (with a `name` of 'FirebaseError'\n * and compatible `code` and `message` fields.)\n */\nvar FirestoreError = /** @class */ (function (_super) {\n    __extends(FirestoreError, _super);\n    function FirestoreError(code, message) {\n        var _this = _super.call(this, message) || this;\n        _this.code = code;\n        _this.message = message;\n        _this.name = 'FirebaseError';\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        _this.toString = function () { return _this.name + \": [code=\" + _this.code + \"]: \" + _this.message; };\n        return _this;\n    }\n    return FirestoreError;\n}(Error));\n\n\n//# sourceMappingURL=error.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/api.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// We are doing some heavy reflective stuff, lots of any casting necessary\n/* tslint:disable:no-any */\n\n/**\n * Helper function to prevent instantiation through the constructor.\n *\n * This method creates a new constructor that throws when it's invoked.\n * The prototype of that constructor is then set to the prototype of the hidden\n * \"class\" to expose all the prototype methods and allow for instanceof\n * checks.\n *\n * To also make all the static methods available, all properties of the\n * original constructor are copied to the new constructor.\n */\nfunction makeConstructorPrivate(cls, optionalMessage) {\n    function PublicConstructor() {\n        var error = 'This constructor is private.';\n        if (optionalMessage) {\n            error += ' ';\n            error += optionalMessage;\n        }\n        throw new FirestoreError(Code.INVALID_ARGUMENT, error);\n    }\n    // Make sure instanceof checks work and all methods are exposed on the public\n    // constructor\n    PublicConstructor.prototype = cls.prototype;\n    // Copy any static methods/members\n    for (var staticProperty in cls) {\n        if (cls.hasOwnProperty(staticProperty)) {\n            PublicConstructor[staticProperty] = cls[staticProperty];\n        }\n    }\n    return PublicConstructor;\n}\n\n//# sourceMappingURL=api.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/obj.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction get(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : null;\n}\nfunction obj_size(obj) {\n    var count = 0;\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\n/** Returns the given value if it's defined or the defaultValue otherwise. */\nfunction defaulted(value, defaultValue) {\n    return value !== undefined ? value : defaultValue;\n}\nfunction forEachNumber(obj, fn) {\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var num = parseInt(key, 10);\n            if (!isNaN(num)) {\n                fn(num, obj[key]);\n            }\n        }\n    }\n}\nfunction forEach(obj, fn) {\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nfunction lookupOrInsert(obj, key, valFn) {\n    if (!contains(obj, key)) {\n        obj[key] = valFn();\n    }\n    return obj[key];\n}\nfunction isEmpty(obj) {\n    assert(obj != null && typeof obj === 'object', 'isEmpty() expects object parameter.');\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction shallowCopy(obj) {\n    assert(obj && typeof obj === 'object', 'shallowCopy() expects object parameter.');\n    var result = {};\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=obj.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/input_validation.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Validates the invocation of functionName has the exact number of arguments.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateExactNumberOfArgs('myFunction', arguments, 2);\n */\nfunction validateExactNumberOfArgs(functionName, args, numberOfArgs) {\n    if (args.length !== numberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires \" +\n            formatPlural(numberOfArgs, 'argument') +\n            ', but was called with ' +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the invocation of functionName has at least the provided number of\n * arguments (but can have many more).\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateAtLeastNumberOfArgs('myFunction', arguments, 2);\n */\nfunction validateAtLeastNumberOfArgs(functionName, args, minNumberOfArgs) {\n    if (args.length < minNumberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires at least \" +\n            formatPlural(minNumberOfArgs, 'argument') +\n            ', but was called with ' +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the invocation of functionName has number of arguments between\n * the values provided.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateBetweenNumberOfArgs('myFunction', arguments, 2, 3);\n */\nfunction validateBetweenNumberOfArgs(functionName, args, minNumberOfArgs, maxNumberOfArgs) {\n    if (args.length < minNumberOfArgs || args.length > maxNumberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires between \" + minNumberOfArgs + \" and \" +\n            (maxNumberOfArgs + \" arguments, but was called with \") +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the provided argument is an array and has as least the expected\n * number of elements.\n */\nfunction validateNamedArrayAtLeastNumberOfElements(functionName, value, name, minNumberOfElements) {\n    if (!(value instanceof Array) || value.length < minNumberOfElements) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + name + \" argument to be an \" +\n            'array with at least ' +\n            (formatPlural(minNumberOfElements, 'element') + \".\"));\n    }\n}\n/**\n * Validates the provided positional argument has the native JavaScript type\n * using typeof checks.\n */\nfunction validateArgType(functionName, type, position, argument) {\n    validateType(functionName, type, ordinal(position) + \" argument\", argument);\n}\n/**\n * Validates the provided argument has the native JavaScript type using\n * typeof checks or is undefined.\n */\nfunction validateOptionalArgType(functionName, type, position, argument) {\n    if (argument !== undefined) {\n        validateArgType(functionName, type, position, argument);\n    }\n}\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks.\n */\nfunction validateNamedType(functionName, type, optionName, argument) {\n    validateType(functionName, type, optionName + \" option\", argument);\n}\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks or is undefined.\n */\nfunction validateNamedOptionalType(functionName, type, optionName, argument) {\n    if (argument !== undefined) {\n        validateNamedType(functionName, type, optionName, argument);\n    }\n}\n/** Helper to validate the type of a provided input. */\nfunction validateType(functionName, type, inputName, input) {\n    if (typeof input !== type || (type === 'object' && !isPlainObject(input))) {\n        var description = valueDescription(input);\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + inputName + \" \" +\n            (\"to be of type \" + type + \", but it was: \" + description));\n    }\n}\n/**\n * Returns true iff it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nfunction isPlainObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        Object.getPrototypeOf(input) === Object.prototype);\n}\n/** Returns a string describing the type / value of the provided input. */\nfunction valueDescription(input) {\n    if (input === undefined) {\n        return 'undefined';\n    }\n    else if (input === null) {\n        return 'null';\n    }\n    else if (typeof input === 'string') {\n        if (input.length > 20) {\n            input = input.substring(0, 20) + \"...\";\n        }\n        return JSON.stringify(input);\n    }\n    else if (typeof input === 'number' || typeof input === 'boolean') {\n        return '' + input;\n    }\n    else if (typeof input === 'object') {\n        if (input instanceof Array) {\n            return 'an array';\n        }\n        else {\n            var customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return \"a custom \" + customObjectName + \" object\";\n            }\n            else {\n                return 'an object';\n            }\n        }\n    }\n    else if (typeof input === 'function') {\n        return 'a function';\n    }\n    else {\n        return fail('Unknown wrong type: ' + typeof input);\n    }\n}\n/** Hacky method to try to get the constructor name for an object. */\nfunction tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        var funcNameRegex = /function\\s+([^\\s(]+)\\s*\\(/;\n        var results = funcNameRegex.exec(input.constructor.toString());\n        if (results && results.length > 1) {\n            return results[1];\n        }\n    }\n    return null;\n}\n/** Validates the provided argument is defined. */\nfunction validateDefined(functionName, position, argument) {\n    if (argument === undefined) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires a valid \" + ordinal(position) + \" \" +\n            \"argument, but it was undefined.\");\n    }\n}\n/**\n * Validates the provided positional argument is an object, and its keys and\n * values match the expected keys and types provided in optionTypes.\n */\nfunction validateOptionNames(functionName, options, optionNames) {\n    forEach(options, function (key, _) {\n        if (optionNames.indexOf(key) < 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Unknown option '\" + key + \"' passed to function \" + functionName + \"(). \" +\n                'Available options: ' +\n                optionNames.join(', '));\n        }\n    });\n}\n/**\n * Helper method to throw an error that the provided argument did not pass\n * an instanceof check.\n */\nfunction invalidClassError(functionName, type, position, argument) {\n    var description = valueDescription(argument);\n    return new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + ordinal(position) + \" \" +\n        (\"argument to be a \" + type + \", but it was: \" + description));\n}\n/** Converts a number to its english word representation */\nfunction ordinal(num) {\n    switch (num) {\n        case 1:\n            return 'first';\n        case 2:\n            return 'second';\n        case 3:\n            return 'third';\n        default:\n            return num + 'th';\n    }\n}\n/**\n * Formats the given word as plural conditionally given the preceding number.\n */\nfunction formatPlural(num, str) {\n    return num + \" \" + str + (num === 1 ? '' : 's');\n}\n\n//# sourceMappingURL=input_validation.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/misc.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// tslint:disable-next-line:class-as-namespace\nvar misc_AutoId = /** @class */ (function () {\n    function AutoId() {\n    }\n    AutoId.newId = function () {\n        // Alphanumeric characters\n        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var autoId = '';\n        for (var i = 0; i < 20; i++) {\n            autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n        return autoId;\n    };\n    return AutoId;\n}());\n\nfunction primitiveComparator(left, right) {\n    if (left < right)\n        return -1;\n    if (left > right)\n        return 1;\n    return 0;\n}\n/** Helper to compare nullable (or undefined-able) objects using equals(). */\nfunction equals(left, right) {\n    if (left !== null && left !== undefined) {\n        return !!(right && left.equals(right));\n    }\n    else {\n        // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n        // smart enough.\n        return left === right;\n    }\n}\n/** Helper to compare arrays using equals(). */\nfunction arrayEquals(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (var i = 0; i < left.length; i++) {\n        if (!left[i].equals(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\nfunction immediatePredecessor(s) {\n    // We can decrement the last character in the string and be done\n    // unless that character is 0 (0x0000), in which case we have to erase the\n    // last character.\n    var lastIndex = s.length - 1;\n    if (s.length === 0) {\n        // Special case the empty string.\n        return '';\n    }\n    else if (s.charAt(lastIndex) === '\\0') {\n        return s.substring(0, lastIndex);\n    }\n    else {\n        return (s.substring(0, lastIndex) +\n            String.fromCharCode(s.charCodeAt(lastIndex) - 1));\n    }\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nfunction immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n//# sourceMappingURL=misc.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/blob.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/** Helper function to assert Uint8Array is available at runtime. */\nfunction assertUint8ArrayAvailable() {\n    if (typeof Uint8Array === 'undefined') {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'Uint8Arrays are not available in this environment.');\n    }\n}\n/** Helper function to assert Base64 functions are available at runtime. */\nfunction assertBase64Available() {\n    if (!platform_PlatformSupport.getPlatform().base64Available) {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'Blobs are unavailable in Firestore in this environment.');\n    }\n}\n/**\n * Immutable class holding a blob (binary data).\n * This class is directly exposed in the public API.\n *\n * Note that while you can't hide the constructor in JavaScript code, we are\n * using the hack above to make sure no-one outside this module can call it.\n */\nvar blob_Blob = /** @class */ (function () {\n    function Blob(binaryString) {\n        assertBase64Available();\n        this._binaryString = binaryString;\n    }\n    Blob.fromBase64String = function (base64) {\n        validateExactNumberOfArgs('Blob.fromBase64String', arguments, 1);\n        validateArgType('Blob.fromBase64String', 'string', 1, base64);\n        assertBase64Available();\n        try {\n            var binaryString = platform_PlatformSupport.getPlatform().atob(base64);\n            return new Blob(binaryString);\n        }\n        catch (e) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct Blob from Base64 string: ' + e);\n        }\n    };\n    Blob.fromUint8Array = function (array) {\n        validateExactNumberOfArgs('Blob.fromUint8Array', arguments, 1);\n        assertUint8ArrayAvailable();\n        if (!(array instanceof Uint8Array)) {\n            throw invalidClassError('Blob.fromUint8Array', 'Uint8Array', 1, array);\n        }\n        // We can't call array.map directly because it expects the return type to\n        // be a Uint8Array, whereas we can convert it to a regular array by invoking\n        // map on the Array prototype.\n        var binaryString = Array.prototype.map\n            .call(array, function (char) {\n            return String.fromCharCode(char);\n        })\n            .join('');\n        return new Blob(binaryString);\n    };\n    Blob.prototype.toBase64 = function () {\n        validateExactNumberOfArgs('Blob.toBase64', arguments, 0);\n        assertBase64Available();\n        return platform_PlatformSupport.getPlatform().btoa(this._binaryString);\n    };\n    Blob.prototype.toUint8Array = function () {\n        validateExactNumberOfArgs('Blob.toUint8Array', arguments, 0);\n        assertUint8ArrayAvailable();\n        var buffer = new Uint8Array(this._binaryString.length);\n        for (var i = 0; i < this._binaryString.length; i++) {\n            buffer[i] = this._binaryString.charCodeAt(i);\n        }\n        return buffer;\n    };\n    Blob.prototype.toString = function () {\n        return 'Blob(base64: ' + this.toBase64() + ')';\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    Blob.prototype._equals = function (other) {\n        return this._binaryString === other._binaryString;\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    Blob.prototype._compareTo = function (other) {\n        return primitiveComparator(this._binaryString, other._binaryString);\n    };\n    return Blob;\n}());\n\n// Public instance that disallows construction at runtime. This constructor is\n// used when exporting Blob on firebase.firestore.Blob and will be called Blob\n// publicly. Internally we still use Blob which has a type checked private\n// constructor. Note that Blob and PublicBlob can be used interchangeably in\n// instanceof checks.\n// For our internal TypeScript code PublicBlob doesn't exist as a type, and so\n// we need to use Blob as type and export it too.\n// tslint:disable-next-line:variable-name We're treating this as a class name.\nvar PublicBlob = makeConstructorPrivate(blob_Blob, 'Use Blob.fromUint8Array() or Blob.fromBase64String() instead.');\n\n//# sourceMappingURL=blob.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/geo_point.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Immutable class representing a geo point as latitude-longitude pair.\n * This class is directly exposed in the public API, including its constructor.\n */\nvar geo_point_GeoPoint = /** @class */ (function () {\n    function GeoPoint(latitude, longitude) {\n        validateExactNumberOfArgs('GeoPoint', arguments, 2);\n        validateArgType('GeoPoint', 'number', 1, latitude);\n        validateArgType('GeoPoint', 'number', 2, longitude);\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    Object.defineProperty(GeoPoint.prototype, \"latitude\", {\n        /**\n         * Returns the latitude of this geo point, a number between -90 and 90.\n         */\n        get: function () {\n            return this._lat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GeoPoint.prototype, \"longitude\", {\n        /**\n         * Returns the longitude of this geo point, a number between -180 and 180.\n         */\n        get: function () {\n            return this._long;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    GeoPoint.prototype._equals = function (other) {\n        return this._lat === other._lat && this._long === other._long;\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    GeoPoint.prototype._compareTo = function (other) {\n        return (primitiveComparator(this._lat, other._lat) ||\n            primitiveComparator(this._long, other._long));\n    };\n    return GeoPoint;\n}());\n\n\n//# sourceMappingURL=geo_point.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/database_info.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar DatabaseInfo = /** @class */ (function () {\n    /**\n     * Constructs a DatabaseInfo using the provided host, databaseId and\n     * persistenceKey.\n     *\n     * @param databaseId The database to use.\n     * @param persistenceKey A unique identifier for this Firestore's local\n     * storage (used in conjunction with the databaseId).\n     * @param host The Firestore backend host to connect to.\n     * @param ssl Whether to use SSL when connecting.\n     */\n    function DatabaseInfo(databaseId, persistenceKey, host, ssl) {\n        this.databaseId = databaseId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n    }\n    return DatabaseInfo;\n}());\n\n/** The default database name for a project. */\nvar DEFAULT_DATABASE_NAME = '(default)';\n/** Represents the database ID a Firestore client is associated with. */\nvar database_info_DatabaseId = /** @class */ (function () {\n    function DatabaseId(projectId, database) {\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    Object.defineProperty(DatabaseId.prototype, \"isDefaultDatabase\", {\n        get: function () {\n            return this.database === DEFAULT_DATABASE_NAME;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DatabaseId.prototype.equals = function (other) {\n        return (other instanceof DatabaseId &&\n            other.projectId === this.projectId &&\n            other.database === this.database);\n    };\n    DatabaseId.prototype.compareTo = function (other) {\n        return (primitiveComparator(this.projectId, other.projectId) ||\n            primitiveComparator(this.database, other.database));\n    };\n    return DatabaseId;\n}());\n\n\n//# sourceMappingURL=database_info.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/path.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar path___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nvar path_Path = /** @class */ (function () {\n    function Path(segments, offset, length) {\n        this.init(segments, offset, length);\n    }\n    /**\n     * An initialization method that can be called from outside the constructor.\n     * We need this so that we can have a non-static construct method that returns\n     * the polymorphic `this` type.\n     */\n    Path.prototype.init = function (segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail('offset ' + offset + ' out of range ' + segments.length);\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail('length ' + length + ' out of range ' + (segments.length - offset));\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    };\n    /**\n     * Constructs a new instance of Path using the same concrete type as `this`.\n     * We need this instead of using the normal constructor, because polymorphic\n     * `this` doesn't work on static methods.\n     */\n    Path.prototype.construct = function (segments, offset, length) {\n        var path = Object.create(Object.getPrototypeOf(this));\n        path.init(segments, offset, length);\n        return path;\n    };\n    Object.defineProperty(Path.prototype, \"length\", {\n        get: function () {\n            return this.len;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path.prototype.equals = function (other) {\n        return Path.comparator(this, other) === 0;\n    };\n    Path.prototype.child = function (nameOrPath) {\n        var segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof Path) {\n            nameOrPath.forEach(function (segment) {\n                segments.push(segment);\n            });\n        }\n        else if (typeof nameOrPath === 'string') {\n            segments.push(nameOrPath);\n        }\n        else {\n            fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n        }\n        return this.construct(segments);\n    };\n    /** The index of one past the last segment of the path. */\n    Path.prototype.limit = function () {\n        return this.offset + this.length;\n    };\n    Path.prototype.popFirst = function (size) {\n        size = size === undefined ? 1 : size;\n        assert(this.length >= size, \"Can't call popFirst() with less segments\");\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    };\n    Path.prototype.popLast = function () {\n        assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n        return this.construct(this.segments, this.offset, this.length - 1);\n    };\n    Path.prototype.firstSegment = function () {\n        assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n        return this.segments[this.offset];\n    };\n    Path.prototype.lastSegment = function () {\n        assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n        return this.segments[this.limit() - 1];\n    };\n    Path.prototype.get = function (index) {\n        assert(index < this.length, 'Index out of range');\n        return this.segments[this.offset + index];\n    };\n    Path.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    Path.prototype.isPrefixOf = function (other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Path.prototype.forEach = function (fn) {\n        for (var i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    };\n    Path.prototype.toArray = function () {\n        return this.segments.slice(this.offset, this.limit());\n    };\n    Path.comparator = function (p1, p2) {\n        var len = Math.min(p1.length, p2.length);\n        for (var i = 0; i < len; i++) {\n            var left = p1.get(i);\n            var right = p2.get(i);\n            if (left < right)\n                return -1;\n            if (left > right)\n                return 1;\n        }\n        if (p1.length < p2.length)\n            return -1;\n        if (p1.length > p2.length)\n            return 1;\n        return 0;\n    };\n    return Path;\n}());\n\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nvar path_ResourcePath = /** @class */ (function (_super) {\n    path___extends(ResourcePath, _super);\n    function ResourcePath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourcePath.prototype.canonicalString = function () {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    };\n    ResourcePath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Creates a resource path from the given slash-delimited string.\n     */\n    ResourcePath.fromString = function (path) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        if (path.indexOf('//') >= 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid path (\" + path + \"). Paths must not contain // in them.\");\n        }\n        // We may still have an empty segment at the beginning or end if they had a\n        // leading or trailing slash (which we allow).\n        var segments = path.split('/').filter(function (segment) { return segment.length > 0; });\n        return new ResourcePath(segments);\n    };\n    ResourcePath.EMPTY_PATH = new ResourcePath([]);\n    return ResourcePath;\n}(path_Path));\n\nvar identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/** A dot-separated path for navigating sub-objects within a document. */\nvar path_FieldPath = /** @class */ (function (_super) {\n    path___extends(FieldPath, _super);\n    function FieldPath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    FieldPath.isValidIdentifier = function (segment) {\n        return identifierRegExp.test(segment);\n    };\n    FieldPath.prototype.canonicalString = function () {\n        return this.toArray()\n            .map(function (str) {\n            str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n            if (!FieldPath.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    };\n    FieldPath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    FieldPath.prototype.isKeyField = function () {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    };\n    /**\n     * The field designating the key of a document.\n     */\n    FieldPath.keyField = function () {\n        return new FieldPath([DOCUMENT_KEY_NAME]);\n    };\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    FieldPath.fromServerFormat = function (path) {\n        var segments = [];\n        var current = '';\n        var i = 0;\n        var addCurrentSegment = function () {\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, begin \" +\n                    \"with '.', end with '.', or contain '..'\");\n            }\n            segments.push(current);\n            current = '';\n        };\n        var inBackticks = false;\n        while (i < path.length) {\n            var c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                var next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath(segments);\n    };\n    FieldPath.EMPTY_PATH = new FieldPath([]);\n    return FieldPath;\n}(path_Path));\n\n\n//# sourceMappingURL=path.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/document_key.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar document_key_DocumentKey = /** @class */ (function () {\n    function DocumentKey(path) {\n        this.path = path;\n        assert(DocumentKey.isDocumentKey(path), 'Invalid DocumentKey with an odd number of segments: ' +\n            path.toArray().join('/'));\n    }\n    DocumentKey.prototype.equals = function (other) {\n        return (other !== null && path_ResourcePath.comparator(this.path, other.path) === 0);\n    };\n    DocumentKey.prototype.toString = function () {\n        return this.path.toString();\n    };\n    DocumentKey.comparator = function (k1, k2) {\n        return path_ResourcePath.comparator(k1.path, k2.path);\n    };\n    DocumentKey.isDocumentKey = function (path) {\n        return path.length % 2 === 0;\n    };\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param path The segments of the path to the document\n     * @return A new instance of DocumentKey\n     */\n    DocumentKey.fromSegments = function (segments) {\n        return new DocumentKey(new path_ResourcePath(segments.slice()));\n    };\n    /**\n     * Creates and returns a new document key using '/' to split the string into\n     * segments.\n     *\n     * @param path The slash-separated path string to the document\n     * @return A new instance of DocumentKey\n     */\n    DocumentKey.fromPathString = function (path) {\n        return new DocumentKey(path_ResourcePath.fromString(path));\n    };\n    DocumentKey.EMPTY = new DocumentKey(new path_ResourcePath([]));\n    return DocumentKey;\n}());\n\n\n//# sourceMappingURL=document_key.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/document.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar document_Document = /** @class */ (function () {\n    function Document(key, version, data, options) {\n        this.key = key;\n        this.version = version;\n        this.data = data;\n        this.hasLocalMutations = options.hasLocalMutations;\n    }\n    Document.prototype.field = function (path) {\n        return this.data.field(path);\n    };\n    Document.prototype.fieldValue = function (path) {\n        var field = this.field(path);\n        return field ? field.value() : undefined;\n    };\n    Document.prototype.value = function () {\n        return this.data.value();\n    };\n    Document.prototype.equals = function (other) {\n        return (other instanceof Document &&\n            this.key.equals(other.key) &&\n            this.version.equals(other.version) &&\n            this.data.equals(other.data) &&\n            this.hasLocalMutations === other.hasLocalMutations);\n    };\n    Document.prototype.toString = function () {\n        return (\"Document(\" + this.key + \", \" + this.version + \", \" + this.data.toString() + \", \" +\n            (\"{hasLocalMutations: \" + this.hasLocalMutations + \"})\"));\n    };\n    Document.compareByKey = function (d1, d2) {\n        return document_key_DocumentKey.comparator(d1.key, d2.key);\n    };\n    Document.compareByField = function (field, d1, d2) {\n        var v1 = d1.field(field);\n        var v2 = d2.field(field);\n        if (v1 !== undefined && v2 !== undefined) {\n            return v1.compareTo(v2);\n        }\n        else {\n            return fail(\"Trying to compare documents on fields that don't exist\");\n        }\n    };\n    return Document;\n}());\n\n/**\n * A class representing a deleted document.\n * Version is set to 0 if we don't point to any specific time, otherwise it\n * denotes time we know it didn't exist at.\n */\nvar document_NoDocument = /** @class */ (function () {\n    function NoDocument(key, version) {\n        this.key = key;\n        this.version = version;\n    }\n    NoDocument.prototype.toString = function () {\n        return \"NoDocument(\" + this.key + \", \" + this.version + \")\";\n    };\n    NoDocument.prototype.equals = function (other) {\n        return (other && other.version.equals(this.version) && other.key.equals(this.key));\n    };\n    NoDocument.compareByKey = function (d1, d2) {\n        return document_key_DocumentKey.comparator(d1.key, d2.key);\n    };\n    return NoDocument;\n}());\n\n\n//# sourceMappingURL=document.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/sorted_map.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nvar sorted_map_SortedMap = /** @class */ (function () {\n    function SortedMap(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : sorted_map_LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    SortedMap.prototype.insert = function (key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, sorted_map_LLRBNode.BLACK, null, null));\n    };\n    // Returns a copy of the map, with the specified key removed.\n    SortedMap.prototype.remove = function (key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, sorted_map_LLRBNode.BLACK, null, null));\n    };\n    // Returns the value of the node with the given key, or null.\n    SortedMap.prototype.get = function (key) {\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    };\n    // Returns the key of the item *before* the specified key, or null if key is\n    // the first item.\n    SortedMap.prototype.getPredecessorKey = function (key) {\n        var node = this.root;\n        var rightParent = null;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                if (!node.left.isEmpty()) {\n                    node = node.left;\n                    while (!node.right.isEmpty())\n                        node = node.right;\n                    return node.key;\n                }\n                else if (rightParent) {\n                    return rightParent.key;\n                }\n                else {\n                    return null; // first item.\n                }\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                rightParent = node;\n                node = node.right;\n            }\n        }\n        throw fail('Attempted to find predecessor key for a nonexistent key.' +\n            '  What gives?');\n    };\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    SortedMap.prototype.indexOf = function (key) {\n        // Number of nodes that were pruned when descending right\n        var prunedNodes = 0;\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    };\n    SortedMap.prototype.isEmpty = function () {\n        return this.root.isEmpty();\n    };\n    Object.defineProperty(SortedMap.prototype, \"size\", {\n        // Returns the total number of nodes in the map.\n        get: function () {\n            return this.root.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Returns the minimum key in the map.\n    SortedMap.prototype.minKey = function () {\n        return this.root.minKey();\n    };\n    // Returns the maximum key in the map.\n    SortedMap.prototype.maxKey = function () {\n        return this.root.maxKey();\n    };\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.inorderTraversal = function (action) {\n        return this.root.inorderTraversal(action);\n    };\n    SortedMap.prototype.forEach = function (fn) {\n        this.inorderTraversal(function (k, v) {\n            fn(k, v);\n            return false;\n        });\n    };\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.reverseTraversal = function (action) {\n        return this.root.reverseTraversal(action);\n    };\n    SortedMap.prototype.getIterator = function (resultGenerator) {\n        return new sorted_map_SortedMapIterator(this.root, null, this.comparator, false, resultGenerator);\n    };\n    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {\n        return new sorted_map_SortedMapIterator(this.root, key, this.comparator, false, resultGenerator);\n    };\n    SortedMap.prototype.getReverseIterator = function (resultGenerator) {\n        return new sorted_map_SortedMapIterator(this.root, null, this.comparator, true, resultGenerator);\n    };\n    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {\n        return new sorted_map_SortedMapIterator(this.root, key, this.comparator, true, resultGenerator);\n    };\n    return SortedMap;\n}()); // end SortedMap\n\n// An iterator over an LLRBNode.\nvar sorted_map_SortedMapIterator = /** @class */ (function () {\n    function SortedMapIterator(node, startKey, comparator, isReverse, resultGenerator) {\n        this.resultGenerator = resultGenerator || null;\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        var cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse)\n                cmp *= -1;\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    SortedMapIterator.prototype.getNext = function () {\n        assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');\n        var node = this.nodeStack.pop();\n        var result;\n        if (this.resultGenerator)\n            result = this.resultGenerator(node.key, node.value);\n        else\n            result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    };\n    SortedMapIterator.prototype.hasNext = function () {\n        return this.nodeStack.length > 0;\n    };\n    SortedMapIterator.prototype.peek = function () {\n        if (this.nodeStack.length === 0)\n            return null;\n        var node = this.nodeStack[this.nodeStack.length - 1];\n        if (this.resultGenerator) {\n            return this.resultGenerator(node.key, node.value);\n        }\n        else {\n            return { key: node.key, value: node.value };\n        }\n    };\n    return SortedMapIterator;\n}()); // end SortedMapIterator\n\n// Represents a node in a Left-leaning Red-Black tree.\nvar sorted_map_LLRBNode = /** @class */ (function () {\n    function LLRBNode(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    LLRBNode.prototype.copy = function (key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    };\n    LLRBNode.prototype.isEmpty = function () {\n        return false;\n    };\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.inorderTraversal = function (action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    };\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.reverseTraversal = function (action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    };\n    // Returns the minimum node in the tree.\n    LLRBNode.prototype.min = function () {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.minKey = function () {\n        return this.min().key;\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.maxKey = function () {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    };\n    // Returns new tree, with the key/value added.\n    LLRBNode.prototype.insert = function (key, value, comparator) {\n        var n = this;\n        var cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.removeMin = function () {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        var n = this;\n        if (!n.left.isRed() && !n.left.left.isRed())\n            n = n.moveRedLeft();\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    };\n    // Returns new tree, with the specified item removed.\n    LLRBNode.prototype.remove = function (key, comparator) {\n        var smallest;\n        var n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed())\n                n = n.rotateRight();\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.isRed = function () {\n        return this.color;\n    };\n    // Returns new tree after performing any needed rotations.\n    LLRBNode.prototype.fixUp = function () {\n        var n = this;\n        if (n.right.isRed() && !n.left.isRed())\n            n = n.rotateLeft();\n        if (n.left.isRed() && n.left.left.isRed())\n            n = n.rotateRight();\n        if (n.left.isRed() && n.right.isRed())\n            n = n.colorFlip();\n        return n;\n    };\n    LLRBNode.prototype.moveRedLeft = function () {\n        var n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.moveRedRight = function () {\n        var n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.rotateLeft = function () {\n        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    };\n    LLRBNode.prototype.rotateRight = function () {\n        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    };\n    LLRBNode.prototype.colorFlip = function () {\n        var left = this.left.copy(null, null, !this.left.color, null, null);\n        var right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    };\n    // For testing.\n    LLRBNode.prototype.checkMaxDepth = function () {\n        var blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    LLRBNode.prototype.check = function () {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n        }\n        if (this.right.isRed()) {\n            throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n        }\n        var blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail('Black depths differ');\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    };\n    LLRBNode.EMPTY = null;\n    LLRBNode.RED = true;\n    LLRBNode.BLACK = false;\n    return LLRBNode;\n}()); // end LLRBNode\n\n// Represents an empty node (a leaf node in the Red-Black Tree).\nvar LLRBEmptyNode = /** @class */ (function () {\n    function LLRBEmptyNode() {\n        this.size = 0;\n    }\n    // Returns a copy of the current node.\n    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\n        return this;\n    };\n    // Returns a copy of the tree, with the specified key/value added.\n    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\n        return new sorted_map_LLRBNode(key, value);\n    };\n    // Returns a copy of the tree, with the specified key removed.\n    LLRBEmptyNode.prototype.remove = function (key, comparator) {\n        return this;\n    };\n    LLRBEmptyNode.prototype.isEmpty = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.inorderTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.reverseTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.minKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.maxKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.isRed = function () {\n        return false;\n    };\n    // For testing.\n    LLRBEmptyNode.prototype.checkMaxDepth = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.check = function () {\n        return 0;\n    };\n    return LLRBEmptyNode;\n}()); // end LLRBEmptyNode\n\nsorted_map_LLRBNode.EMPTY = new LLRBEmptyNode();\n\n//# sourceMappingURL=sorted_map.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/field_value.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar field_value___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar TypeOrder;\n(function (TypeOrder) {\n    // This order is defined by the backend.\n    TypeOrder[TypeOrder[\"NullValue\"] = 0] = \"NullValue\";\n    TypeOrder[TypeOrder[\"BooleanValue\"] = 1] = \"BooleanValue\";\n    TypeOrder[TypeOrder[\"NumberValue\"] = 2] = \"NumberValue\";\n    TypeOrder[TypeOrder[\"TimestampValue\"] = 3] = \"TimestampValue\";\n    TypeOrder[TypeOrder[\"StringValue\"] = 4] = \"StringValue\";\n    TypeOrder[TypeOrder[\"BlobValue\"] = 5] = \"BlobValue\";\n    TypeOrder[TypeOrder[\"RefValue\"] = 6] = \"RefValue\";\n    TypeOrder[TypeOrder[\"GeoPointValue\"] = 7] = \"GeoPointValue\";\n    TypeOrder[TypeOrder[\"ArrayValue\"] = 8] = \"ArrayValue\";\n    TypeOrder[TypeOrder[\"ObjectValue\"] = 9] = \"ObjectValue\";\n})(TypeOrder = TypeOrder || (TypeOrder = {}));\n/**\n * A field value represents a datatype as stored by Firestore.\n */\nvar field_value_FieldValue = /** @class */ (function () {\n    function FieldValue() {\n    }\n    FieldValue.prototype.toString = function () {\n        var val = this.value();\n        return val === null ? 'null' : val.toString();\n    };\n    FieldValue.prototype.defaultCompareTo = function (other) {\n        assert(this.typeOrder !== other.typeOrder, 'Default compareTo should not be used for values of same type.');\n        var cmp = primitiveComparator(this.typeOrder, other.typeOrder);\n        return cmp;\n    };\n    return FieldValue;\n}());\n\nvar NullValue = /** @class */ (function (_super) {\n    field_value___extends(NullValue, _super);\n    function NullValue() {\n        var _this = _super.call(this) || this;\n        _this.typeOrder = TypeOrder.NullValue;\n        // internalValue is unused but we add it to work around\n        // https://github.com/Microsoft/TypeScript/issues/15585\n        _this.internalValue = null;\n        return _this;\n    }\n    NullValue.prototype.value = function () {\n        return null;\n    };\n    NullValue.prototype.equals = function (other) {\n        return other instanceof NullValue;\n    };\n    NullValue.prototype.compareTo = function (other) {\n        if (other instanceof NullValue) {\n            return 0;\n        }\n        return this.defaultCompareTo(other);\n    };\n    NullValue.INSTANCE = new NullValue();\n    return NullValue;\n}(field_value_FieldValue));\n\nvar field_value_BooleanValue = /** @class */ (function (_super) {\n    field_value___extends(BooleanValue, _super);\n    function BooleanValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.BooleanValue;\n        return _this;\n    }\n    BooleanValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    BooleanValue.prototype.equals = function (other) {\n        return (other instanceof BooleanValue &&\n            this.internalValue === other.internalValue);\n    };\n    BooleanValue.prototype.compareTo = function (other) {\n        if (other instanceof BooleanValue) {\n            return primitiveComparator(this, other);\n        }\n        return this.defaultCompareTo(other);\n    };\n    BooleanValue.of = function (value) {\n        return value ? BooleanValue.TRUE : BooleanValue.FALSE;\n    };\n    BooleanValue.TRUE = new BooleanValue(true);\n    BooleanValue.FALSE = new BooleanValue(false);\n    return BooleanValue;\n}(field_value_FieldValue));\n\n/** Base class for IntegerValue and DoubleValue. */\nvar NumberValue = /** @class */ (function (_super) {\n    field_value___extends(NumberValue, _super);\n    function NumberValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.NumberValue;\n        return _this;\n    }\n    NumberValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    NumberValue.prototype.compareTo = function (other) {\n        if (other instanceof NumberValue) {\n            return numericComparator(this.internalValue, other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return NumberValue;\n}(field_value_FieldValue));\n\n/** Utility function to compare doubles (using Firestore semantics for NaN). */\nfunction numericComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    else if (left > right) {\n        return 1;\n    }\n    else if (left === right) {\n        return 0;\n    }\n    else {\n        // one or both are NaN.\n        if (isNaN(left)) {\n            return isNaN(right) ? 0 : -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\n/**\n * Utility function to check numbers for equality using Firestore semantics\n * (NaN === NaN, -0.0 !== 0.0).\n */\nfunction numericEquals(left, right) {\n    // Implemented based on Object.is() polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    if (left === right) {\n        // +0 != -0\n        return left !== 0 || 1 / left === 1 / right;\n    }\n    else {\n        // NaN == NaN\n        return left !== left && right !== right;\n    }\n}\nvar IntegerValue = /** @class */ (function (_super) {\n    field_value___extends(IntegerValue, _super);\n    function IntegerValue(internalValue) {\n        return _super.call(this, internalValue) || this;\n    }\n    IntegerValue.prototype.equals = function (other) {\n        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,\n        // but that doesn't make them equal via equals().\n        if (other instanceof IntegerValue) {\n            return numericEquals(this.internalValue, other.internalValue);\n        }\n        else {\n            return false;\n        }\n    };\n    return IntegerValue;\n}(NumberValue));\n\nvar DoubleValue = /** @class */ (function (_super) {\n    field_value___extends(DoubleValue, _super);\n    function DoubleValue(internalValue) {\n        var _this = _super.call(this, internalValue) || this;\n        _this.internalValue = internalValue;\n        return _this;\n    }\n    DoubleValue.prototype.equals = function (other) {\n        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,\n        // but that doesn't make them equal via equals().\n        if (other instanceof DoubleValue) {\n            return numericEquals(this.internalValue, other.internalValue);\n        }\n        else {\n            return false;\n        }\n    };\n    DoubleValue.NAN = new DoubleValue(NaN);\n    DoubleValue.POSITIVE_INFINITY = new DoubleValue(Infinity);\n    DoubleValue.NEGATIVE_INFINITY = new DoubleValue(-Infinity);\n    return DoubleValue;\n}(NumberValue));\n\n// TODO(b/37267885): Add truncation support\nvar field_value_StringValue = /** @class */ (function (_super) {\n    field_value___extends(StringValue, _super);\n    function StringValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.StringValue;\n        return _this;\n    }\n    StringValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    StringValue.prototype.equals = function (other) {\n        return (other instanceof StringValue && this.internalValue === other.internalValue);\n    };\n    StringValue.prototype.compareTo = function (other) {\n        if (other instanceof StringValue) {\n            return primitiveComparator(this.internalValue, other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return StringValue;\n}(field_value_FieldValue));\n\nvar TimestampValue = /** @class */ (function (_super) {\n    field_value___extends(TimestampValue, _super);\n    function TimestampValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.TimestampValue;\n        return _this;\n    }\n    TimestampValue.prototype.value = function () {\n        return this.internalValue.toDate();\n    };\n    TimestampValue.prototype.equals = function (other) {\n        return (other instanceof TimestampValue &&\n            this.internalValue.equals(other.internalValue));\n    };\n    TimestampValue.prototype.compareTo = function (other) {\n        if (other instanceof TimestampValue) {\n            return this.internalValue.compareTo(other.internalValue);\n        }\n        else if (other instanceof ServerTimestampValue) {\n            // Concrete timestamps come before server timestamps.\n            return -1;\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    return TimestampValue;\n}(field_value_FieldValue));\n\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   TransformMutation (see TransformMutation.applyTo()). They can only exist in\n *   the local view of a document. Therefore they do not need to be parsed or\n *   serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they evaluate to null.\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nvar ServerTimestampValue = /** @class */ (function (_super) {\n    field_value___extends(ServerTimestampValue, _super);\n    function ServerTimestampValue(localWriteTime) {\n        var _this = _super.call(this) || this;\n        _this.localWriteTime = localWriteTime;\n        _this.typeOrder = TypeOrder.TimestampValue;\n        return _this;\n    }\n    ServerTimestampValue.prototype.value = function () {\n        return null;\n    };\n    ServerTimestampValue.prototype.equals = function (other) {\n        return (other instanceof ServerTimestampValue &&\n            this.localWriteTime.equals(other.localWriteTime));\n    };\n    ServerTimestampValue.prototype.compareTo = function (other) {\n        if (other instanceof ServerTimestampValue) {\n            return this.localWriteTime.compareTo(other.localWriteTime);\n        }\n        else if (other instanceof TimestampValue) {\n            // Server timestamps come after all concrete timestamps.\n            return 1;\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ServerTimestampValue.prototype.toString = function () {\n        return '<ServerTimestamp localTime=' + this.localWriteTime.toString() + '>';\n    };\n    return ServerTimestampValue;\n}(field_value_FieldValue));\n\nvar BlobValue = /** @class */ (function (_super) {\n    field_value___extends(BlobValue, _super);\n    function BlobValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.BlobValue;\n        return _this;\n    }\n    BlobValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    BlobValue.prototype.equals = function (other) {\n        return (other instanceof BlobValue &&\n            this.internalValue._equals(other.internalValue));\n    };\n    BlobValue.prototype.compareTo = function (other) {\n        if (other instanceof BlobValue) {\n            return this.internalValue._compareTo(other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return BlobValue;\n}(field_value_FieldValue));\n\nvar field_value_RefValue = /** @class */ (function (_super) {\n    field_value___extends(RefValue, _super);\n    function RefValue(databaseId, key) {\n        var _this = _super.call(this) || this;\n        _this.databaseId = databaseId;\n        _this.key = key;\n        _this.typeOrder = TypeOrder.RefValue;\n        return _this;\n    }\n    RefValue.prototype.value = function () {\n        return this.key;\n    };\n    RefValue.prototype.equals = function (other) {\n        if (other instanceof RefValue) {\n            return (this.key.equals(other.key) && this.databaseId.equals(other.databaseId));\n        }\n        else {\n            return false;\n        }\n    };\n    RefValue.prototype.compareTo = function (other) {\n        if (other instanceof RefValue) {\n            var cmp = this.databaseId.compareTo(other.databaseId);\n            return cmp !== 0 ? cmp : document_key_DocumentKey.comparator(this.key, other.key);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return RefValue;\n}(field_value_FieldValue));\n\nvar GeoPointValue = /** @class */ (function (_super) {\n    field_value___extends(GeoPointValue, _super);\n    function GeoPointValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.GeoPointValue;\n        return _this;\n    }\n    GeoPointValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    GeoPointValue.prototype.equals = function (other) {\n        return (other instanceof GeoPointValue &&\n            this.internalValue._equals(other.internalValue));\n    };\n    GeoPointValue.prototype.compareTo = function (other) {\n        if (other instanceof GeoPointValue) {\n            return this.internalValue._compareTo(other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return GeoPointValue;\n}(field_value_FieldValue));\n\nvar field_value_ObjectValue = /** @class */ (function (_super) {\n    field_value___extends(ObjectValue, _super);\n    function ObjectValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.ObjectValue;\n        return _this;\n    }\n    ObjectValue.prototype.value = function () {\n        var result = {};\n        this.internalValue.inorderTraversal(function (key, val) {\n            result[key] = val.value();\n        });\n        return result;\n    };\n    ObjectValue.prototype.forEach = function (action) {\n        this.internalValue.inorderTraversal(action);\n    };\n    ObjectValue.prototype.equals = function (other) {\n        if (other instanceof ObjectValue) {\n            var it1 = this.internalValue.getIterator();\n            var it2 = other.internalValue.getIterator();\n            while (it1.hasNext() && it2.hasNext()) {\n                var next1 = it1.getNext();\n                var next2 = it2.getNext();\n                if (next1.key !== next2.key || !next1.value.equals(next2.value)) {\n                    return false;\n                }\n            }\n            return !it1.hasNext() && !it2.hasNext();\n        }\n        return false;\n    };\n    ObjectValue.prototype.compareTo = function (other) {\n        if (other instanceof ObjectValue) {\n            var it1 = this.internalValue.getIterator();\n            var it2 = other.internalValue.getIterator();\n            while (it1.hasNext() && it2.hasNext()) {\n                var next1 = it1.getNext();\n                var next2 = it2.getNext();\n                var cmp = primitiveComparator(next1.key, next2.key) ||\n                    next1.value.compareTo(next2.value);\n                if (cmp) {\n                    return cmp;\n                }\n            }\n            // Only equal if both iterators are exhausted\n            return primitiveComparator(it1.hasNext(), it2.hasNext());\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ObjectValue.prototype.set = function (path, to) {\n        assert(!path.isEmpty(), 'Cannot set field for empty path on ObjectValue');\n        if (path.length === 1) {\n            return this.setChild(path.firstSegment(), to);\n        }\n        else {\n            var child = this.child(path.firstSegment());\n            if (!(child instanceof ObjectValue)) {\n                child = ObjectValue.EMPTY;\n            }\n            var newChild = child.set(path.popFirst(), to);\n            return this.setChild(path.firstSegment(), newChild);\n        }\n    };\n    ObjectValue.prototype.delete = function (path) {\n        assert(!path.isEmpty(), 'Cannot delete field for empty path on ObjectValue');\n        if (path.length === 1) {\n            return new ObjectValue(this.internalValue.remove(path.firstSegment()));\n        }\n        else {\n            // nested field\n            var child = this.child(path.firstSegment());\n            if (child instanceof ObjectValue) {\n                var newChild = child.delete(path.popFirst());\n                return new ObjectValue(this.internalValue.insert(path.firstSegment(), newChild));\n            }\n            else {\n                // Don't actually change a primitive value to an object for a delete\n                return this;\n            }\n        }\n    };\n    ObjectValue.prototype.contains = function (path) {\n        return this.field(path) !== undefined;\n    };\n    ObjectValue.prototype.field = function (path) {\n        assert(!path.isEmpty(), \"Can't get field of empty path\");\n        var field = this;\n        path.forEach(function (pathSegment) {\n            if (field instanceof ObjectValue) {\n                field = field.internalValue.get(pathSegment) || undefined;\n            }\n            else {\n                field = undefined;\n            }\n        });\n        return field;\n    };\n    ObjectValue.prototype.toString = function () {\n        return JSON.stringify(this.value());\n    };\n    ObjectValue.prototype.child = function (childName) {\n        return this.internalValue.get(childName) || undefined;\n    };\n    ObjectValue.prototype.setChild = function (childName, value) {\n        return new ObjectValue(this.internalValue.insert(childName, value));\n    };\n    ObjectValue.EMPTY = new ObjectValue(new sorted_map_SortedMap(primitiveComparator));\n    return ObjectValue;\n}(field_value_FieldValue));\n\nvar field_value_ArrayValue = /** @class */ (function (_super) {\n    field_value___extends(ArrayValue, _super);\n    function ArrayValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.ArrayValue;\n        return _this;\n    }\n    ArrayValue.prototype.value = function () {\n        return this.internalValue.map(function (v) { return v.value(); });\n    };\n    ArrayValue.prototype.forEach = function (action) {\n        this.internalValue.forEach(action);\n    };\n    ArrayValue.prototype.equals = function (other) {\n        if (other instanceof ArrayValue) {\n            if (this.internalValue.length !== other.internalValue.length) {\n                return false;\n            }\n            for (var i = 0; i < this.internalValue.length; i++) {\n                if (!this.internalValue[i].equals(other.internalValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    ArrayValue.prototype.compareTo = function (other) {\n        if (other instanceof ArrayValue) {\n            var minLength = Math.min(this.internalValue.length, other.internalValue.length);\n            for (var i = 0; i < minLength; i++) {\n                var cmp = this.internalValue[i].compareTo(other.internalValue[i]);\n                if (cmp) {\n                    return cmp;\n                }\n            }\n            return primitiveComparator(this.internalValue.length, other.internalValue.length);\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ArrayValue.prototype.toString = function () {\n        return JSON.stringify(this.value());\n    };\n    return ArrayValue;\n}(field_value_FieldValue));\n\n\n//# sourceMappingURL=field_value.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/types.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Untyped Number alias we can use to check for ES6 methods / properties.\n// tslint:disable-next-line:no-any variable-name\nvar NumberAsAny = Number;\n/**\n * Minimum safe integer in Javascript because of floating point precision.\n * Added to not rely on ES6 features.\n */\nvar MIN_SAFE_INTEGER = NumberAsAny.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);\n/**\n * Maximum safe integer in Javascript because of floating point precision.\n * Added to not rely on ES6 features.\n */\nvar MAX_SAFE_INTEGER = NumberAsAny.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;\n/**\n * Returns whether an number is an integer, uses native implementation if\n * available.\n * Added to not rely on ES6 features.\n * @param value The value to test for being an integer\n */\nvar isInteger = NumberAsAny.isInteger ||\n    (function (value) {\n        return typeof value === 'number' &&\n            isFinite(value) &&\n            Math.floor(value) === value;\n    });\n/**\n * Returns whether a variable is either undefined or null.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value The value to test for being an integer and in the safe range\n */\nfunction isSafeInteger(value) {\n    return (isInteger(value) &&\n        value <= MAX_SAFE_INTEGER &&\n        value >= MIN_SAFE_INTEGER);\n}\n/**\n * Safely checks if the number is NaN.\n */\nfunction safeIsNaN(value) {\n    if (NumberAsAny.IsNaN) {\n        return NumberAsAny.IsNaN(value);\n    }\n    else {\n        return typeof value === 'number' && isNaN(value);\n    }\n}\n\n//# sourceMappingURL=types.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/query.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\nvar query_Query = /** @class */ (function () {\n    function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {\n        if (explicitOrderBy === void 0) { explicitOrderBy = []; }\n        if (filters === void 0) { filters = []; }\n        if (limit === void 0) { limit = null; }\n        if (startAt === void 0) { startAt = null; }\n        if (endAt === void 0) { endAt = null; }\n        this.path = path;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n        this.memoizedOrderBy = null;\n        if (this.startAt) {\n            this.assertValidBound(this.startAt);\n        }\n        if (this.endAt) {\n            this.assertValidBound(this.endAt);\n        }\n    }\n    Query.atPath = function (path) {\n        return new Query(path);\n    };\n    Object.defineProperty(Query.prototype, \"orderBy\", {\n        get: function () {\n            if (this.memoizedOrderBy === null) {\n                var inequalityField = this.getInequalityFilterField();\n                var firstOrderByField = this.getFirstOrderByField();\n                if (inequalityField !== null && firstOrderByField === null) {\n                    // In order to implicitly add key ordering, we must also add the\n                    // inequality filter field for it to be a valid query.\n                    // Note that the default inequality field and key ordering is ascending.\n                    if (inequalityField.isKeyField()) {\n                        this.memoizedOrderBy = [KEY_ORDERING_ASC];\n                    }\n                    else {\n                        this.memoizedOrderBy = [\n                            new query_OrderBy(inequalityField),\n                            KEY_ORDERING_ASC\n                        ];\n                    }\n                }\n                else {\n                    assert(inequalityField === null ||\n                        (firstOrderByField !== null &&\n                            inequalityField.equals(firstOrderByField)), 'First orderBy should match inequality field.');\n                    this.memoizedOrderBy = [];\n                    var foundKeyOrdering = false;\n                    for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n                        var orderBy = _a[_i];\n                        this.memoizedOrderBy.push(orderBy);\n                        if (orderBy.field.isKeyField()) {\n                            foundKeyOrdering = true;\n                        }\n                    }\n                    if (!foundKeyOrdering) {\n                        // The order of the implicit key ordering always matches the last\n                        // explicit order by\n                        var lastDirection = this.explicitOrderBy.length > 0\n                            ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir\n                            : Direction.ASCENDING;\n                        this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING\n                            ? KEY_ORDERING_ASC\n                            : KEY_ORDERING_DESC);\n                    }\n                }\n            }\n            return this.memoizedOrderBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Query.prototype.addFilter = function (filter) {\n        assert(this.getInequalityFilterField() == null ||\n            !(filter instanceof query_RelationFilter) ||\n            !filter.isInequality() ||\n            filter.field.equals(this.getInequalityFilterField()), 'Query must only have one inequality field.');\n        assert(!document_key_DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');\n        var newFilters = this.filters.concat([filter]);\n        return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.addOrderBy = function (orderBy) {\n        assert(!document_key_DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');\n        assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');\n        // TODO(dimond): validate that orderBy does not list the same key twice.\n        var newOrderBy = this.explicitOrderBy.concat([orderBy]);\n        return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withLimit = function (limit) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withStartAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);\n    };\n    Query.prototype.withEndAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);\n    };\n    // TODO(b/29183165): This is used to get a unique string from a query to, for\n    // example, use as a dictionary key, but the implementation is subject to\n    // collisions. Make it collision-free.\n    Query.prototype.canonicalId = function () {\n        if (this.memoizedCanonicalId === null) {\n            var canonicalId = this.path.canonicalString();\n            canonicalId += '|f:';\n            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n                var filter = _a[_i];\n                canonicalId += filter.canonicalId();\n                canonicalId += ',';\n            }\n            canonicalId += '|ob:';\n            // TODO(dimond): make this collision resistant\n            for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {\n                var orderBy = _c[_b];\n                canonicalId += orderBy.canonicalId();\n                canonicalId += ',';\n            }\n            if (!isNullOrUndefined(this.limit)) {\n                canonicalId += '|l:';\n                canonicalId += this.limit;\n            }\n            if (this.startAt) {\n                canonicalId += '|lb:';\n                canonicalId += this.startAt.canonicalId();\n            }\n            if (this.endAt) {\n                canonicalId += '|ub:';\n                canonicalId += this.endAt.canonicalId();\n            }\n            this.memoizedCanonicalId = canonicalId;\n        }\n        return this.memoizedCanonicalId;\n    };\n    Query.prototype.toString = function () {\n        var str = 'Query(' + this.path.canonicalString();\n        if (this.filters.length > 0) {\n            str += \", filters: [\" + this.filters.join(', ') + \"]\";\n        }\n        if (!isNullOrUndefined(this.limit)) {\n            str += ', limit: ' + this.limit;\n        }\n        if (this.explicitOrderBy.length > 0) {\n            str += \", orderBy: [\" + this.explicitOrderBy.join(', ') + \"]\";\n        }\n        if (this.startAt) {\n            str += ', startAt: ' + this.startAt.canonicalId();\n        }\n        if (this.endAt) {\n            str += ', endAt: ' + this.endAt.canonicalId();\n        }\n        return str + ')';\n    };\n    Query.prototype.equals = function (other) {\n        if (this.limit !== other.limit) {\n            return false;\n        }\n        if (this.orderBy.length !== other.orderBy.length) {\n            return false;\n        }\n        for (var i = 0; i < this.orderBy.length; i++) {\n            if (!this.orderBy[i].equals(other.orderBy[i])) {\n                return false;\n            }\n        }\n        if (this.filters.length !== other.filters.length) {\n            return false;\n        }\n        for (var i = 0; i < this.filters.length; i++) {\n            if (!this.filters[i].equals(other.filters[i])) {\n                return false;\n            }\n        }\n        if (!this.path.equals(other.path)) {\n            return false;\n        }\n        if (this.startAt !== null\n            ? !this.startAt.equals(other.startAt)\n            : other.startAt !== null) {\n            return false;\n        }\n        return this.endAt !== null\n            ? this.endAt.equals(other.endAt)\n            : other.endAt === null;\n    };\n    Query.prototype.docComparator = function (d1, d2) {\n        var comparedOnKeyField = false;\n        for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            var comp = orderBy.compare(d1, d2);\n            if (comp !== 0)\n                return comp;\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        // Assert that we actually compared by key\n        assert(comparedOnKeyField, \"orderBy used that doesn't compare on key field\");\n        return 0;\n    };\n    Query.prototype.matches = function (doc) {\n        return (this.matchesAncestor(doc) &&\n            this.matchesOrderBy(doc) &&\n            this.matchesFilters(doc) &&\n            this.matchesBounds(doc));\n    };\n    Query.prototype.hasLimit = function () {\n        return !isNullOrUndefined(this.limit);\n    };\n    Query.prototype.getFirstOrderByField = function () {\n        return this.explicitOrderBy.length > 0\n            ? this.explicitOrderBy[0].field\n            : null;\n    };\n    Query.prototype.getInequalityFilterField = function () {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (filter instanceof query_RelationFilter && filter.isInequality()) {\n                return filter.field;\n            }\n        }\n        return null;\n    };\n    Query.prototype.isDocumentQuery = function () {\n        return document_key_DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;\n    };\n    Query.prototype.matchesAncestor = function (doc) {\n        var docPath = doc.key.path;\n        if (document_key_DocumentKey.isDocumentKey(this.path)) {\n            // exact match for document queries\n            return this.path.equals(docPath);\n        }\n        else {\n            // shallow ancestor queries by default\n            return (this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1);\n        }\n    };\n    /**\n     * A document must have a value for every ordering clause in order to show up\n     * in the results.\n     */\n    Query.prototype.matchesOrderBy = function (doc) {\n        for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            // order by key always matches\n            if (!orderBy.field.isKeyField() &&\n                doc.field(orderBy.field) === undefined) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Query.prototype.matchesFilters = function (doc) {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (!filter.matches(doc)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Makes sure a document is within the bounds, if provided.\n     */\n    Query.prototype.matchesBounds = function (doc) {\n        if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        return true;\n    };\n    Query.prototype.assertValidBound = function (bound) {\n        assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');\n    };\n    return Query;\n}());\n\nvar query_RelationOp = /** @class */ (function () {\n    function RelationOp(name) {\n        this.name = name;\n    }\n    RelationOp.fromString = function (op) {\n        switch (op) {\n            case '<':\n                return RelationOp.LESS_THAN;\n            case '<=':\n                return RelationOp.LESS_THAN_OR_EQUAL;\n            case '==':\n                return RelationOp.EQUAL;\n            case '>=':\n                return RelationOp.GREATER_THAN_OR_EQUAL;\n            case '>':\n                return RelationOp.GREATER_THAN;\n            default:\n                return fail('Unknown relation: ' + op);\n        }\n    };\n    RelationOp.prototype.toString = function () {\n        return this.name;\n    };\n    RelationOp.prototype.equals = function (other) {\n        return this.name === other.name;\n    };\n    RelationOp.LESS_THAN = new RelationOp('<');\n    RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');\n    RelationOp.EQUAL = new RelationOp('==');\n    RelationOp.GREATER_THAN = new RelationOp('>');\n    RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');\n    return RelationOp;\n}());\n\nvar query_RelationFilter = /** @class */ (function () {\n    function RelationFilter(field, op, value) {\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    RelationFilter.prototype.matches = function (doc) {\n        if (this.field.isKeyField()) {\n            assert(this.value instanceof field_value_RefValue, 'Comparing on key, but filter value not a RefValue');\n            var refValue = this.value;\n            var comparison = document_key_DocumentKey.comparator(doc.key, refValue.key);\n            return this.matchesComparison(comparison);\n        }\n        else {\n            var val = doc.field(this.field);\n            return val !== undefined && this.matchesValue(val);\n        }\n    };\n    RelationFilter.prototype.matchesValue = function (value) {\n        // Only compare types with matching backend order (such as double and int).\n        if (this.value.typeOrder !== value.typeOrder) {\n            return false;\n        }\n        return this.matchesComparison(value.compareTo(this.value));\n    };\n    RelationFilter.prototype.matchesComparison = function (comparison) {\n        switch (this.op) {\n            case query_RelationOp.LESS_THAN:\n                return comparison < 0;\n            case query_RelationOp.LESS_THAN_OR_EQUAL:\n                return comparison <= 0;\n            case query_RelationOp.EQUAL:\n                return comparison === 0;\n            case query_RelationOp.GREATER_THAN:\n                return comparison > 0;\n            case query_RelationOp.GREATER_THAN_OR_EQUAL:\n                return comparison >= 0;\n            default:\n                return fail('Unknown relation op' + this.op);\n        }\n    };\n    RelationFilter.prototype.isInequality = function () {\n        return this.op !== query_RelationOp.EQUAL;\n    };\n    RelationFilter.prototype.canonicalId = function () {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (this.field.canonicalString() + this.op.toString() + this.value.toString());\n    };\n    RelationFilter.prototype.equals = function (other) {\n        if (other instanceof RelationFilter) {\n            return (this.op.equals(other.op) &&\n                this.field.equals(other.field) &&\n                this.value.equals(other.value));\n        }\n        else {\n            return false;\n        }\n    };\n    RelationFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n    };\n    return RelationFilter;\n}());\n\n/**\n * Filter that matches 'null' values.\n */\nvar NullFilter = /** @class */ (function () {\n    function NullFilter(field) {\n        this.field = field;\n    }\n    NullFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field);\n        return val !== undefined && val.value() === null;\n    };\n    NullFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS null';\n    };\n    NullFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS null\";\n    };\n    NullFilter.prototype.equals = function (other) {\n        if (other instanceof NullFilter) {\n            return this.field.equals(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NullFilter;\n}());\n\n/**\n * Filter that matches 'NaN' values.\n */\nvar NanFilter = /** @class */ (function () {\n    function NanFilter(field) {\n        this.field = field;\n    }\n    NanFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field).value();\n        return typeof val === 'number' && isNaN(val);\n    };\n    NanFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS NaN';\n    };\n    NanFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS NaN\";\n    };\n    NanFilter.prototype.equals = function (other) {\n        if (other instanceof NanFilter) {\n            return this.field.equals(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NanFilter;\n}());\n\n/**\n * Creates a filter based on the provided arguments.\n */\nfunction fieldFilter(field, op, value) {\n    if (value.equals(NullValue.INSTANCE)) {\n        if (op !== query_RelationOp.EQUAL) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on null.');\n        }\n        return new NullFilter(field);\n    }\n    else if (value.equals(DoubleValue.NAN)) {\n        if (op !== query_RelationOp.EQUAL) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on NaN.');\n        }\n        return new NanFilter(field);\n    }\n    else {\n        return new query_RelationFilter(field, op, value);\n    }\n}\n/**\n * The direction of sorting in an order by.\n */\nvar Direction = /** @class */ (function () {\n    function Direction(name) {\n        this.name = name;\n    }\n    Direction.prototype.toString = function () {\n        return this.name;\n    };\n    Direction.ASCENDING = new Direction('asc');\n    Direction.DESCENDING = new Direction('desc');\n    return Direction;\n}());\n\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nvar query_Bound = /** @class */ (function () {\n    function Bound(position, before) {\n        this.position = position;\n        this.before = before;\n    }\n    Bound.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        var canonicalId = this.before ? 'b:' : 'a:';\n        for (var _i = 0, _a = this.position; _i < _a.length; _i++) {\n            var component = _a[_i];\n            canonicalId += component.toString();\n        }\n        return canonicalId;\n    };\n    /**\n     * Returns true if a document sorts before a bound using the provided sort\n     * order.\n     */\n    Bound.prototype.sortsBeforeDocument = function (orderBy, doc) {\n        assert(this.position.length <= orderBy.length, \"Bound has more components than query's orderBy\");\n        var comparison = 0;\n        for (var i = 0; i < this.position.length; i++) {\n            var orderByComponent = orderBy[i];\n            var component = this.position[i];\n            if (orderByComponent.field.isKeyField()) {\n                assert(component instanceof field_value_RefValue, 'Bound has a non-key value where the key path is being used.');\n                comparison = document_key_DocumentKey.comparator(component.key, doc.key);\n            }\n            else {\n                var docValue = doc.field(orderByComponent.field);\n                assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');\n                comparison = component.compareTo(docValue);\n            }\n            if (orderByComponent.dir === Direction.DESCENDING) {\n                comparison = comparison * -1;\n            }\n            if (comparison !== 0) {\n                break;\n            }\n        }\n        return this.before ? comparison <= 0 : comparison < 0;\n    };\n    Bound.prototype.equals = function (other) {\n        if (other === null) {\n            return false;\n        }\n        if (this.before !== other.before ||\n            this.position.length !== other.position.length) {\n            return false;\n        }\n        for (var i = 0; i < this.position.length; i++) {\n            var thisPosition = this.position[i];\n            var otherPosition = other.position[i];\n            return thisPosition.equals(otherPosition);\n        }\n        return true;\n    };\n    return Bound;\n}());\n\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nvar query_OrderBy = /** @class */ (function () {\n    function OrderBy(field, dir) {\n        this.field = field;\n        if (dir === undefined) {\n            dir = Direction.ASCENDING;\n        }\n        this.dir = dir;\n        this.isKeyOrderBy = field.isKeyField();\n    }\n    OrderBy.prototype.compare = function (d1, d2) {\n        var comparison = this.isKeyOrderBy\n            ? document_Document.compareByKey(d1, d2)\n            : document_Document.compareByField(this.field, d1, d2);\n        switch (this.dir) {\n            case Direction.ASCENDING:\n                return comparison;\n            case Direction.DESCENDING:\n                return -1 * comparison;\n            default:\n                return fail('Unknown direction: ' + this.dir);\n        }\n    };\n    OrderBy.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        return this.field.canonicalString() + this.dir.toString();\n    };\n    OrderBy.prototype.toString = function () {\n        return this.field.canonicalString() + \" (\" + this.dir + \")\";\n    };\n    OrderBy.prototype.equals = function (other) {\n        return this.dir === other.dir && this.field.equals(other.field);\n    };\n    return OrderBy;\n}());\n\nvar KEY_ORDERING_ASC = new query_OrderBy(path_FieldPath.keyField(), Direction.ASCENDING);\nvar KEY_ORDERING_DESC = new query_OrderBy(path_FieldPath.keyField(), Direction.DESCENDING);\n\n//# sourceMappingURL=query.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/timestamp.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nvar isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\nvar timestamp_Timestamp = /** @class */ (function () {\n    function Timestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n        assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n        assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos);\n        // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n        assert(seconds >= -62135596800, 'timestamp seconds out of range: ' + seconds);\n        // This will break in the year 10,000.\n        assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n    }\n    Timestamp.now = function () {\n        return Timestamp.fromEpochMilliseconds(Date.now());\n    };\n    Timestamp.fromDate = function (date) {\n        return Timestamp.fromEpochMilliseconds(date.getTime());\n    };\n    Timestamp.fromEpochMilliseconds = function (milliseconds) {\n        var seconds = Math.floor(milliseconds / 1000);\n        var nanos = (milliseconds - seconds * 1000) * 1e6;\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.fromISOString = function (utc) {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        var nanos = 0;\n        var fraction = isoRegExp.exec(utc);\n        assert(!!fraction, 'invalid timestamp: ' + utc);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            var nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = parseInt(nanoStr, 10);\n        }\n        // Parse the date to get the seconds.\n        var date = new Date(utc);\n        var seconds = Math.floor(date.getTime() / 1000);\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.prototype.toDate = function () {\n        return new Date(this.toEpochMilliseconds());\n    };\n    Timestamp.prototype.toEpochMilliseconds = function () {\n        return this.seconds * 1000 + this.nanos / 1e6;\n    };\n    Timestamp.prototype.compareTo = function (other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanos, other.nanos);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    };\n    Timestamp.prototype.equals = function (other) {\n        return other.seconds === this.seconds && other.nanos === this.nanos;\n    };\n    Timestamp.prototype.toString = function () {\n        return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n    };\n    return Timestamp;\n}());\n\n\n//# sourceMappingURL=timestamp.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/snapshot_version.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nvar snapshot_version_SnapshotVersion = /** @class */ (function () {\n    function SnapshotVersion(timestamp) {\n        this.timestamp = timestamp;\n    }\n    // TODO(b/34176344): Once we no longer need to use the old alpha protos,\n    // delete this constructor and use a timestamp-backed version everywhere.\n    SnapshotVersion.fromMicroseconds = function (value) {\n        var seconds = Math.floor(value / 1e6);\n        var nanos = (value % 1e6) * 1e3;\n        return new SnapshotVersion(new timestamp_Timestamp(seconds, nanos));\n    };\n    SnapshotVersion.fromTimestamp = function (value) {\n        return new SnapshotVersion(value);\n    };\n    SnapshotVersion.forDeletedDoc = function () {\n        return SnapshotVersion.MIN;\n    };\n    SnapshotVersion.prototype.compareTo = function (other) {\n        return this.timestamp.compareTo(other.timestamp);\n    };\n    SnapshotVersion.prototype.equals = function (other) {\n        return this.timestamp.equals(other.timestamp);\n    };\n    /** Returns a number representation of the version for use in spec tests. */\n    SnapshotVersion.prototype.toMicroseconds = function () {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanos / 1000;\n    };\n    SnapshotVersion.prototype.toString = function () {\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n    };\n    SnapshotVersion.prototype.toTimestamp = function () {\n        return this.timestamp;\n    };\n    SnapshotVersion.MIN = new SnapshotVersion(new timestamp_Timestamp(0, 0));\n    return SnapshotVersion;\n}());\n\n\n//# sourceMappingURL=snapshot_version.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/query_data.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** An enumeration of the different purposes we have for queries. */\nvar QueryPurpose;\n(function (QueryPurpose) {\n    /** A regular, normal query. */\n    QueryPurpose[QueryPurpose[\"Listen\"] = 0] = \"Listen\";\n    /**\n     * The query was used to refill a query after an existence filter mismatch.\n     */\n    QueryPurpose[QueryPurpose[\"ExistenceFilterMismatch\"] = 1] = \"ExistenceFilterMismatch\";\n    /** The query was used to resolve a limbo document. */\n    QueryPurpose[QueryPurpose[\"LimboResolution\"] = 2] = \"LimboResolution\";\n})(QueryPurpose = QueryPurpose || (QueryPurpose = {}));\n/**\n * An immutable set of metadata that the local store tracks for each query.\n */\nvar query_data_QueryData = /** @class */ (function () {\n    function QueryData(\n        /** The query being listened to. */\n        query, \n        /**\n         * The target ID to which the query corresponds; Assigned by the\n         * LocalStore for user listens and by the SyncEngine for limbo watches.\n         */\n        targetId, \n        /** The purpose of the query. */\n        purpose, \n        /** The latest snapshot version seen for this target. */\n        snapshotVersion, \n        /**\n         * An opaque, server-assigned token that allows watching a query to be\n         * resumed after disconnecting without retransmitting all the data that\n         * matches the query. The resume token essentially identifies a point in\n         * time from which the server should resume sending results.\n         */\n        resumeToken) {\n        if (snapshotVersion === void 0) { snapshotVersion = snapshot_version_SnapshotVersion.MIN; }\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        this.query = query;\n        this.targetId = targetId;\n        this.purpose = purpose;\n        this.snapshotVersion = snapshotVersion;\n        this.resumeToken = resumeToken;\n    }\n    /**\n     * Creates a new query data instance with an updated snapshot version and\n     * resume token.\n     */\n    QueryData.prototype.update = function (updated) {\n        return new QueryData(this.query, this.targetId, this.purpose, updated.snapshotVersion, updated.resumeToken);\n    };\n    QueryData.prototype.equals = function (other) {\n        return (this.targetId === other.targetId &&\n            this.purpose === other.purpose &&\n            this.snapshotVersion.equals(other.snapshotVersion) &&\n            this.resumeToken === other.resumeToken &&\n            this.query.equals(other.query));\n    };\n    return QueryData;\n}());\n\n\n//# sourceMappingURL=query_data.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/mutation.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar mutation___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nvar mutation_FieldMask = /** @class */ (function () {\n    function FieldMask(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n    }\n    FieldMask.prototype.equals = function (other) {\n        return arrayEquals(this.fields, other.fields);\n    };\n    return FieldMask;\n}());\n\n/** Transforms a value into a server-generated timestamp. */\nvar ServerTimestampTransform = /** @class */ (function () {\n    function ServerTimestampTransform() {\n    }\n    ServerTimestampTransform.prototype.equals = function (other) {\n        return other instanceof ServerTimestampTransform;\n    };\n    ServerTimestampTransform.instance = new ServerTimestampTransform();\n    return ServerTimestampTransform;\n}());\n\n/** A field path and the TransformOperation to perform upon it. */\nvar FieldTransform = /** @class */ (function () {\n    function FieldTransform(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n    FieldTransform.prototype.equals = function (other) {\n        return (this.field.equals(other.field) && this.transform.equals(other.transform));\n    };\n    return FieldTransform;\n}());\n\n/** The result of successfully applying a mutation to the backend. */\nvar MutationResult = /** @class */ (function () {\n    function MutationResult(\n        /**\n           * The version at which the mutation was committed or null for a delete.\n           */\n        version, \n        /**\n           * The resulting fields returned from the backend after a\n           * TransformMutation has been committed. Contains one FieldValue for each\n           * FieldTransform that was in the mutation.\n           *\n           * Will be null if the mutation was not a TransformMutation.\n           */\n        transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n    return MutationResult;\n}());\n\nvar MutationType;\n(function (MutationType) {\n    MutationType[MutationType[\"Set\"] = 0] = \"Set\";\n    MutationType[MutationType[\"Patch\"] = 1] = \"Patch\";\n    MutationType[MutationType[\"Transform\"] = 2] = \"Transform\";\n    MutationType[MutationType[\"Delete\"] = 3] = \"Delete\";\n})(MutationType = MutationType || (MutationType = {}));\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nvar mutation_Precondition = /** @class */ (function () {\n    function Precondition(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n        assert(updateTime === undefined || exists === undefined, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n    }\n    /** Creates a new Precondition with an exists flag. */\n    Precondition.exists = function (exists) {\n        return new Precondition(undefined, exists);\n    };\n    /** Creates a new Precondition based on a version a document exists at. */\n    Precondition.updateTime = function (version) {\n        return new Precondition(version);\n    };\n    Object.defineProperty(Precondition.prototype, \"isNone\", {\n        /** Returns whether this Precondition is empty. */\n        get: function () {\n            return this.updateTime === undefined && this.exists === undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns true if the preconditions is valid for the given document\n     * (or null if no document is available).\n     */\n    Precondition.prototype.isValidFor = function (maybeDoc) {\n        if (this.updateTime !== undefined) {\n            return (maybeDoc instanceof document_Document && maybeDoc.version.equals(this.updateTime));\n        }\n        else if (this.exists !== undefined) {\n            if (this.exists) {\n                return maybeDoc instanceof document_Document;\n            }\n            else {\n                return maybeDoc === null || maybeDoc instanceof document_NoDocument;\n            }\n        }\n        else {\n            assert(this.isNone, 'Precondition should be empty');\n            return true;\n        }\n    };\n    Precondition.prototype.equals = function (other) {\n        return (equals(this.updateTime, other.updateTime) &&\n            this.exists === other.exists);\n    };\n    Precondition.NONE = new Precondition();\n    return Precondition;\n}());\n\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nvar mutation_Mutation = /** @class */ (function () {\n    function Mutation() {\n    }\n    Mutation.prototype.verifyKeyMatches = function (maybeDoc) {\n        if (maybeDoc != null) {\n            assert(maybeDoc.key.equals(this.key), 'Can only apply a mutation to a document with the same key');\n        }\n    };\n    /**\n     * Returns the version from the given document for use as the result of a\n     * mutation. Mutations are defined to return the version of the base document\n     * only if it is an existing document. Deleted and unknown documents have a\n     * post-mutation version of SnapshotVersion.MIN.\n     */\n    Mutation.getPostMutationVersion = function (maybeDoc) {\n        if (maybeDoc instanceof document_Document) {\n            return maybeDoc.version;\n        }\n        else {\n            return snapshot_version_SnapshotVersion.MIN;\n        }\n    };\n    return Mutation;\n}());\n\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nvar mutation_SetMutation = /** @class */ (function (_super) {\n    mutation___extends(SetMutation, _super);\n    function SetMutation(key, value, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.value = value;\n        _this.precondition = precondition;\n        _this.type = MutationType.Set;\n        return _this;\n    }\n    SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);\n        return new document_Document(this.key, version, this.value, {\n            hasLocalMutations: false\n        });\n    };\n    SetMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);\n        return new document_Document(this.key, version, this.value, {\n            hasLocalMutations: true\n        });\n    };\n    SetMutation.prototype.equals = function (other) {\n        return (other instanceof SetMutation &&\n            this.key.equals(other.key) &&\n            this.value.equals(other.value) &&\n            this.precondition.equals(other.precondition));\n    };\n    return SetMutation;\n}(mutation_Mutation));\n\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nvar mutation_PatchMutation = /** @class */ (function (_super) {\n    mutation___extends(PatchMutation, _super);\n    function PatchMutation(key, data, fieldMask, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.data = data;\n        _this.fieldMask = fieldMask;\n        _this.precondition = precondition;\n        _this.type = MutationType.Patch;\n        return _this;\n    }\n    PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.');\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new document_Document(this.key, version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    PatchMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new document_Document(this.key, version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    PatchMutation.prototype.equals = function (other) {\n        return (other instanceof PatchMutation &&\n            this.key.equals(other.key) &&\n            this.fieldMask.equals(other.fieldMask) &&\n            this.precondition.equals(other.precondition));\n    };\n    /**\n     * Patches the data of document if available or creates a new document. Note\n     * that this does not check whether or not the precondition of this patch\n     * holds.\n     */\n    PatchMutation.prototype.patchDocument = function (maybeDoc) {\n        var data;\n        if (maybeDoc instanceof document_Document) {\n            data = maybeDoc.data;\n        }\n        else {\n            data = field_value_ObjectValue.EMPTY;\n        }\n        return this.patchObject(data);\n    };\n    PatchMutation.prototype.patchObject = function (data) {\n        for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {\n            var fieldPath = _a[_i];\n            var newValue = this.data.field(fieldPath);\n            if (newValue !== undefined) {\n                data = data.set(fieldPath, newValue);\n            }\n            else {\n                data = data.delete(fieldPath);\n            }\n        }\n        return data;\n    };\n    return PatchMutation;\n}(mutation_Mutation));\n\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nvar mutation_TransformMutation = /** @class */ (function (_super) {\n    mutation___extends(TransformMutation, _super);\n    function TransformMutation(key, fieldTransforms) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.fieldTransforms = fieldTransforms;\n        _this.type = MutationType.Transform;\n        // NOTE: We set a precondition of exists: true as a safety-check, since we\n        // always combine TransformMutations with a SetMutation or PatchMutation which\n        // (if successful) should end up with an existing document.\n        _this.precondition = mutation_Precondition.exists(true);\n        return _this;\n    }\n    TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');\n        var transformResults = mutationResult.transformResults;\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new document_Document(this.key, doc.version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    TransformMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var transformResults = this.localTransformResults(localWriteTime);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new document_Document(this.key, doc.version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    TransformMutation.prototype.equals = function (other) {\n        return (other instanceof TransformMutation &&\n            this.key.equals(other.key) &&\n            arrayEquals(this.fieldTransforms, other.fieldTransforms) &&\n            this.precondition.equals(other.precondition));\n    };\n    /**\n     * Asserts that the given MaybeDocument is actually a Document and verifies\n     * that it matches the key for this mutation. Since we only support\n     * transformations with precondition exists this method is guaranteed to be\n     * safe.\n     */\n    TransformMutation.prototype.requireDocument = function (maybeDoc) {\n        assert(maybeDoc instanceof document_Document, 'Unknown MaybeDocument type ' + maybeDoc);\n        var doc = maybeDoc;\n        assert(doc.key.equals(this.key), 'Can only transform a document with the same key');\n        return doc;\n    };\n    /**\n     * Creates a list of \"transform results\" (a transform result is a field value\n     * representing the result of applying a transform) for use when applying a\n     * TransformMutation locally.\n     *\n     * @param localWriteTime The local time of the transform mutation (used to\n     *     generate ServerTimestampValues).\n     * @return The transform results list.\n     */\n    TransformMutation.prototype.localTransformResults = function (localWriteTime) {\n        var transformResults = [];\n        for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {\n            var fieldTransform = _a[_i];\n            var transform = fieldTransform.transform;\n            if (transform instanceof ServerTimestampTransform) {\n                transformResults.push(new ServerTimestampValue(localWriteTime));\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return transformResults;\n    };\n    TransformMutation.prototype.transformObject = function (data, transformResults) {\n        assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');\n        for (var i = 0; i < this.fieldTransforms.length; i++) {\n            var fieldTransform = this.fieldTransforms[i];\n            var transform = fieldTransform.transform;\n            var fieldPath = fieldTransform.field;\n            if (transform instanceof ServerTimestampTransform) {\n                data = data.set(fieldPath, transformResults[i]);\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return data;\n    };\n    return TransformMutation;\n}(mutation_Mutation));\n\n/** A mutation that deletes the document at the given key. */\nvar mutation_DeleteMutation = /** @class */ (function (_super) {\n    mutation___extends(DeleteMutation, _super);\n    function DeleteMutation(key, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.precondition = precondition;\n        _this.type = MutationType.Delete;\n        return _this;\n    }\n    DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        return new document_NoDocument(this.key, snapshot_version_SnapshotVersion.MIN);\n    };\n    DeleteMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(this.key), 'Can only apply mutation to document with same key');\n        }\n        return new document_NoDocument(this.key, snapshot_version_SnapshotVersion.forDeletedDoc());\n    };\n    DeleteMutation.prototype.equals = function (other) {\n        return (other instanceof DeleteMutation &&\n            this.key.equals(other.key) &&\n            this.precondition.equals(other.precondition));\n    };\n    return DeleteMutation;\n}(mutation_Mutation));\n\n\n//# sourceMappingURL=mutation.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/existence_filter.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ExistenceFilter = /** @class */ (function () {\n    // TODO(b/33078163): just use simplest form of existence filter for now\n    function ExistenceFilter(count) {\n        this.count = count;\n    }\n    ExistenceFilter.prototype.equals = function (other) {\n        return other && other.count === this.count;\n    };\n    return ExistenceFilter;\n}());\n\n\n//# sourceMappingURL=existence_filter.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/rpc_error.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\nfunction isPermanentError(code) {\n    switch (code) {\n        case Code.OK:\n            return fail('Treated status OK as error');\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        // TODO(b/37325376): Give up after second unauthenticated error.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependant on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.\n *\n * @returns The Code equivalent to the given status string or undefined if\n *     there is no match.\n */\nfunction mapCodeFromRpcStatus(status) {\n    // tslint:disable-next-line:no-any lookup by string\n    var code = RpcCode[status];\n    if (code === undefined) {\n        return undefined;\n    }\n    return mapCodeFromRpcCode(code);\n}\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nfunction mapCodeFromRpcCode(code) {\n    switch (code) {\n        case RpcCode.OK:\n            return Code.OK;\n        case RpcCode.CANCELLED:\n            return Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return Code.DATA_LOSS;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Maps an RPC code from a Code. This is the reverse operation from\n * mapCodeFromRpcCode and should really only be used in tests.\n */\nfunction mapRpcCodeFromCode(code) {\n    if (code === undefined) {\n        return RpcCode.OK;\n    }\n    switch (code) {\n        case Code.OK:\n            return RpcCode.OK;\n        case Code.CANCELLED:\n            return RpcCode.CANCELLED;\n        case Code.UNKNOWN:\n            return RpcCode.UNKNOWN;\n        case Code.DEADLINE_EXCEEDED:\n            return RpcCode.DEADLINE_EXCEEDED;\n        case Code.RESOURCE_EXHAUSTED:\n            return RpcCode.RESOURCE_EXHAUSTED;\n        case Code.INTERNAL:\n            return RpcCode.INTERNAL;\n        case Code.UNAVAILABLE:\n            return RpcCode.UNAVAILABLE;\n        case Code.UNAUTHENTICATED:\n            return RpcCode.UNAUTHENTICATED;\n        case Code.INVALID_ARGUMENT:\n            return RpcCode.INVALID_ARGUMENT;\n        case Code.NOT_FOUND:\n            return RpcCode.NOT_FOUND;\n        case Code.ALREADY_EXISTS:\n            return RpcCode.ALREADY_EXISTS;\n        case Code.PERMISSION_DENIED:\n            return RpcCode.PERMISSION_DENIED;\n        case Code.FAILED_PRECONDITION:\n            return RpcCode.FAILED_PRECONDITION;\n        case Code.ABORTED:\n            return RpcCode.ABORTED;\n        case Code.OUT_OF_RANGE:\n            return RpcCode.OUT_OF_RANGE;\n        case Code.UNIMPLEMENTED:\n            return RpcCode.UNIMPLEMENTED;\n        case Code.DATA_LOSS:\n            return RpcCode.DATA_LOSS;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Converts an HTTP Status Code to the equivalent error code.\n *\n * @param status An HTTP Status Code, like 200, 404, 503, etc.\n * @returns The equivalent Code. Unknown status codes are mapped to\n *     Code.UNKNOWN.\n */\nfunction mapCodeFromHttpStatus(status) {\n    // The canonical error codes for Google APIs [1] specify mapping onto HTTP\n    // status codes but the mapping is not bijective. In each case of ambiguity\n    // this function chooses a primary error.\n    //\n    // [1]\n    // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n    switch (status) {\n        case 200:// OK\n            return Code.OK;\n        case 400:// Bad Request\n            return Code.INVALID_ARGUMENT;\n        // Other possibilities based on the forward mapping\n        // return Code.FAILED_PRECONDITION;\n        // return Code.OUT_OF_RANGE;\n        case 401:// Unauthorized\n            return Code.UNAUTHENTICATED;\n        case 403:// Forbidden\n            return Code.PERMISSION_DENIED;\n        case 404:// Not Found\n            return Code.NOT_FOUND;\n        case 409:// Conflict\n            return Code.ABORTED;\n        // Other possibilities:\n        // return Code.ALREADY_EXISTS;\n        case 416:// Range Not Satisfiable\n            return Code.OUT_OF_RANGE;\n        case 429:// Too Many Requests\n            return Code.RESOURCE_EXHAUSTED;\n        case 499:// Client Closed Request\n            return Code.CANCELLED;\n        case 500:// Internal Server Error\n            return Code.UNKNOWN;\n        // Other possibilities:\n        // return Code.INTERNAL;\n        // return Code.DATA_LOSS;\n        case 501:// Unimplemented\n            return Code.UNIMPLEMENTED;\n        case 503:// Service Unavailable\n            return Code.UNAVAILABLE;\n        case 504:// Gateway Timeout\n            return Code.DEADLINE_EXCEEDED;\n        default:\n            if (status >= 200 && status < 300)\n                return Code.OK;\n            if (status >= 400 && status < 500)\n                return Code.FAILED_PRECONDITION;\n            if (status >= 500 && status < 600)\n                return Code.INTERNAL;\n            return Code.UNKNOWN;\n    }\n}\n\n//# sourceMappingURL=rpc_error.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/sorted_set.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nvar sorted_set_SortedSet = /** @class */ (function () {\n    function SortedSet(comparator) {\n        this.comparator = comparator;\n        this.data = new sorted_map_SortedMap(this.comparator);\n    }\n    /**\n     * Creates a SortedSet from the keys of the map.\n     * This is currently implemented as an O(n) copy.\n     */\n    SortedSet.fromMapKeys = function (map) {\n        var keys = new SortedSet(map.comparator);\n        map.forEach(function (key) {\n            keys = keys.add(key);\n        });\n        return keys;\n    };\n    SortedSet.prototype.has = function (elem) {\n        return this.data.get(elem) !== null;\n    };\n    SortedSet.prototype.first = function () {\n        return this.data.minKey();\n    };\n    SortedSet.prototype.last = function () {\n        return this.data.maxKey();\n    };\n    Object.defineProperty(SortedSet.prototype, \"size\", {\n        get: function () {\n            return this.data.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SortedSet.prototype.indexOf = function (elem) {\n        return this.data.indexOf(elem);\n    };\n    /** Iterates elements in order defined by \"comparator\" */\n    SortedSet.prototype.forEach = function (cb) {\n        this.data.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Iterates over `elem`s such that: range[0] <= elem < range[1]. */\n    SortedSet.prototype.forEachInRange = function (range, cb) {\n        var iter = this.data.getIteratorFrom(range[0]);\n        while (iter.hasNext()) {\n            var elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0)\n                return;\n            cb(elem.key);\n        }\n    };\n    /**\n     * Iterates over `elem`s such that: start <= elem until false is returned.\n     */\n    SortedSet.prototype.forEachWhile = function (cb, start) {\n        var iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        }\n        else {\n            iter = this.data.getIterator();\n        }\n        while (iter.hasNext()) {\n            var elem = iter.getNext();\n            var result = cb(elem.key);\n            if (!result)\n                return;\n        }\n    };\n    /** Finds the least element greater than or equal to `elem`. */\n    SortedSet.prototype.firstAfterOrEqual = function (elem) {\n        var iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    };\n    /** Inserts or updates an element */\n    SortedSet.prototype.add = function (elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    };\n    /** Deletes an element */\n    SortedSet.prototype.delete = function (elem) {\n        if (!this.has(elem))\n            return this;\n        return this.copy(this.data.remove(elem));\n    };\n    SortedSet.prototype.isEmpty = function () {\n        return this.data.isEmpty();\n    };\n    SortedSet.prototype.unionWith = function (other) {\n        var result = this;\n        other.forEach(function (elem) {\n            result = result.add(elem);\n        });\n        return result;\n    };\n    SortedSet.prototype.equals = function (other) {\n        if (!(other instanceof SortedSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.data.getIterator();\n        var otherIt = other.data.getIterator();\n        while (thisIt.hasNext()) {\n            var thisElem = thisIt.getNext().key;\n            var otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0)\n                return false;\n        }\n        return true;\n    };\n    SortedSet.prototype.toString = function () {\n        var result = [];\n        this.forEach(function (elem) { return result.push(elem); });\n        return 'SortedSet(' + result.toString() + ')';\n    };\n    SortedSet.prototype.copy = function (data) {\n        var result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    };\n    return SortedSet;\n}());\n\n\n//# sourceMappingURL=sorted_set.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/collections.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar EMPTY_MAYBE_DOCUMENT_MAP = new sorted_map_SortedMap(document_key_DocumentKey.comparator);\nfunction maybeDocumentMap() {\n    return EMPTY_MAYBE_DOCUMENT_MAP;\n}\nvar EMPTY_DOCUMENT_MAP = new sorted_map_SortedMap(document_key_DocumentKey.comparator);\nfunction documentMap() {\n    return EMPTY_DOCUMENT_MAP;\n}\nvar EMPTY_DOCUMENT_VERSION_MAP = new sorted_map_SortedMap(document_key_DocumentKey.comparator);\nfunction documentVersionMap() {\n    return EMPTY_DOCUMENT_VERSION_MAP;\n}\nvar EMPTY_DOCUMENT_KEY_SET = new sorted_set_SortedSet(document_key_DocumentKey.comparator);\nfunction documentKeySet() {\n    return EMPTY_DOCUMENT_KEY_SET;\n}\n\n//# sourceMappingURL=collections.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/remote_event.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nvar remote_event_RemoteEvent = /** @class */ (function () {\n    function RemoteEvent(\n        /**\n           * The snapshot version this event brings us up to, or MIN if not set.\n           */\n        snapshotVersion, \n        /**\n           * A map from target to changes to the target. See TargetChange.\n           */\n        targetChanges, \n        /**\n           * A set of which documents have changed or been deleted, along with the\n           * doc's new values (if not deleted).\n           */\n        documentUpdates) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.documentUpdates = documentUpdates;\n    }\n    RemoteEvent.prototype.addDocumentUpdate = function (doc) {\n        this.documentUpdates = this.documentUpdates.insert(doc.key, doc);\n    };\n    RemoteEvent.prototype.handleExistenceFilterMismatch = function (targetId) {\n        /*\n         * An existence filter mismatch will reset the query and we need to reset\n         * the mapping to contain no documents and an empty resume token.\n         *\n         * Note:\n         *   * The reset mapping is empty, specifically forcing the consumer of the\n         *     change to forget all keys for this targetID;\n         *   * The resume snapshot for this target must be reset\n         *   * The target must be unacked because unwatching and rewatching\n         *     introduces a race for changes.\n         */\n        this.targetChanges[targetId] = {\n            mapping: new ResetMapping(),\n            snapshotVersion: snapshot_version_SnapshotVersion.MIN,\n            currentStatusUpdate: CurrentStatusUpdate.MarkNotCurrent,\n            resumeToken: emptyByteString()\n        };\n    };\n    return RemoteEvent;\n}());\n\n/**\n * Represents an update to the current status of a target, either explicitly\n * having no new state, or the new value to set. Note \"current\" has special\n * meaning for in the RPC protocol that implies that a target is both up-to-date\n * and consistent with the rest of the watch stream.\n */\nvar CurrentStatusUpdate;\n(function (CurrentStatusUpdate) {\n    /** The current status is not affected and should not be modified. */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"None\"] = 0] = \"None\";\n    /** The target must be marked as no longer \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkNotCurrent\"] = 1] = \"MarkNotCurrent\";\n    /** The target must be marked as \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkCurrent\"] = 2] = \"MarkCurrent\";\n})(CurrentStatusUpdate = CurrentStatusUpdate || (CurrentStatusUpdate = {}));\nvar EMPTY_KEY_SET = documentKeySet();\nvar ResetMapping = /** @class */ (function () {\n    function ResetMapping() {\n        this.docs = EMPTY_KEY_SET;\n    }\n    Object.defineProperty(ResetMapping.prototype, \"documents\", {\n        get: function () {\n            return this.docs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ResetMapping.prototype.add = function (key) {\n        this.docs = this.docs.add(key);\n    };\n    ResetMapping.prototype.delete = function (key) {\n        this.docs = this.docs.delete(key);\n    };\n    ResetMapping.prototype.equals = function (other) {\n        return other !== null && this.docs.equals(other.docs);\n    };\n    return ResetMapping;\n}());\n\nvar UpdateMapping = /** @class */ (function () {\n    function UpdateMapping() {\n        this.addedDocuments = EMPTY_KEY_SET;\n        this.removedDocuments = EMPTY_KEY_SET;\n    }\n    UpdateMapping.prototype.applyToKeySet = function (keys) {\n        var result = keys;\n        this.addedDocuments.forEach(function (key) { return (result = result.add(key)); });\n        this.removedDocuments.forEach(function (key) { return (result = result.delete(key)); });\n        return result;\n    };\n    UpdateMapping.prototype.add = function (key) {\n        this.addedDocuments = this.addedDocuments.add(key);\n        this.removedDocuments = this.removedDocuments.delete(key);\n    };\n    UpdateMapping.prototype.delete = function (key) {\n        this.addedDocuments = this.addedDocuments.delete(key);\n        this.removedDocuments = this.removedDocuments.add(key);\n    };\n    UpdateMapping.prototype.equals = function (other) {\n        return (other !== null &&\n            this.addedDocuments.equals(other.addedDocuments) &&\n            this.removedDocuments.equals(other.removedDocuments));\n    };\n    return UpdateMapping;\n}());\n\n\n//# sourceMappingURL=remote_event.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/watch_change.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nvar DocumentWatchChange = /** @class */ (function () {\n    function DocumentWatchChange(\n        /** The new document applies to all of these targets. */\n        updatedTargetIds, \n        /** The new document is removed from all of these targets. */\n        removedTargetIds, \n        /** The key of the document for this change. */\n        key, \n        /**\n           * The new document or NoDocument if it was deleted. Is null if the\n           * document went out of view without the server sending a new document.\n           */\n        newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n    return DocumentWatchChange;\n}());\n\nvar ExistenceFilterChange = /** @class */ (function () {\n    function ExistenceFilterChange(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n    return ExistenceFilterChange;\n}());\n\nvar WatchTargetChangeState;\n(function (WatchTargetChangeState) {\n    WatchTargetChangeState[WatchTargetChangeState[\"NoChange\"] = 0] = \"NoChange\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Added\"] = 1] = \"Added\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Removed\"] = 2] = \"Removed\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Current\"] = 3] = \"Current\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Reset\"] = 4] = \"Reset\";\n})(WatchTargetChangeState = WatchTargetChangeState || (WatchTargetChangeState = {}));\nvar watch_change_WatchTargetChange = /** @class */ (function () {\n    function WatchTargetChange(\n        /** What kind of change occurred to the watch target. */\n        state, \n        /** The target IDs that were added/removed/set. */\n        targetIds, \n        /**\n           * An opaque, server-assigned token that allows watching a query to be\n           * resumed after disconnecting without retransmitting all the data that\n           * matches the query. The resume token essentially identifies a point in\n           * time from which the server should resume sending results.\n           */\n        resumeToken, \n        /** An RPC error indicating why the watch failed. */\n        cause) {\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        if (cause === void 0) { cause = null; }\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n    return WatchTargetChange;\n}());\n\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nvar watch_change_WatchChangeAggregator = /** @class */ (function () {\n    function WatchChangeAggregator(snapshotVersion, listenTargets, pendingTargetResponses) {\n        this.snapshotVersion = snapshotVersion;\n        this.listenTargets = listenTargets;\n        /** The existence filter - if any - for the given target IDs. */\n        this.existenceFilters = {};\n        /** Keeps track of the current target mappings */\n        this.targetChanges = {};\n        /** Keeps track of document to update */\n        this.documentUpdates = maybeDocumentMap();\n        /** Whether this aggregator was frozen and can no longer be modified */\n        this.frozen = false;\n        this.pendingTargetResponses = shallowCopy(pendingTargetResponses);\n    }\n    /** Aggregates a watch change into the current state */\n    WatchChangeAggregator.prototype.add = function (watchChange) {\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        if (watchChange instanceof DocumentWatchChange) {\n            this.addDocumentChange(watchChange);\n        }\n        else if (watchChange instanceof watch_change_WatchTargetChange) {\n            this.addTargetChange(watchChange);\n        }\n        else if (watchChange instanceof ExistenceFilterChange) {\n            this.addExistenceFilterChange(watchChange);\n        }\n        else {\n            fail('Unknown watch change: ' + watchChange);\n        }\n    };\n    /** Aggregates all provided watch changes to the current state in order */\n    WatchChangeAggregator.prototype.addChanges = function (watchChanges) {\n        var _this = this;\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        watchChanges.forEach(function (change) { return _this.add(change); });\n    };\n    /**\n     * Converts the current state into a remote event with the snapshot version\n     * provided via the constructor.\n     */\n    WatchChangeAggregator.prototype.createRemoteEvent = function () {\n        var _this = this;\n        var targetChanges = this.targetChanges;\n        // Remove all the non-active targets from the remote event.\n        forEachNumber(this.targetChanges, function (targetId) {\n            if (!_this.isActiveTarget(targetId)) {\n                delete targetChanges[targetId];\n            }\n        });\n        // Mark this aggregator as frozen so no further modifications are made\n        this.frozen = true;\n        return new remote_event_RemoteEvent(this.snapshotVersion, targetChanges, this.documentUpdates);\n    };\n    WatchChangeAggregator.prototype.ensureTargetChange = function (targetId) {\n        var change = this.targetChanges[targetId];\n        if (!change) {\n            // Create an UpdateMapping by default, since resets are always explicit.\n            change = {\n                currentStatusUpdate: CurrentStatusUpdate.None,\n                snapshotVersion: this.snapshotVersion,\n                mapping: new UpdateMapping(),\n                resumeToken: emptyByteString()\n            };\n            this.targetChanges[targetId] = change;\n        }\n        return change;\n    };\n    /**\n     * We need to wait for watch to ack targets before we process those events,\n     * so to know if a target is active, there must be no pending acks we're\n     * waiting for and it must be in the current list of targets that the client\n     * cares about.\n     *\n     * This method is visible for testing.\n     */\n    WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {\n        return (!contains(this.pendingTargetResponses, targetId) &&\n            contains(this.listenTargets, targetId));\n    };\n    WatchChangeAggregator.prototype.addDocumentChange = function (docChange) {\n        var relevant = false;\n        for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {\n            var targetId = _a[_i];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.add(docChange.key);\n                relevant = true;\n            }\n        }\n        for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {\n            var targetId = _c[_b];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.delete(docChange.key);\n                relevant = true;\n            }\n        }\n        // Only update the document if there is a new document to replace to an\n        // active target that is being listened to, this might be just a target\n        // update instead.\n        if (docChange.newDoc && relevant) {\n            this.documentUpdates = this.documentUpdates.insert(docChange.key, docChange.newDoc);\n        }\n    };\n    WatchChangeAggregator.prototype.addTargetChange = function (targetChange) {\n        var _this = this;\n        targetChange.targetIds.forEach(function (targetId) {\n            var change = _this.ensureTargetChange(targetId);\n            switch (targetChange.state) {\n                case WatchTargetChangeState.NoChange:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Creating the change above satisfies the semantics of no-change.\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Added:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    if (!contains(_this.pendingTargetResponses, targetId)) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        change.mapping = new UpdateMapping();\n                        change.currentStatusUpdate = CurrentStatusUpdate.None;\n                        delete _this.existenceFilters[targetId];\n                    }\n                    applyResumeToken(change, targetChange.resumeToken);\n                    break;\n                case WatchTargetChangeState.Removed:\n                    // We need to keep track of removed targets to we can\n                    // post-filter and remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');\n                    break;\n                case WatchTargetChangeState.Current:\n                    if (_this.isActiveTarget(targetId)) {\n                        change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Reset:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Overwrite any existing target mapping with a reset\n                        // mapping. Every subsequent update will modify the reset\n                        // mapping, not an update mapping.\n                        change.mapping = new ResetMapping();\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail('Unknown target watch change state: ' + targetChange.state);\n            }\n        });\n    };\n    /**\n     * Record that we get a watch target add/remove by decrementing the number of\n     * pending target responses that we have.\n     */\n    WatchChangeAggregator.prototype.recordTargetResponse = function (targetId) {\n        var newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n        if (newCount === 0) {\n            delete this.pendingTargetResponses[targetId];\n        }\n        else {\n            this.pendingTargetResponses[targetId] = newCount;\n        }\n    };\n    WatchChangeAggregator.prototype.addExistenceFilterChange = function (change) {\n        if (this.isActiveTarget(change.targetId)) {\n            this.existenceFilters[change.targetId] = change.existenceFilter;\n        }\n    };\n    return WatchChangeAggregator;\n}());\n\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(change, resumeToken) {\n    if (resumeToken.length > 0) {\n        change.resumeToken = resumeToken;\n    }\n}\n\n//# sourceMappingURL=watch_change.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/serializer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DIRECTIONS = (function () {\n    var dirs = {};\n    dirs[Direction.ASCENDING.name] = 'ASCENDING';\n    dirs[Direction.DESCENDING.name] = 'DESCENDING';\n    return dirs;\n})();\nvar OPERATORS = (function () {\n    var ops = {};\n    ops[query_RelationOp.LESS_THAN.name] = 'LESS_THAN';\n    ops[query_RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';\n    ops[query_RelationOp.GREATER_THAN.name] = 'GREATER_THAN';\n    ops[query_RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';\n    ops[query_RelationOp.EQUAL.name] = 'EQUAL';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n    assert(!isNullOrUndefined(value), description + ' is missing');\n}\nfunction parseInt64(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return parseInt(value, 10);\n    }\n    else {\n        return fail(\"can't parse \" + value);\n    }\n}\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nvar serializer_JsonProtoSerializer = /** @class */ (function () {\n    function JsonProtoSerializer(databaseId, options) {\n        this.databaseId = databaseId;\n        this.options = options;\n    }\n    JsonProtoSerializer.prototype.emptyByteString = function () {\n        if (this.options.useProto3Json) {\n            return '';\n        }\n        else {\n            return new Uint8Array(0);\n        }\n    };\n    JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) {\n        // byteStrings can be either string or UInt8Array, but the typings say\n        // it's always a string. Cast as string to avoid type check failing\n        return byteString;\n    };\n    JsonProtoSerializer.prototype.fromRpcStatus = function (status) {\n        var code = status.code === undefined\n            ? Code.UNKNOWN\n            : mapCodeFromRpcCode(status.code);\n        return new FirestoreError(code, status.message || '');\n    };\n    /**\n     * Returns a value for a Date that's appropriate to put into a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say dates must be. But it's easier and safer\n     * to actually return a Timestamp proto.\n     */\n    JsonProtoSerializer.prototype.toTimestamp = function (timestamp) {\n        return {\n            seconds: timestamp.seconds,\n            nanos: timestamp.nanos\n            // tslint:disable-next-line:no-any\n        };\n    };\n    JsonProtoSerializer.prototype.fromTimestamp = function (date) {\n        // The json interface (for the browser) will return an iso timestamp string,\n        // while the proto js library (for node) will return a\n        // google.protobuf.Timestamp instance.\n        if (typeof date === 'string') {\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(this.options.useProto3Json,\n            //   'The timestamp string format requires Proto3.');\n            return timestamp_Timestamp.fromISOString(date);\n        }\n        else {\n            assert(!!date, 'Cannot deserialize null or undefined timestamp.');\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(!this.options.useProto3Json,\n            //   'The timestamp instance format requires Proto JS.');\n            var seconds = parseInt64(date.seconds || '0');\n            var nanos = date.nanos || 0;\n            return new timestamp_Timestamp(seconds, nanos);\n        }\n    };\n    /**\n     * Returns a value for bytes that's appropriate to put in a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say bytes must be. But it should return\n     * an Uint8Array in Node.\n     */\n    JsonProtoSerializer.prototype.toBytes = function (bytes) {\n        if (this.options.useProto3Json) {\n            return bytes.toBase64();\n        }\n        else {\n            // The typings say it's a string, but it needs to be a Uint8Array in Node.\n            return this.unsafeCastProtoByteString(bytes.toUint8Array());\n        }\n    };\n    /**\n     * Parse the blob from the protos into the internal Blob class. Note that the\n     * typings assume all blobs are strings, but they are actually Uint8Arrays\n     * on Node.\n     */\n    JsonProtoSerializer.prototype.fromBlob = function (blob) {\n        if (typeof blob === 'string') {\n            assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');\n            return blob_Blob.fromBase64String(blob);\n        }\n        else {\n            assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');\n            return blob_Blob.fromUint8Array(blob);\n        }\n    };\n    JsonProtoSerializer.prototype.toVersion = function (version) {\n        return this.toTimestamp(version.toTimestamp());\n    };\n    JsonProtoSerializer.prototype.fromVersion = function (version) {\n        assert(!!version, \"Trying to deserialize version that isn't set\");\n        return snapshot_version_SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n    };\n    JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) {\n        return this.fullyQualifiedPrefixPath(databaseId)\n            .child('documents')\n            .child(path)\n            .canonicalString();\n    };\n    JsonProtoSerializer.prototype.fromResourceName = function (name) {\n        var resource = path_ResourcePath.fromString(name);\n        assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());\n        return resource;\n    };\n    JsonProtoSerializer.prototype.toName = function (key) {\n        return this.toResourceName(this.databaseId, key.path);\n    };\n    JsonProtoSerializer.prototype.fromName = function (name) {\n        var resource = this.fromResourceName(name);\n        assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            this.databaseId.projectId);\n        assert((!resource.get(3) && !this.databaseId.database) ||\n            resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            this.databaseId.database);\n        return new document_key_DocumentKey(this.extractLocalPathFromResourceName(resource));\n    };\n    JsonProtoSerializer.prototype.toQueryPath = function (path) {\n        if (path.length === 0) {\n            // If the path is empty, the backend requires we leave off the /documents\n            // at the end.\n            return this.encodedDatabaseId;\n        }\n        return this.toResourceName(this.databaseId, path);\n    };\n    JsonProtoSerializer.prototype.fromQueryPath = function (name) {\n        var resourceName = this.fromResourceName(name);\n        if (resourceName.length === 4) {\n            return path_ResourcePath.EMPTY_PATH;\n        }\n        return this.extractLocalPathFromResourceName(resourceName);\n    };\n    Object.defineProperty(JsonProtoSerializer.prototype, \"encodedDatabaseId\", {\n        get: function () {\n            var path = new path_ResourcePath([\n                'projects',\n                this.databaseId.projectId,\n                'databases',\n                this.databaseId.database\n            ]);\n            return path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) {\n        return new path_ResourcePath([\n            'projects',\n            databaseId.projectId,\n            'databases',\n            databaseId.database\n        ]);\n    };\n    JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) {\n        assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());\n        return resourceName.popFirst(5);\n    };\n    JsonProtoSerializer.prototype.isValidResourceName = function (path) {\n        // Resource names have at least 4 components (project ID, database ID)\n        return (path.length >= 4 &&\n            path.get(0) === 'projects' &&\n            path.get(2) === 'databases');\n    };\n    JsonProtoSerializer.prototype.toValue = function (val) {\n        if (val instanceof NullValue) {\n            return { nullValue: 'NULL_VALUE' };\n        }\n        else if (val instanceof field_value_BooleanValue) {\n            return { booleanValue: val.value() };\n        }\n        else if (val instanceof IntegerValue) {\n            return { integerValue: '' + val.value() };\n        }\n        else if (val instanceof DoubleValue) {\n            var doubleValue = val.value();\n            if (this.options.useProto3Json) {\n                // Proto 3 let's us encode NaN and Infinity as string values as\n                // expected by the backend. This is currently not checked by our unit\n                // tests because they rely on protobuf.js.\n                if (isNaN(doubleValue)) {\n                    return { doubleValue: 'NaN' };\n                }\n                else if (doubleValue === Infinity) {\n                    return { doubleValue: 'Infinity' };\n                }\n                else if (doubleValue === -Infinity) {\n                    return { doubleValue: '-Infinity' };\n                }\n            }\n            return { doubleValue: val.value() };\n        }\n        else if (val instanceof field_value_StringValue) {\n            return { stringValue: val.value() };\n        }\n        else if (val instanceof field_value_ObjectValue) {\n            return { mapValue: this.toMapValue(val) };\n        }\n        else if (val instanceof field_value_ArrayValue) {\n            return { arrayValue: this.toArrayValue(val) };\n        }\n        else if (val instanceof TimestampValue) {\n            return {\n                timestampValue: this.toTimestamp(val.internalValue)\n            };\n        }\n        else if (val instanceof GeoPointValue) {\n            return {\n                geoPointValue: {\n                    latitude: val.value().latitude,\n                    longitude: val.value().longitude\n                }\n            };\n        }\n        else if (val instanceof BlobValue) {\n            return {\n                bytesValue: this.toBytes(val.value())\n            };\n        }\n        else if (val instanceof field_value_RefValue) {\n            return {\n                referenceValue: this.toResourceName(val.databaseId, val.key.path)\n            };\n        }\n        else {\n            return fail('Unknown FieldValue ' + JSON.stringify(val));\n        }\n    };\n    JsonProtoSerializer.prototype.fromValue = function (obj) {\n        var _this = this;\n        // tslint:disable-next-line:no-any\n        var type = obj['value_type'];\n        if (hasTag(obj, type, 'nullValue')) {\n            return NullValue.INSTANCE;\n        }\n        else if (hasTag(obj, type, 'booleanValue')) {\n            return field_value_BooleanValue.of(obj.booleanValue);\n        }\n        else if (hasTag(obj, type, 'integerValue')) {\n            return new IntegerValue(parseInt64(obj.integerValue));\n        }\n        else if (hasTag(obj, type, 'doubleValue')) {\n            if (this.options.useProto3Json) {\n                // Proto 3 uses the string values 'NaN' and 'Infinity'.\n                if (obj.doubleValue === 'NaN') {\n                    return DoubleValue.NAN;\n                }\n                else if (obj.doubleValue === 'Infinity') {\n                    return DoubleValue.POSITIVE_INFINITY;\n                }\n                else if (obj.doubleValue === '-Infinity') {\n                    return DoubleValue.NEGATIVE_INFINITY;\n                }\n            }\n            return new DoubleValue(obj.doubleValue);\n        }\n        else if (hasTag(obj, type, 'stringValue')) {\n            return new field_value_StringValue(obj.stringValue);\n        }\n        else if (hasTag(obj, type, 'mapValue')) {\n            return this.fromFields(obj.mapValue.fields || {});\n        }\n        else if (hasTag(obj, type, 'arrayValue')) {\n            // \"values\" is not present if the array is empty\n            assertPresent(obj.arrayValue, 'arrayValue');\n            var values = obj.arrayValue.values || [];\n            return new field_value_ArrayValue(values.map(function (v) { return _this.fromValue(v); }));\n        }\n        else if (hasTag(obj, type, 'timestampValue')) {\n            assertPresent(obj.timestampValue, 'timestampValue');\n            return new TimestampValue(this.fromTimestamp(obj.timestampValue));\n        }\n        else if (hasTag(obj, type, 'geoPointValue')) {\n            assertPresent(obj.geoPointValue, 'geoPointValue');\n            var latitude = obj.geoPointValue.latitude || 0;\n            var longitude = obj.geoPointValue.longitude || 0;\n            return new GeoPointValue(new geo_point_GeoPoint(latitude, longitude));\n        }\n        else if (hasTag(obj, type, 'bytesValue')) {\n            assertPresent(obj.bytesValue, 'bytesValue');\n            var blob = this.fromBlob(obj.bytesValue);\n            return new BlobValue(blob);\n        }\n        else if (hasTag(obj, type, 'referenceValue')) {\n            assertPresent(obj.referenceValue, 'referenceValue');\n            var resourceName = this.fromResourceName(obj.referenceValue);\n            var dbId = new database_info_DatabaseId(resourceName.get(1), resourceName.get(3));\n            var key = new document_key_DocumentKey(this.extractLocalPathFromResourceName(resourceName));\n            return new field_value_RefValue(dbId, key);\n        }\n        else {\n            return fail('Unknown Value proto ' + JSON.stringify(obj));\n        }\n    };\n    /** Creates an api.Document from key and fields (but no create/update time) */\n    JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) {\n        return {\n            name: this.toName(key),\n            fields: this.toFields(fields)\n        };\n    };\n    JsonProtoSerializer.prototype.toDocument = function (document) {\n        assert(!document.hasLocalMutations, \"Can't serialize documents with mutations.\");\n        return {\n            name: this.toName(document.key),\n            fields: this.toFields(document.data),\n            updateTime: this.toTimestamp(document.version.toTimestamp())\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocument = function (document) {\n        return new document_Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.toFields = function (fields) {\n        var _this = this;\n        var result = {};\n        fields.forEach(function (key, value) {\n            result[key] = _this.toValue(value);\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromFields = function (object) {\n        var _this = this;\n        // Proto map<string, Value> gets mapped to Object, so cast it.\n        var map = object;\n        var result = field_value_ObjectValue.EMPTY;\n        forEach(map, function (key, value) {\n            result = result.set(new path_FieldPath([key]), _this.fromValue(value));\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.toMapValue = function (map) {\n        return {\n            fields: this.toFields(map)\n        };\n    };\n    JsonProtoSerializer.prototype.toArrayValue = function (array) {\n        var _this = this;\n        var result = [];\n        array.forEach(function (value) {\n            result.push(_this.toValue(value));\n        });\n        return { values: result };\n    };\n    JsonProtoSerializer.prototype.fromFound = function (doc) {\n        assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');\n        assertPresent(doc.found.name, 'doc.found.name');\n        assertPresent(doc.found.updateTime, 'doc.found.updateTime');\n        var key = this.fromName(doc.found.name);\n        var version = this.fromVersion(doc.found.updateTime);\n        var fields = this.fromFields(doc.found.fields || {});\n        return new document_Document(key, version, fields, { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.fromMissing = function (result) {\n        assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');\n        assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');\n        var key = this.fromName(result.missing);\n        var version = this.fromVersion(result.readTime);\n        return new document_NoDocument(key, version);\n    };\n    JsonProtoSerializer.prototype.fromMaybeDocument = function (result) {\n        // tslint:disable-next-line:no-any\n        var type = result['result_type'];\n        if (hasTag(result, type, 'found')) {\n            return this.fromFound(result);\n        }\n        else if (hasTag(result, type, 'missing')) {\n            return this.fromMissing(result);\n        }\n        return fail('invalid batch get response: ' + JSON.stringify(result));\n    };\n    JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) {\n        switch (state) {\n            case WatchTargetChangeState.Added:\n                return 'ADD';\n            case WatchTargetChangeState.Current:\n                return 'CURRENT';\n            case WatchTargetChangeState.NoChange:\n                return 'NO_CHANGE';\n            case WatchTargetChangeState.Removed:\n                return 'REMOVE';\n            case WatchTargetChangeState.Reset:\n                return 'RESET';\n            default:\n                return fail('Unknown WatchTargetChangeState: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) {\n        if (watchChange instanceof ExistenceFilterChange) {\n            return {\n                filter: {\n                    count: watchChange.existenceFilter.count,\n                    targetId: watchChange.targetId\n                }\n            };\n        }\n        if (watchChange instanceof DocumentWatchChange) {\n            if (watchChange.newDoc instanceof document_Document) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentChange: {\n                        document: {\n                            name: this.toName(doc.key),\n                            fields: this.toFields(doc.data),\n                            updateTime: this.toVersion(doc.version)\n                        },\n                        targetIds: watchChange.updatedTargetIds,\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc instanceof document_NoDocument) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentDelete: {\n                        document: this.toName(doc.key),\n                        readTime: this.toVersion(doc.version),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc === null) {\n                return {\n                    documentRemove: {\n                        document: this.toName(watchChange.key),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n        }\n        if (watchChange instanceof watch_change_WatchTargetChange) {\n            var cause = undefined;\n            if (watchChange.cause) {\n                cause = {\n                    code: mapRpcCodeFromCode(watchChange.cause.code),\n                    message: watchChange.cause.message\n                };\n            }\n            return {\n                targetChange: {\n                    targetChangeType: this.toWatchTargetChangeState(watchChange.state),\n                    targetIds: watchChange.targetIds,\n                    resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),\n                    cause: cause\n                }\n            };\n        }\n        return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));\n    };\n    JsonProtoSerializer.prototype.fromWatchChange = function (change) {\n        // tslint:disable-next-line:no-any\n        var type = change['change_type'];\n        var watchChange;\n        if (hasTag(change, type, 'targetChange')) {\n            assertPresent(change.targetChange, 'targetChange');\n            // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n            // if unset\n            var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n            var targetIds = change.targetChange.targetIds || [];\n            var resumeToken = change.targetChange.resumeToken || this.emptyByteString();\n            var causeProto = change.targetChange.cause;\n            var cause = causeProto && this.fromRpcStatus(causeProto);\n            watchChange = new watch_change_WatchTargetChange(state, targetIds, resumeToken, cause || null);\n        }\n        else if (hasTag(change, type, 'documentChange')) {\n            assertPresent(change.documentChange, 'documentChange');\n            assertPresent(change.documentChange.document, 'documentChange.name');\n            assertPresent(change.documentChange.document.name, 'documentChange.document.name');\n            assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');\n            var entityChange = change.documentChange;\n            var key = this.fromName(entityChange.document.name);\n            var version = this.fromVersion(entityChange.document.updateTime);\n            var fields = this.fromFields(entityChange.document.fields || {});\n            var doc = new document_Document(key, version, fields, {\n                hasLocalMutations: false\n            });\n            var updatedTargetIds = entityChange.targetIds || [];\n            var removedTargetIds = entityChange.removedTargetIds || [];\n            watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentDelete')) {\n            assertPresent(change.documentDelete, 'documentDelete');\n            assertPresent(change.documentDelete.document, 'documentDelete.document');\n            var docDelete = change.documentDelete;\n            var key = this.fromName(docDelete.document);\n            var version = docDelete.readTime\n                ? this.fromVersion(docDelete.readTime)\n                : snapshot_version_SnapshotVersion.forDeletedDoc();\n            var doc = new document_NoDocument(key, version);\n            var removedTargetIds = docDelete.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentRemove')) {\n            assertPresent(change.documentRemove, 'documentRemove');\n            assertPresent(change.documentRemove.document, 'documentRemove');\n            var docRemove = change.documentRemove;\n            var key = this.fromName(docRemove.document);\n            var removedTargetIds = docRemove.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n        }\n        else if (hasTag(change, type, 'filter')) {\n            // TODO(dimond): implement existence filter parsing with strategy.\n            assertPresent(change.filter, 'filter');\n            assertPresent(change.filter.targetId, 'filter.targetId');\n            var filter = change.filter;\n            var count = filter.count || 0;\n            var existenceFilter = new ExistenceFilter(count);\n            var targetId = filter.targetId;\n            watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n        }\n        else {\n            return fail('Unknown change type ' + JSON.stringify(change));\n        }\n        return watchChange;\n    };\n    JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) {\n        if (state === 'NO_CHANGE') {\n            return WatchTargetChangeState.NoChange;\n        }\n        else if (state === 'ADD') {\n            return WatchTargetChangeState.Added;\n        }\n        else if (state === 'REMOVE') {\n            return WatchTargetChangeState.Removed;\n        }\n        else if (state === 'CURRENT') {\n            return WatchTargetChangeState.Current;\n        }\n        else if (state === 'RESET') {\n            return WatchTargetChangeState.Reset;\n        }\n        else {\n            return fail('Got unexpected TargetChange.state: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.versionFromListenResponse = function (change) {\n        // We have only reached a consistent snapshot for the entire stream if there\n        // is a read_time set and it applies to all targets (i.e. the list of\n        // targets is empty). The backend is guaranteed to send such responses.\n        // tslint:disable-next-line:no-any\n        var type = change['response_type'];\n        if (!hasTag(change, type, 'targetChange')) {\n            return snapshot_version_SnapshotVersion.MIN;\n        }\n        var targetChange = change.targetChange;\n        if (targetChange.targetIds && targetChange.targetIds.length) {\n            return snapshot_version_SnapshotVersion.MIN;\n        }\n        if (!targetChange.readTime) {\n            return snapshot_version_SnapshotVersion.MIN;\n        }\n        return this.fromVersion(targetChange.readTime);\n    };\n    JsonProtoSerializer.prototype.toMutation = function (mutation) {\n        var _this = this;\n        var result;\n        if (mutation instanceof mutation_SetMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.value)\n            };\n        }\n        else if (mutation instanceof mutation_DeleteMutation) {\n            result = { delete: this.toName(mutation.key) };\n        }\n        else if (mutation instanceof mutation_PatchMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.data),\n                updateMask: this.toDocumentMask(mutation.fieldMask)\n            };\n        }\n        else if (mutation instanceof mutation_TransformMutation) {\n            result = {\n                transform: {\n                    document: this.toName(mutation.key),\n                    fieldTransforms: mutation.fieldTransforms.map(function (transform) {\n                        return _this.toFieldTransform(transform);\n                    })\n                }\n            };\n        }\n        else {\n            return fail('Unknown mutation type ' + mutation.type);\n        }\n        if (!mutation.precondition.isNone) {\n            result.currentDocument = this.toPrecondition(mutation.precondition);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromMutation = function (proto) {\n        var _this = this;\n        var precondition = proto.currentDocument\n            ? this.fromPrecondition(proto.currentDocument)\n            : mutation_Precondition.NONE;\n        if (proto.update) {\n            assertPresent(proto.update.name, 'name');\n            var key = this.fromName(proto.update.name);\n            var value = this.fromFields(proto.update.fields || {});\n            if (proto.updateMask) {\n                var fieldMask = this.fromDocumentMask(proto.updateMask);\n                return new mutation_PatchMutation(key, value, fieldMask, precondition);\n            }\n            else {\n                return new mutation_SetMutation(key, value, precondition);\n            }\n        }\n        else if (proto.delete) {\n            var key = this.fromName(proto.delete);\n            return new mutation_DeleteMutation(key, precondition);\n        }\n        else if (proto.transform) {\n            var key = this.fromName(proto.transform.document);\n            var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) {\n                return _this.fromFieldTransform(transform);\n            });\n            assert(precondition.exists === true, 'Transforms only support precondition \"exists == true\"');\n            return new mutation_TransformMutation(key, fieldTransforms);\n        }\n        else {\n            return fail('unknown mutation proto: ' + JSON.stringify(proto));\n        }\n    };\n    JsonProtoSerializer.prototype.toPrecondition = function (precondition) {\n        assert(!precondition.isNone, \"Can't serialize an empty precondition\");\n        if (precondition.updateTime !== undefined) {\n            return {\n                updateTime: this.toVersion(precondition.updateTime)\n            };\n        }\n        else if (precondition.exists !== undefined) {\n            return { exists: precondition.exists };\n        }\n        else {\n            return fail('Unknown precondition');\n        }\n    };\n    JsonProtoSerializer.prototype.fromPrecondition = function (precondition) {\n        if (precondition.updateTime !== undefined) {\n            return mutation_Precondition.updateTime(this.fromVersion(precondition.updateTime));\n        }\n        else if (precondition.exists !== undefined) {\n            return mutation_Precondition.exists(precondition.exists);\n        }\n        else {\n            return mutation_Precondition.NONE;\n        }\n    };\n    JsonProtoSerializer.prototype.fromWriteResult = function (proto) {\n        var _this = this;\n        // NOTE: Deletes don't have an updateTime.\n        var version = proto.updateTime\n            ? this.fromVersion(proto.updateTime)\n            : null;\n        var transformResults = null;\n        if (proto.transformResults) {\n            transformResults = proto.transformResults.map(function (result) {\n                return _this.fromValue(result);\n            });\n        }\n        return new MutationResult(version, transformResults);\n    };\n    JsonProtoSerializer.prototype.fromWriteResults = function (protos) {\n        var _this = this;\n        return (protos || []).map(function (proto) { return _this.fromWriteResult(proto); });\n    };\n    JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) {\n        assert(fieldTransform.transform instanceof ServerTimestampTransform, 'Unknown transform: ' + fieldTransform.transform);\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    };\n    JsonProtoSerializer.prototype.fromFieldTransform = function (proto) {\n        assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown transform proto: ' + JSON.stringify(proto));\n        var fieldPath = path_FieldPath.fromServerFormat(proto.fieldPath);\n        return new FieldTransform(fieldPath, ServerTimestampTransform.instance);\n    };\n    JsonProtoSerializer.prototype.toDocumentsTarget = function (query) {\n        return { documents: [this.toQueryPath(query.path)] };\n    };\n    JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) {\n        var count = documentsTarget.documents.length;\n        assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);\n        var name = documentsTarget.documents[0];\n        return query_Query.atPath(this.fromQueryPath(name));\n    };\n    JsonProtoSerializer.prototype.toQueryTarget = function (query) {\n        // Dissect the path into parent, collectionId, and optional key filter.\n        var result = { structuredQuery: {} };\n        if (query.path.isEmpty()) {\n            result.parent = this.toQueryPath(path_ResourcePath.EMPTY_PATH);\n        }\n        else {\n            var path = query.path;\n            assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');\n            result.parent = this.toQueryPath(path.popLast());\n            result.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n        }\n        var where = this.toFilter(query.filters);\n        if (where) {\n            result.structuredQuery.where = where;\n        }\n        var orderBy = this.toOrder(query.orderBy);\n        if (orderBy) {\n            result.structuredQuery.orderBy = orderBy;\n        }\n        var limit = this.toLimit(query.limit);\n        if (limit !== undefined) {\n            result.structuredQuery.limit = limit;\n        }\n        if (query.startAt) {\n            result.structuredQuery.startAt = this.toCursor(query.startAt);\n        }\n        if (query.endAt) {\n            result.structuredQuery.endAt = this.toCursor(query.endAt);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromQueryTarget = function (target) {\n        var path = this.fromQueryPath(target.parent);\n        var query = target.structuredQuery;\n        var fromCount = query.from ? query.from.length : 0;\n        if (fromCount > 0) {\n            assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');\n            var from = query.from[0];\n            path = path.child(from.collectionId);\n        }\n        var filterBy = [];\n        if (query.where) {\n            filterBy = this.fromFilter(query.where);\n        }\n        var orderBy = [];\n        if (query.orderBy) {\n            orderBy = this.fromOrder(query.orderBy);\n        }\n        var limit = null;\n        if (query.limit) {\n            limit = query.limit;\n        }\n        var startAt = null;\n        if (query.startAt) {\n            startAt = this.fromCursor(query.startAt);\n        }\n        var endAt = null;\n        if (query.endAt) {\n            endAt = this.fromCursor(query.endAt);\n        }\n        return new query_Query(path, orderBy, filterBy, limit, startAt, endAt);\n    };\n    JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) {\n        var value = this.toLabel(queryData.purpose);\n        if (value == null) {\n            return null;\n        }\n        else {\n            return {\n                'goog-listen-tags': value\n            };\n        }\n    };\n    JsonProtoSerializer.prototype.toLabel = function (purpose) {\n        switch (purpose) {\n            case QueryPurpose.Listen:\n                return null;\n            case QueryPurpose.ExistenceFilterMismatch:\n                return 'existence-filter-mismatch';\n            case QueryPurpose.LimboResolution:\n                return 'limbo-document';\n            default:\n                return fail('Unrecognized query purpose: ' + purpose);\n        }\n    };\n    JsonProtoSerializer.prototype.toTarget = function (queryData) {\n        var result;\n        var query = queryData.query;\n        if (query.isDocumentQuery()) {\n            result = { documents: this.toDocumentsTarget(query) };\n        }\n        else {\n            result = { query: this.toQueryTarget(query) };\n        }\n        result.targetId = queryData.targetId;\n        if (queryData.resumeToken.length > 0) {\n            result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.toFilter = function (filters) {\n        var _this = this;\n        if (filters.length === 0)\n            return;\n        var protos = filters.map(function (filter) {\n            return filter instanceof query_RelationFilter\n                ? _this.toRelationFilter(filter)\n                : _this.toUnaryFilter(filter);\n        });\n        if (protos.length === 1) {\n            return protos[0];\n        }\n        return { compositeFilter: { op: 'AND', filters: protos } };\n    };\n    JsonProtoSerializer.prototype.fromFilter = function (filter) {\n        var _this = this;\n        if (!filter) {\n            return [];\n        }\n        else if (filter.unaryFilter !== undefined) {\n            return [this.fromUnaryFilter(filter)];\n        }\n        else if (filter.fieldFilter !== undefined) {\n            return [this.fromRelationFilter(filter)];\n        }\n        else if (filter.compositeFilter !== undefined) {\n            return filter.compositeFilter.filters\n                .map(function (f) { return _this.fromFilter(f); })\n                .reduce(function (accum, current) { return accum.concat(current); });\n        }\n        else {\n            return fail('Unknown filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.toOrder = function (orderBys) {\n        var _this = this;\n        if (orderBys.length === 0)\n            return;\n        return orderBys.map(function (order) { return _this.toPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.fromOrder = function (orderBys) {\n        var _this = this;\n        return orderBys.map(function (order) { return _this.fromPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.toLimit = function (limit) {\n        if (!isNullOrUndefined(limit)) {\n            return limit;\n        }\n        return;\n    };\n    JsonProtoSerializer.prototype.toCursor = function (cursor) {\n        var _this = this;\n        return {\n            before: cursor.before,\n            values: cursor.position.map(function (component) { return _this.toValue(component); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromCursor = function (cursor) {\n        var _this = this;\n        var before = !!cursor.before;\n        var position = cursor.values.map(function (component) { return _this.fromValue(component); });\n        return new query_Bound(position, before);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toDirection = function (dir) {\n        return DIRECTIONS[dir.name];\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.fromDirection = function (dir) {\n        switch (dir) {\n            case 'ASCENDING':\n                return Direction.ASCENDING;\n            case 'DESCENDING':\n                return Direction.DESCENDING;\n            default:\n                return undefined;\n        }\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toOperatorName = function (op) {\n        return OPERATORS[op.name];\n    };\n    JsonProtoSerializer.prototype.fromOperatorName = function (op) {\n        switch (op) {\n            case 'EQUAL':\n                return query_RelationOp.EQUAL;\n            case 'GREATER_THAN':\n                return query_RelationOp.GREATER_THAN;\n            case 'GREATER_THAN_OR_EQUAL':\n                return query_RelationOp.GREATER_THAN_OR_EQUAL;\n            case 'LESS_THAN':\n                return query_RelationOp.LESS_THAN;\n            case 'LESS_THAN_OR_EQUAL':\n                return query_RelationOp.LESS_THAN_OR_EQUAL;\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified relation');\n            default:\n                return fail('Unknown relation');\n        }\n    };\n    JsonProtoSerializer.prototype.toFieldPathReference = function (path) {\n        return { fieldPath: path.canonicalString() };\n    };\n    JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) {\n        return path_FieldPath.fromServerFormat(fieldReference.fieldPath);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) {\n        return {\n            field: this.toFieldPathReference(orderBy.field),\n            direction: this.toDirection(orderBy.dir)\n        };\n    };\n    JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) {\n        return new query_OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toRelationFilter = function (filter) {\n        if (filter instanceof query_RelationFilter) {\n            return {\n                fieldFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: this.toOperatorName(filter.op),\n                    value: this.toValue(filter.value)\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromRelationFilter = function (filter) {\n        return new query_RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toUnaryFilter = function (filter) {\n        if (filter instanceof NanFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (filter instanceof NullFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) {\n        switch (filter.unaryFilter.op) {\n            case 'IS_NAN':\n                var nanField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NanFilter(nanField);\n            case 'IS_NULL':\n                var nullField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NullFilter(nullField);\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified filter');\n            default:\n                return fail('Unknown filter');\n        }\n    };\n    JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) {\n        return {\n            fieldPaths: fieldMask.fields.map(function (field) { return field.canonicalString(); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocumentMask = function (proto) {\n        var paths = proto.fieldPaths || [];\n        var fields = paths.map(function (path) { return path_FieldPath.fromServerFormat(path); });\n        return new mutation_FieldMask(fields);\n    };\n    return JsonProtoSerializer;\n}());\n\n/**\n * Checks for a specific oneof tag in a protocol buffer message.\n *\n * This intentionally accommodates two distinct cases:\n *\n * 1) Messages containing a type tag: these are the format produced by GRPC in\n * return values. These may contain default-value mappings for all tags in the\n * oneof but the type tag specifies which one was actually set.\n *\n * 2) Messages that don't contain a type tag: these are the format required by\n * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would\n * choke claiming that the tags aren't fields in the Message.\n *\n * Allowing both formats here makes the serializer able to consume the outputs\n * it produces: for all messages it supports, fromX(toX(value)) == value.\n *\n * Note that case 2 suffers from ambiguity: if multiple tags are present\n * without a type tag then the callers are structured in such a way that the\n * first invocation will win. Since we only parse in this mode when parsing\n * the output of a serialize method this works, but it's not a general\n * solution.\n *\n * Unfortunately there is no general solution here because proto3 makes it\n * impossible to distinguish unset from explicitly set fields: both have the\n * default value for the type. Without the type tag but multiple value tags\n * it's possible to have default values for each tag in the oneof and not be\n * able to know which was actually in effect.\n */\nfunction hasTag(obj, type, tag) {\n    return type === tag || (!type && tag in obj);\n}\n\n//# sourceMappingURL=serializer.js.map\n\n// EXTERNAL MODULE: ../webchannel-wrapper/dist/index.js\nvar dist = __webpack_require__(115);\nvar dist_default = /*#__PURE__*/__webpack_require__.n(dist);\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/stream_bridge.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nvar stream_bridge_StreamBridge = /** @class */ (function () {\n    function StreamBridge(args) {\n        this.wrappedOnOpen = null;\n        this.wrappedOnClose = null;\n        this.wrappedOnMessage = null;\n        this.sendFn = args.sendFn;\n        this.closeFn = args.closeFn;\n    }\n    StreamBridge.prototype.onOpen = function (callback) {\n        assert(!this.wrappedOnOpen, 'Called onOpen on stream twice!');\n        this.wrappedOnOpen = callback;\n    };\n    StreamBridge.prototype.onClose = function (callback) {\n        assert(!this.wrappedOnClose, 'Called onClose on stream twice!');\n        this.wrappedOnClose = callback;\n    };\n    StreamBridge.prototype.onMessage = function (callback) {\n        assert(!this.wrappedOnMessage, 'Called onMessage on stream twice!');\n        this.wrappedOnMessage = callback;\n    };\n    StreamBridge.prototype.close = function () {\n        this.closeFn();\n    };\n    StreamBridge.prototype.send = function (msg) {\n        this.sendFn(msg);\n    };\n    StreamBridge.prototype.callOnOpen = function () {\n        assert(this.wrappedOnOpen !== null, 'Cannot call onOpen because no callback ' + 'was set');\n        this.wrappedOnOpen();\n    };\n    StreamBridge.prototype.callOnClose = function (err) {\n        assert(this.wrappedOnClose !== null, 'Cannot call onClose because no ' + 'callback was set');\n        this.wrappedOnClose(err);\n    };\n    StreamBridge.prototype.callOnMessage = function (msg) {\n        assert(this.wrappedOnMessage !== null, 'Cannot call onMessage because no ' + 'callback was set');\n        this.wrappedOnMessage(msg);\n    };\n    return StreamBridge;\n}());\n\n\n//# sourceMappingURL=stream_bridge.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform_browser/webchannel_connection.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\nvar LOG_TAG = 'Connection';\nvar RPC_URL_VERSION = 'v1beta1';\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nvar X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;\nvar XHR_TIMEOUT_SECS = 15;\nvar webchannel_connection_WebChannelConnection = /** @class */ (function () {\n    function WebChannelConnection(info) {\n        this.databaseId = info.databaseId;\n        this.pool = new dist[\"XhrIoPool\"]();\n        var proto = info.ssl ? 'https' : 'http';\n        this.baseUrl = proto + '://' + info.host;\n    }\n    /**\n     * Modifies the headers for a request, adding any authorization token if\n     * present and any additional headers for the request.\n     */\n    WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {\n        if (token) {\n            for (var header in token.authHeaders) {\n                if (token.authHeaders.hasOwnProperty(header)) {\n                    headers[header] = token.authHeaders[header];\n                }\n            }\n        }\n        headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;\n        // This header is used to improve routing and project isolation by the\n        // backend.\n        headers['google-cloud-resource-prefix'] =\n            \"projects/\" + this.databaseId.projectId + \"/\" +\n                (\"databases/\" + this.databaseId.database);\n    };\n    WebChannelConnection.prototype.invoke = function (rpcName, request, token) {\n        var _this = this;\n        var url = this.makeUrl(rpcName);\n        return new Promise(function (resolve, reject) {\n            _this.pool.getObject(function (xhr) {\n                xhr.listenOnce(dist[\"EventType\"].COMPLETE, function () {\n                    try {\n                        switch (xhr.getLastErrorCode()) {\n                            case dist[\"ErrorCode\"].NO_ERROR:\n                                var json = xhr.getResponseJson();\n                                debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                                resolve(json);\n                                break;\n                            case dist[\"ErrorCode\"].TIMEOUT:\n                                log_error('RPC \"' + rpcName + '\" timed out, retrying.');\n                                reject(new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out'));\n                                break;\n                            case dist[\"ErrorCode\"].HTTP_ERROR:\n                                var status_1 = xhr.getStatus();\n                                log_error('RPC \"' + rpcName + '\" failed with status:', status_1, 'response text:', xhr.getResponseText());\n                                if (status_1 > 0) {\n                                    reject(new FirestoreError(mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));\n                                }\n                                else {\n                                    // If we received an HTTP_ERROR but there's no status code,\n                                    // it's most probably a connection issue, let's retry.\n                                    log_error(LOG_TAG, 'RPC \"' + rpcName + '\" failed, retrying.');\n                                    reject(new FirestoreError(Code.UNAVAILABLE, 'Connection failed.'));\n                                }\n                                break;\n                            default:\n                                fail('RPC \"' +\n                                    rpcName +\n                                    '\" failed with unanticipated ' +\n                                    'webchannel error ' +\n                                    xhr.getLastErrorCode() +\n                                    ': ' +\n                                    xhr.getLastError() +\n                                    ', giving up.');\n                        }\n                    }\n                    finally {\n                        debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n                        _this.pool.releaseObject(xhr);\n                    }\n                });\n                var requestString = JSON.stringify(request);\n                debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);\n                // Content-Type: text/plain will avoid preflight requests which might\n                // mess with CORS and redirects by proxies. If we add custom headers\n                // we will need to change this code to potentially use the\n                // $httpOverwrite parameter supported by ESF to avoid\n                // triggering preflight requests.\n                var headers = { 'Content-Type': 'text/plain' };\n                _this.modifyHeadersForRequest(headers, token);\n                xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n            });\n        });\n    };\n    WebChannelConnection.prototype.openStream = function (rpcName, token) {\n        var rpcService = WebChannelConnection.RPC_STREAM_SERVICE_MAPPING[rpcName];\n        var rpcUrlName = WebChannelConnection.RPC_STREAM_NAME_MAPPING[rpcName];\n        if (!rpcService || !rpcUrlName) {\n            fail('Unknown RPC name: ' + rpcName);\n        }\n        var urlParts = [\n            this.baseUrl,\n            '/',\n            rpcService,\n            '/',\n            rpcUrlName,\n            '/channel'\n        ];\n        var webchannelTransport = Object(dist[\"createWebChannelTransport\"])();\n        var request = {\n            // Background channel test avoids the initial two test calls and decreases\n            // initial cold start time.\n            // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n            // we should monitor closely for any reports.\n            backgroundChannelTest: true,\n            // Required for backend stickiness, routing behavior is based on this\n            // parameter.\n            httpSessionIdParam: 'gsessionid',\n            initMessageHeaders: {},\n            sendRawJson: true,\n            supportsCrossDomainXhr: true\n        };\n        this.modifyHeadersForRequest(request.initMessageHeaders, token);\n        var url = urlParts.join('');\n        debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);\n        // tslint:disable-next-line:no-any Because listen isn't defined on it.\n        var channel = webchannelTransport.createWebChannel(url, request);\n        // WebChannel supports sending the first message with the handshake - saving\n        // a network round trip. However, it will have to call send in the same\n        // JS event loop as open. In order to enforce this, we delay actually\n        // opening the WebChannel until send is called. Whether we have called\n        // open is tracked with this variable.\n        var opened = false;\n        // A flag to determine whether the stream was closed (by us or through an\n        // error/close event) to avoid delivering multiple close events or sending\n        // on a closed stream\n        var closed = false;\n        // tslint:disable-next-line:no-any\n        var streamBridge = new stream_bridge_StreamBridge({\n            sendFn: function (msg) {\n                if (!closed) {\n                    if (!opened) {\n                        debug(LOG_TAG, 'Opening WebChannel transport.');\n                        channel.open();\n                        opened = true;\n                    }\n                    debug(LOG_TAG, 'WebChannel sending:', msg);\n                    channel.send(msg);\n                }\n                else {\n                    debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n                }\n            },\n            closeFn: function () { return channel.close(); }\n        });\n        // Closure events are guarded and exceptions are swallowed, so catch any\n        // exception and rethrow using a setTimeout so they become visible again.\n        // Note that eventually this function could go away if we are confident\n        // enough the code is exception free.\n        var unguardedEventListen = function (type, fn) {\n            // TODO(dimond): closure typing seems broken because WebChannel does\n            // not implement goog.events.Listenable\n            channel.listen(type, function (param) {\n                try {\n                    fn(param);\n                }\n                catch (e) {\n                    setTimeout(function () {\n                        throw e;\n                    }, 0);\n                }\n            });\n        };\n        unguardedEventListen(dist[\"WebChannel\"].EventType.OPEN, function () {\n            if (!closed) {\n                debug(LOG_TAG, 'WebChannel transport opened.');\n            }\n        });\n        unguardedEventListen(dist[\"WebChannel\"].EventType.CLOSE, function () {\n            if (!closed) {\n                closed = true;\n                debug(LOG_TAG, 'WebChannel transport closed');\n                streamBridge.callOnClose();\n            }\n        });\n        unguardedEventListen(dist[\"WebChannel\"].EventType.ERROR, function (err) {\n            if (!closed) {\n                closed = true;\n                debug(LOG_TAG, 'WebChannel transport errored:', err);\n                streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE, 'The operation could not be completed'));\n            }\n        });\n        unguardedEventListen(dist[\"WebChannel\"].EventType.MESSAGE, function (msg) {\n            if (!closed) {\n                // WebChannel delivers message events as array. If batching\n                // is not enabled (it's off by default) each message will be\n                // delivered alone, resulting in a single element array.\n                var msgData = msg.data[0];\n                assert(!!msgData, 'Got a webchannel message without data.');\n                // TODO(b/35143891): There is a bug in One Platform that caused errors\n                // (and only errors) to be wrapped in an extra array. To be forward\n                // compatible with the bug we need to check either condition. The latter\n                // can be removed once the fix has been rolled out.\n                var error = msgData.error || (msgData[0] && msgData[0].error);\n                if (error) {\n                    debug(LOG_TAG, 'WebChannel received error:', error);\n                    // error.status will be a string like 'OK' or 'NOT_FOUND'.\n                    var status_2 = error.status;\n                    var code = mapCodeFromRpcStatus(status_2);\n                    var message = error.message;\n                    if (code === undefined) {\n                        code = Code.INTERNAL;\n                        message =\n                            'Unknown error status: ' +\n                                status_2 +\n                                ' with message ' +\n                                error.message;\n                    }\n                    // Mark closed so no further events are propagated\n                    closed = true;\n                    streamBridge.callOnClose(new FirestoreError(code, message));\n                    channel.close();\n                }\n                else {\n                    debug(LOG_TAG, 'WebChannel received:', msgData);\n                    streamBridge.callOnMessage(msgData);\n                }\n            }\n        });\n        setTimeout(function () {\n            // Technically we could/should wait for the WebChannel opened event,\n            // but because we want to send the first message with the WebChannel\n            // handshake we pretend the channel opened here (asynchronously), and\n            // then delay the actual open until the first message is sent.\n            streamBridge.callOnOpen();\n        }, 0);\n        return streamBridge;\n    };\n    // visible for testing\n    WebChannelConnection.prototype.makeUrl = function (rpcName) {\n        var url = [this.baseUrl, '/', RPC_URL_VERSION];\n        url.push('/projects/');\n        url.push(this.databaseId.projectId);\n        url.push('/databases/');\n        url.push(this.databaseId.database);\n        url.push('/documents');\n        url.push(':');\n        url.push(rpcName);\n        return url.join('');\n    };\n    /**\n     * Mapping from RPC name to service providing the RPC.\n     * For streaming RPCs only.\n     */\n    WebChannelConnection.RPC_STREAM_SERVICE_MAPPING = {\n        Write: 'google.firestore.v1beta1.Firestore',\n        Listen: 'google.firestore.v1beta1.Firestore'\n    };\n    /**\n     * Mapping from RPC name to actual RPC name in URLs.\n     * For streaming RPCs only.\n     */\n    WebChannelConnection.RPC_STREAM_NAME_MAPPING = {\n        Write: 'Write',\n        Listen: 'Listen'\n    };\n    return WebChannelConnection;\n}());\n\n\n//# sourceMappingURL=webchannel_connection.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform_browser/browser_platform.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar browser_platform_BrowserPlatform = /** @class */ (function () {\n    function BrowserPlatform() {\n        this.emptyByteString = '';\n        this.base64Available = typeof atob !== 'undefined';\n    }\n    BrowserPlatform.prototype.loadConnection = function (databaseInfo) {\n        return Promise.resolve(new webchannel_connection_WebChannelConnection(databaseInfo));\n    };\n    BrowserPlatform.prototype.newSerializer = function (databaseId) {\n        return new serializer_JsonProtoSerializer(databaseId, { useProto3Json: true });\n    };\n    BrowserPlatform.prototype.atob = function (encoded) {\n        return atob(encoded);\n    };\n    BrowserPlatform.prototype.btoa = function (raw) {\n        return btoa(raw);\n    };\n    return BrowserPlatform;\n}());\n\n\n//# sourceMappingURL=browser_platform.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform_browser/browser_init.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * This code needs to run before Firestore is used. This can be achieved in\n * several ways:\n *   1) Through the JSCompiler compiling this code and then (automatically)\n *      executing it before exporting the Firestore symbols.\n *   2) Through importing this module first in a Firestore main module\n */\nplatform_PlatformSupport.setPlatform(new browser_platform_BrowserPlatform());\n\n//# sourceMappingURL=browser_init.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/field_path.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\n/**\n * A FieldPath refers to a field in a document. The path may consist of a single\n * field name (referring to a top-level field in the document), or a list of\n * field names (referring to a nested field in the document).\n */\nvar field_path_FieldPath = /** @class */ (function () {\n    /**\n     * Creates a FieldPath from the provided field names. If more than one field\n     * name is provided, the path will point to a nested field in a document.\n     *\n     * @param fieldNames A list of field names.\n     */\n    function FieldPath() {\n        var fieldNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fieldNames[_i] = arguments[_i];\n        }\n        validateNamedArrayAtLeastNumberOfElements('FieldPath', fieldNames, 'fieldNames', 1);\n        for (var i = 0; i < fieldNames.length; ++i) {\n            validateArgType('FieldPath', 'string', i, fieldNames[i]);\n            if (fieldNames[i].length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field name at argument $(i + 1). \" +\n                    'Field names must not be empty.');\n            }\n        }\n        this._internalPath = new path_FieldPath(fieldNames);\n    }\n    FieldPath.documentId = function () {\n        return FieldPath._DOCUMENT_ID;\n    };\n    /**\n     * Internal Note: The backend doesn't technically support querying by\n     * document ID. Instead it queries by the entire document name (full path\n     * included), but in the cases we currently support documentId(), the net\n     * effect is the same.\n     */\n    FieldPath._DOCUMENT_ID = new FieldPath(path_FieldPath.keyField().canonicalString());\n    return FieldPath;\n}());\n\n/**\n * Matches any characters in a field path string that are reserved.\n */\nvar RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n/**\n * Parses a field path string into a FieldPath, treating dots as separators.\n */\nfunction fromDotSeparatedString(path) {\n    var found = path.search(RESERVED);\n    if (found >= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not contain \" +\n            \"'~', '*', '/', '[', or ']'\");\n    }\n    try {\n        return new (field_path_FieldPath.bind.apply(field_path_FieldPath, [void 0].concat(path.split('.'))))();\n    }\n    catch (e) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, \" +\n            \"begin with '.', end with '.', or contain '..'\");\n    }\n}\n\n//# sourceMappingURL=field_path.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/types.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Describes the online state of the Firestore client */\nvar OnlineState;\n(function (OnlineState) {\n    /**\n     * The Firestore client is in an unknown online state. This means the client\n     * is either not actively trying to establish a connection or it was\n     * previously in an unknown state and is trying to establish a connection.\n     */\n    OnlineState[OnlineState[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * The client is connected and the connections are healthy. This state is\n     * reached after a successful connection and there has been at least one\n     * succesful message received from the backends.\n     */\n    OnlineState[OnlineState[\"Healthy\"] = 1] = \"Healthy\";\n    /**\n     * The client has tried to establish a connection but has failed.\n     * This state is reached after either a connection attempt failed or a\n     * healthy stream was closed for unexpected reasons.\n     */\n    OnlineState[OnlineState[\"Failed\"] = 2] = \"Failed\";\n})(OnlineState = OnlineState || (OnlineState = {}));\n\n//# sourceMappingURL=types.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/view_snapshot.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar ChangeType;\n(function (ChangeType) {\n    ChangeType[ChangeType[\"Added\"] = 0] = \"Added\";\n    ChangeType[ChangeType[\"Removed\"] = 1] = \"Removed\";\n    ChangeType[ChangeType[\"Modified\"] = 2] = \"Modified\";\n    ChangeType[ChangeType[\"Metadata\"] = 3] = \"Metadata\";\n})(ChangeType = ChangeType || (ChangeType = {}));\nvar SyncState;\n(function (SyncState) {\n    SyncState[SyncState[\"Local\"] = 0] = \"Local\";\n    SyncState[SyncState[\"Synced\"] = 1] = \"Synced\";\n})(SyncState = SyncState || (SyncState = {}));\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nvar view_snapshot_DocumentChangeSet = /** @class */ (function () {\n    function DocumentChangeSet() {\n        this.changeMap = new sorted_map_SortedMap(document_key_DocumentKey.comparator);\n    }\n    DocumentChangeSet.prototype.track = function (change) {\n        var key = change.doc.key;\n        var oldChange = this.changeMap.get(key);\n        if (!oldChange) {\n            this.changeMap = this.changeMap.insert(key, change);\n            return;\n        }\n        // Merge the new change with the existing change.\n        if (change.type !== ChangeType.Added &&\n            oldChange.type === ChangeType.Metadata) {\n            this.changeMap = this.changeMap.insert(key, change);\n        }\n        else if (change.type === ChangeType.Metadata &&\n            oldChange.type !== ChangeType.Removed) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: oldChange.type,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Modified &&\n            oldChange.type === ChangeType.Modified) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Modified,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Modified &&\n            oldChange.type === ChangeType.Added) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Added,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Removed &&\n            oldChange.type === ChangeType.Added) {\n            this.changeMap = this.changeMap.remove(key);\n        }\n        else if (change.type === ChangeType.Removed &&\n            oldChange.type === ChangeType.Modified) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Removed,\n                doc: oldChange.doc\n            });\n        }\n        else if (change.type === ChangeType.Added &&\n            oldChange.type === ChangeType.Removed) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Modified,\n                doc: change.doc\n            });\n        }\n        else {\n            // This includes these cases, which don't make sense:\n            // Added->Added\n            // Removed->Removed\n            // Modified->Added\n            // Removed->Modified\n            // Metadata->Added\n            // Removed->Metadata\n            fail('unsupported combination of changes: ' +\n                JSON.stringify(change) +\n                ' after ' +\n                JSON.stringify(oldChange));\n        }\n    };\n    DocumentChangeSet.prototype.getChanges = function () {\n        var changes = [];\n        this.changeMap.inorderTraversal(function (key, change) {\n            changes.push(change);\n        });\n        return changes;\n    };\n    return DocumentChangeSet;\n}());\n\n\n//# sourceMappingURL=view_snapshot.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/document_set.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nvar document_set_DocumentSet = /** @class */ (function () {\n    /** The default ordering is by key if the comparator is omitted */\n    function DocumentSet(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = function (d1, d2) {\n                return comp(d1, d2) || document_key_DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        else {\n            this.comparator = function (d1, d2) {\n                return document_key_DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new sorted_map_SortedMap(this.comparator);\n    }\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    DocumentSet.emptySet = function (oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    };\n    DocumentSet.prototype.has = function (key) {\n        return this.keyedMap.get(key) != null;\n    };\n    DocumentSet.prototype.get = function (key) {\n        return this.keyedMap.get(key);\n    };\n    DocumentSet.prototype.first = function () {\n        return this.sortedSet.minKey();\n    };\n    DocumentSet.prototype.last = function () {\n        return this.sortedSet.maxKey();\n    };\n    DocumentSet.prototype.isEmpty = function () {\n        return this.sortedSet.isEmpty();\n    };\n    /**\n     * Returns previous document or null if it's a first doc.\n     *\n     * @param key A key that MUST be present in the DocumentSet.\n     */\n    DocumentSet.prototype.prevDoc = function (key) {\n        assert(this.has(key), 'Trying to get a previous document to non-existing key: ' + key);\n        var doc = this.keyedMap.get(key);\n        return this.sortedSet.getPredecessorKey(doc);\n    };\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    DocumentSet.prototype.indexOf = function (key) {\n        var doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    };\n    Object.defineProperty(DocumentSet.prototype, \"size\", {\n        get: function () {\n            return this.sortedSet.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Iterates documents in order defined by \"comparator\" */\n    DocumentSet.prototype.forEach = function (cb) {\n        this.sortedSet.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Inserts or updates a document with the same key */\n    DocumentSet.prototype.add = function (doc) {\n        // First remove the element if we have it.\n        var set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    };\n    /** Deletes a document with a given key */\n    DocumentSet.prototype.delete = function (key) {\n        var doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    };\n    DocumentSet.prototype.equals = function (other) {\n        if (!(other instanceof DocumentSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.sortedSet.getIterator();\n        var otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            var thisDoc = thisIt.getNext().key;\n            var otherDoc = otherIt.getNext().key;\n            if (!thisDoc.equals(otherDoc))\n                return false;\n        }\n        return true;\n    };\n    DocumentSet.prototype.toString = function () {\n        var docStrings = [];\n        this.forEach(function (doc) {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    };\n    DocumentSet.prototype.copy = function (keyedMap, sortedSet) {\n        var newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    };\n    return DocumentSet;\n}());\n\n\n//# sourceMappingURL=document_set.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/obj_map.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nvar obj_map_ObjectMap = /** @class */ (function () {\n    function ObjectMap(mapKeyFn) {\n        this.mapKeyFn = mapKeyFn;\n        /**\n         * The inner map for a key -> value pair. Due to the possibility of\n         * collisions we keep a list of entries that we do a linear search through\n         * to find an actual match. Note that collisions should be rare, so we still\n         * expect near constant time lookups in practice.\n         */\n        this.inner = {};\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    ObjectMap.prototype.get = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n            var _a = matches_1[_i], otherKey = _a[0], value = _a[1];\n            if (otherKey.equals(key)) {\n                return value;\n            }\n        }\n        return undefined;\n    };\n    ObjectMap.prototype.has = function (key) {\n        return this.get(key) !== undefined;\n    };\n    /** Put this key and value in the map. */\n    ObjectMap.prototype.set = function (key, value) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            return;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].equals(key)) {\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n    };\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    ObjectMap.prototype.delete = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].equals(key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    ObjectMap.prototype.forEach = function (fn) {\n        forEach(this.inner, function (_, entries) {\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                fn(k, v);\n            }\n        });\n    };\n    ObjectMap.prototype.isEmpty = function () {\n        return isEmpty(this.inner);\n    };\n    return ObjectMap;\n}());\n\n\n//# sourceMappingURL=obj_map.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/event_manager.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nvar QueryListenersInfo = /** @class */ (function () {\n    function QueryListenersInfo() {\n        this.listeners = [];\n    }\n    return QueryListenersInfo;\n}());\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\nvar event_manager_EventManager = /** @class */ (function () {\n    function EventManager(syncEngine) {\n        this.syncEngine = syncEngine;\n        this.queries = new obj_map_ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.onlineState = OnlineState.Unknown;\n        this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));\n    }\n    EventManager.prototype.listen = function (listener) {\n        var query = listener.query;\n        var firstListen = false;\n        var queryInfo = this.queries.get(query);\n        if (!queryInfo) {\n            firstListen = true;\n            queryInfo = new QueryListenersInfo();\n            this.queries.set(query, queryInfo);\n        }\n        queryInfo.listeners.push(listener);\n        listener.onOnlineStateChanged(this.onlineState);\n        if (queryInfo.viewSnap)\n            listener.onViewSnapshot(queryInfo.viewSnap);\n        if (firstListen) {\n            return this.syncEngine.listen(query).then(function (targetId) {\n                queryInfo.targetId = targetId;\n                return targetId;\n            });\n        }\n        else {\n            return Promise.resolve(queryInfo.targetId);\n        }\n    };\n    EventManager.prototype.unlisten = function (listener) {\n        var query = listener.query;\n        var lastListen = false;\n        var queryInfo = this.queries.get(query);\n        if (queryInfo) {\n            var i = queryInfo.listeners.indexOf(listener);\n            if (i >= 0) {\n                queryInfo.listeners.splice(i, 1);\n                lastListen = queryInfo.listeners.length === 0;\n            }\n        }\n        if (lastListen) {\n            this.queries.delete(query);\n            return this.syncEngine.unlisten(query);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    EventManager.prototype.onChange = function (viewSnaps) {\n        for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {\n            var viewSnap = viewSnaps_1[_i];\n            var query = viewSnap.query;\n            var queryInfo = this.queries.get(query);\n            if (queryInfo) {\n                for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {\n                    var listener = _b[_a];\n                    listener.onViewSnapshot(viewSnap);\n                }\n                queryInfo.viewSnap = viewSnap;\n            }\n        }\n    };\n    EventManager.prototype.onError = function (query, error) {\n        var queryInfo = this.queries.get(query);\n        if (queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.onError(error);\n            }\n        }\n        // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n        // after an error.\n        this.queries.delete(query);\n    };\n    EventManager.prototype.onOnlineStateChanged = function (onlineState) {\n        this.onlineState = onlineState;\n        this.queries.forEach(function (_, queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.onOnlineStateChanged(onlineState);\n            }\n        });\n    };\n    return EventManager;\n}());\n\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nvar event_manager_QueryListener = /** @class */ (function () {\n    function QueryListener(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.onlineState = OnlineState.Unknown;\n        this.options = options || {};\n    }\n    QueryListener.prototype.onViewSnapshot = function (snap) {\n        assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');\n        if (!this.options.includeDocumentMetadataChanges) {\n            // Remove the metadata only changes.\n            var docChanges = [];\n            for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {\n                var docChange = _a[_i];\n                if (docChange.type !== ChangeType.Metadata) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = {\n                query: snap.query,\n                docs: snap.docs,\n                oldDocs: snap.oldDocs,\n                docChanges: docChanges,\n                fromCache: snap.fromCache,\n                hasPendingWrites: snap.hasPendingWrites,\n                syncStateChanged: snap.syncStateChanged\n            };\n        }\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n        }\n        this.snap = snap;\n    };\n    QueryListener.prototype.onError = function (error) {\n        this.queryObserver.error(error);\n    };\n    QueryListener.prototype.onOnlineStateChanged = function (onlineState) {\n        this.onlineState = onlineState;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n        }\n    };\n    QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) {\n        assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event');\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Failed\n        // or Online if we wait long enough).\n        var maybeOnline = onlineState !== OnlineState.Failed;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');\n            return false;\n        }\n        // Raise data from cache if we have any documents or we are offline\n        return !snap.docs.isEmpty() || onlineState === OnlineState.Failed;\n    };\n    QueryListener.prototype.shouldRaiseEvent = function (snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeQueryMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    };\n    QueryListener.prototype.raiseInitialEvent = function (snap) {\n        assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');\n        snap = {\n            query: snap.query,\n            docs: snap.docs,\n            oldDocs: document_set_DocumentSet.emptySet(snap.docs),\n            docChanges: QueryListener.getInitialViewChanges(snap),\n            fromCache: snap.fromCache,\n            hasPendingWrites: snap.hasPendingWrites,\n            syncStateChanged: true\n        };\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    };\n    /** Returns changes as if all documents in the snap were added. */\n    QueryListener.getInitialViewChanges = function (snap) {\n        var result = [];\n        snap.docs.forEach(function (doc) {\n            result.push({ type: ChangeType.Added, doc: doc });\n        });\n        return result;\n    };\n    return QueryListener;\n}());\n\n\n//# sourceMappingURL=event_manager.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/persistence_promise.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nvar persistence_promise_PersistencePromise = /** @class */ (function () {\n    function PersistencePromise(callback) {\n        var _this = this;\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        this.nextCallback = null;\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = null;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(function (value) {\n            _this.isDone = true;\n            _this.result = value;\n            if (_this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                _this.nextCallback(value);\n            }\n        }, function (error) {\n            _this.isDone = true;\n            _this.error = error;\n            if (_this.catchCallback) {\n                _this.catchCallback(error);\n            }\n        });\n    }\n    PersistencePromise.prototype.catch = function (fn) {\n        return this.next(undefined, fn);\n    };\n    PersistencePromise.prototype.next = function (nextFn, catchFn) {\n        var _this = this;\n        if (this.callbackAttached) {\n            fail('Called next() or catch() twice for PersistencePromise');\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise(function (resolve, reject) {\n                _this.nextCallback = function (value) {\n                    _this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                _this.catchCallback = function (error) {\n                    _this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    };\n    PersistencePromise.prototype.toPromise = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.next(resolve, reject);\n        });\n    };\n    PersistencePromise.prototype.wrapUserFunction = function (fn) {\n        try {\n            var result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    };\n    PersistencePromise.prototype.wrapSuccess = function (nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(function () { return nextFn(value); });\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T but we\n            // can't express that in the type system.\n            return PersistencePromise.resolve(value);\n        }\n    };\n    PersistencePromise.prototype.wrapFailure = function (catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(function () { return catchFn(error); });\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    };\n    PersistencePromise.resolve = function (result) {\n        return new PersistencePromise(function (resolve, reject) {\n            resolve(result);\n        });\n    };\n    PersistencePromise.reject = function (error) {\n        return new PersistencePromise(function (resolve, reject) {\n            reject(error);\n        });\n    };\n    PersistencePromise.waitFor = function (all) {\n        return all.reduce(function (promise, nextPromise, idx) {\n            return promise.next(function () {\n                return nextPromise;\n            });\n        }, PersistencePromise.resolve());\n    };\n    PersistencePromise.map = function (all) {\n        var results = [];\n        var first = true;\n        // initial is ignored, so we can cheat on the type.\n        var initial = PersistencePromise.resolve(null);\n        return all\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (!first) {\n                    results.push(result);\n                }\n                first = false;\n                return nextPromise;\n            });\n        }, initial)\n            .next(function (result) {\n            results.push(result);\n            return results;\n        });\n    };\n    return PersistencePromise;\n}());\n\n\n//# sourceMappingURL=persistence_promise.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/eager_garbage_collector.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A garbage collector implementation that eagerly collects documents as soon as\n * they're no longer referenced in any of its registered GarbageSources.\n *\n * This implementation keeps track of a set of keys that are potentially garbage\n * without keeping an exact reference count. During collectGarbage, the\n * collector verifies that all potential garbage keys actually have no\n * references by consulting its list of garbage sources.\n */\nvar eager_garbage_collector_EagerGarbageCollector = /** @class */ (function () {\n    function EagerGarbageCollector() {\n        this.isEager = true;\n        /**\n         * The garbage collectible sources to double-check during garbage collection.\n         */\n        this.sources = [];\n        /**\n         * A set of potentially garbage keys.\n         * PORTING NOTE: This would be a mutable set if Javascript had one.\n         */\n        this.potentialGarbage = documentKeySet();\n    }\n    EagerGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        this.sources.push(garbageSource);\n        garbageSource.setGarbageCollector(this);\n    };\n    EagerGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        this.sources.splice(this.sources.indexOf(garbageSource), 1);\n        garbageSource.setGarbageCollector(null);\n    };\n    EagerGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        this.potentialGarbage = this.potentialGarbage.add(key);\n    };\n    EagerGarbageCollector.prototype.collectGarbage = function (txn) {\n        var _this = this;\n        var promises = [];\n        var garbageKeys = documentKeySet();\n        this.potentialGarbage.forEach(function (key) {\n            var hasRefsPromise = _this.documentHasAnyReferences(txn, key);\n            promises.push(hasRefsPromise.next(function (hasRefs) {\n                // If there are no references, get the key.\n                if (!hasRefs) {\n                    garbageKeys = garbageKeys.add(key);\n                }\n                return persistence_promise_PersistencePromise.resolve();\n            }));\n        });\n        // Clear locally retained potential keys and returned confirmed garbage.\n        this.potentialGarbage = documentKeySet();\n        return persistence_promise_PersistencePromise.waitFor(promises).next(function () { return garbageKeys; });\n    };\n    EagerGarbageCollector.prototype.documentHasAnyReferences = function (txn, key) {\n        var initial = persistence_promise_PersistencePromise.resolve(false);\n        return this.sources\n            .map(function (source) { return function () { return source.containsKey(txn, key); }; })\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (result) {\n                    return persistence_promise_PersistencePromise.resolve(true);\n                }\n                else {\n                    return nextPromise();\n                }\n            });\n        }, initial);\n    };\n    return EagerGarbageCollector;\n}());\n\n\n//# sourceMappingURL=eager_garbage_collector.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/local_view_changes.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nvar local_view_changes_LocalViewChanges = /** @class */ (function () {\n    function LocalViewChanges(query, addedKeys, removedKeys) {\n        this.query = query;\n        this.addedKeys = addedKeys;\n        this.removedKeys = removedKeys;\n    }\n    LocalViewChanges.fromSnapshot = function (viewSnapshot) {\n        var addedKeys = documentKeySet();\n        var removedKeys = documentKeySet();\n        for (var _i = 0, _a = viewSnapshot.docChanges; _i < _a.length; _i++) {\n            var docChange = _a[_i];\n            switch (docChange.type) {\n                case ChangeType.Added:\n                    addedKeys = addedKeys.add(docChange.doc.key);\n                    break;\n                case ChangeType.Removed:\n                    removedKeys = removedKeys.add(docChange.doc.key);\n                    break;\n                default:\n            }\n        }\n        return new LocalViewChanges(viewSnapshot.query, addedKeys, removedKeys);\n    };\n    return LocalViewChanges;\n}());\n\n\n//# sourceMappingURL=local_view_changes.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/reference_set.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nvar reference_set_ReferenceSet = /** @class */ (function () {\n    function ReferenceSet() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new sorted_set_SortedSet(reference_set_DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new sorted_set_SortedSet(reference_set_DocReference.compareByTargetId);\n        /** Keeps track of keys that have references */\n        this.garbageCollector = null;\n    }\n    /** Returns true if the reference set contains no references. */\n    ReferenceSet.prototype.isEmpty = function () {\n        return this.refsByKey.isEmpty();\n    };\n    /** Adds a reference to the given document key for the given ID. */\n    ReferenceSet.prototype.addReference = function (key, id) {\n        var ref = new reference_set_DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    };\n    /** Add references to the given document keys for the given ID. */\n    ReferenceSet.prototype.addReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.addReference(key, id); });\n    };\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    ReferenceSet.prototype.removeReference = function (key, id) {\n        this.removeRef(new reference_set_DocReference(key, id));\n    };\n    ReferenceSet.prototype.removeReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.removeReference(key, id); });\n    };\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    ReferenceSet.prototype.removeReferencesForId = function (id) {\n        var _this = this;\n        var emptyKey = document_key_DocumentKey.EMPTY;\n        var startRef = new reference_set_DocReference(emptyKey, id);\n        var endRef = new reference_set_DocReference(emptyKey, id + 1);\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            _this.removeRef(ref);\n        });\n    };\n    ReferenceSet.prototype.removeAllReferences = function () {\n        var _this = this;\n        this.refsByKey.forEach(function (ref) { return _this.removeRef(ref); });\n    };\n    ReferenceSet.prototype.removeRef = function (ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n        if (this.garbageCollector !== null) {\n            this.garbageCollector.addPotentialGarbageKey(ref.key);\n        }\n    };\n    ReferenceSet.prototype.referencesForId = function (id) {\n        var emptyKey = document_key_DocumentKey.EMPTY;\n        var startRef = new reference_set_DocReference(emptyKey, id);\n        var endRef = new reference_set_DocReference(emptyKey, id + 1);\n        var keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    };\n    ReferenceSet.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    ReferenceSet.prototype.containsKey = function (txn, key) {\n        var ref = new reference_set_DocReference(key, 0);\n        var firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return persistence_promise_PersistencePromise.resolve(firstRef !== null && key.equals(firstRef.key));\n    };\n    return ReferenceSet;\n}());\n\nvar reference_set_DocReference = /** @class */ (function () {\n    function DocReference(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    DocReference.compareByKey = function (left, right) {\n        return (document_key_DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    };\n    /** Compare by ID then by key */\n    DocReference.compareByTargetId = function (left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            document_key_DocumentKey.comparator(left.key, right.key));\n    };\n    return DocReference;\n}());\n\n\n//# sourceMappingURL=reference_set.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/target_id_generator.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar RESERVED_BITS = 1;\nvar GeneratorIds;\n(function (GeneratorIds) {\n    GeneratorIds[GeneratorIds[\"LocalStore\"] = 0] = \"LocalStore\";\n    GeneratorIds[GeneratorIds[\"SyncEngine\"] = 1] = \"SyncEngine\";\n})(GeneratorIds || (GeneratorIds = {}));\n/**\n * TargetIdGenerator generates monotonically increasing integer IDs. There are\n * separate generators for different scopes. While these generators will operate\n * independently of each other, they are scoped, such that no two generators\n * will ever produce the same ID. This is useful, because sometimes the backend\n * may group IDs from separate parts of the client into the same ID space.\n */\nvar TargetIdGenerator = /** @class */ (function () {\n    function TargetIdGenerator(generatorId, initAfter) {\n        if (initAfter === void 0) { initAfter = 0; }\n        this.generatorId = generatorId;\n        // Replace the generator part of initAfter with this generator's ID.\n        var afterWithoutGenerator = (initAfter >> RESERVED_BITS) << RESERVED_BITS;\n        var afterGenerator = initAfter - afterWithoutGenerator;\n        if (afterGenerator >= generatorId) {\n            // For example, if:\n            //   this.generatorId = 0b0000\n            //   after = 0b1011\n            //   afterGenerator = 0b0001\n            // Then:\n            //   previous = 0b1010\n            //   next = 0b1100\n            this.previousId = afterWithoutGenerator | this.generatorId;\n        }\n        else {\n            // For example, if:\n            //   this.generatorId = 0b0001\n            //   after = 0b1010\n            //   afterGenerator = 0b0000\n            // Then:\n            //   previous = 0b1001\n            //   next = 0b1011\n            this.previousId =\n                (afterWithoutGenerator | this.generatorId) - (1 << RESERVED_BITS);\n        }\n    }\n    TargetIdGenerator.prototype.next = function () {\n        this.previousId += 1 << RESERVED_BITS;\n        return this.previousId;\n    };\n    TargetIdGenerator.forLocalStore = function (initAfter) {\n        if (initAfter === void 0) { initAfter = 0; }\n        return new TargetIdGenerator(GeneratorIds.LocalStore, initAfter);\n    };\n    TargetIdGenerator.forSyncEngine = function () {\n        return new TargetIdGenerator(GeneratorIds.SyncEngine);\n    };\n    return TargetIdGenerator;\n}());\n\n\n//# sourceMappingURL=target_id_generator.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/view.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\nvar AddedLimboDocument = /** @class */ (function () {\n    function AddedLimboDocument(key) {\n        this.key = key;\n    }\n    return AddedLimboDocument;\n}());\n\nvar RemovedLimboDocument = /** @class */ (function () {\n    function RemovedLimboDocument(key) {\n        this.key = key;\n    }\n    return RemovedLimboDocument;\n}());\n\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nvar view_View = /** @class */ (function () {\n    function View(query, \n        /** Documents included in the remote target */\n        syncedDocuments) {\n        this.query = query;\n        this.syncedDocuments = syncedDocuments;\n        this.syncState = null;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.documentSet = new document_set_DocumentSet(query.docComparator.bind(query));\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges The doc changes to apply to this view.\n     * @param previousChanges If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @return a new set of docs, changes, and refill flag.\n     */\n    View.prototype.computeDocChanges = function (docChanges, previousChanges) {\n        var _this = this;\n        var changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new view_snapshot_DocumentChangeSet();\n        var oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        var newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        var newDocumentSet = oldDocumentSet;\n        var needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        docChanges.inorderTraversal(function (key, newMaybeDoc) {\n            var oldDoc = oldDocumentSet.get(key);\n            var newDoc = newMaybeDoc instanceof document_Document ? newMaybeDoc : null;\n            if (newDoc) {\n                assert(key.equals(newDoc.key), 'Mismatching keys found in document changes: ' +\n                    key +\n                    ' != ' +\n                    newDoc.key);\n                newDoc = _this.query.matches(newDoc) ? newDoc : null;\n            }\n            if (newDoc) {\n                newDocumentSet = newDocumentSet.add(newDoc);\n                if (newDoc.hasLocalMutations) {\n                    newMutatedKeys = newMutatedKeys.add(key);\n                }\n                else {\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n            else {\n                newDocumentSet = newDocumentSet.delete(key);\n                newMutatedKeys = newMutatedKeys.delete(key);\n            }\n            // Calculate change\n            if (oldDoc && newDoc) {\n                var docsEqual = oldDoc.data.equals(newDoc.data);\n                if (!docsEqual ||\n                    oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {\n                    // only report a change if document actually changed\n                    if (docsEqual) {\n                        changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n                    }\n                    else {\n                        changeSet.track({ type: ChangeType.Modified, doc: newDoc });\n                    }\n                    if (lastDocInLimit &&\n                        _this.query.docComparator(newDoc, lastDocInLimit) > 0) {\n                        // This doc moved from inside the limit to after the limit.\n                        // That means there may be some doc in the local cache that's\n                        // actually less than this one.\n                        needsRefill = true;\n                    }\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: ChangeType.Added, doc: newDoc });\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n                if (lastDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n        });\n        if (this.query.hasLimit()) {\n            // TODO(klimt): Make DocumentSet size be constant time.\n            while (newDocumentSet.size > this.query.limit) {\n                var oldDoc = newDocumentSet.last();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n            }\n        }\n        assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');\n        return {\n            documentSet: newDocumentSet,\n            changeSet: changeSet,\n            needsRefill: needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    };\n    /**\n     * Updates the view with the given ViewDocumentChanges and updates limbo docs\n     * and sync state from the given (optional) target change.\n     * @param docChanges The set of changes to make to the view's docs.\n     * @param targetChange A target change to apply for computing limbo docs and\n     *        sync state.\n     * @return A new ViewChange with the given docs, changes, and sync state.\n     */\n    View.prototype.applyChanges = function (docChanges, targetChange) {\n        var _this = this;\n        assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n        var oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        var changes = docChanges.changeSet.getChanges();\n        changes.sort(function (c1, c2) {\n            return (compareChangeType(c1.type, c2.type) ||\n                _this.query.docComparator(c1.doc, c2.doc));\n        });\n        var limboChanges = this.applyTargetChange(targetChange);\n        var synced = this.limboDocuments.size === 0 && this.current;\n        var newSyncState = synced ? SyncState.Synced : SyncState.Local;\n        var syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges: limboChanges };\n        }\n        else {\n            return {\n                snapshot: {\n                    query: this.query,\n                    docs: docChanges.documentSet,\n                    oldDocs: oldDocs,\n                    docChanges: changes,\n                    fromCache: newSyncState === SyncState.Local,\n                    syncStateChanged: syncStateChanged,\n                    hasPendingWrites: !docChanges.mutatedKeys.isEmpty()\n                },\n                limboChanges: limboChanges\n            };\n        }\n    };\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    View.prototype.shouldBeInLimbo = function (key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this.syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    };\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    View.prototype.applyTargetChange = function (targetChange) {\n        var _this = this;\n        if (targetChange) {\n            var targetMapping = targetChange.mapping;\n            if (targetMapping instanceof ResetMapping) {\n                this.syncedDocuments = targetMapping.documents;\n            }\n            else if (targetMapping instanceof UpdateMapping) {\n                this.syncedDocuments = targetMapping.applyToKeySet(this.syncedDocuments);\n            }\n            switch (targetChange.currentStatusUpdate) {\n                case CurrentStatusUpdate.MarkCurrent:\n                    this.current = true;\n                    break;\n                case CurrentStatusUpdate.MarkNotCurrent:\n                    this.current = false;\n                    break;\n                case CurrentStatusUpdate.None:\n                    break;\n                default:\n                    fail('Unknown current status update: ' + targetChange.currentStatusUpdate);\n            }\n        }\n        // Recompute the set of limbo docs.\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        var oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        if (this.current) {\n            this.documentSet.forEach(function (doc) {\n                if (_this.shouldBeInLimbo(doc.key)) {\n                    _this.limboDocuments = _this.limboDocuments.add(doc.key);\n                }\n            });\n        }\n        // Diff the new limbo docs with the old limbo docs.\n        var changes = [];\n        oldLimboDocuments.forEach(function (key) {\n            if (!_this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(function (key) {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    };\n    return View;\n}());\n\nfunction compareChangeType(c1, c2) {\n    var order = function (change) {\n        switch (change) {\n            case ChangeType.Added:\n                return 1;\n            case ChangeType.Modified:\n                return 2;\n            case ChangeType.Metadata:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case ChangeType.Removed:\n                return 0;\n            default:\n                return fail('Unknown ChangeType: ' + change);\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n//# sourceMappingURL=view.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/sync_engine.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar sync_engine_LOG_TAG = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nvar QueryView = /** @class */ (function () {\n    function QueryView(\n        /**\n         * The query itself.\n         */\n        query, \n        /**\n         * The target number created by the client that is used in the watch\n         * stream to identify this query.\n         */\n        targetId, \n        /**\n         * An identifier from the datastore backend that indicates the last state\n         * of the results that was received. This can be used to indicate where\n         * to continue receiving new doc changes for the query.\n         */\n        resumeToken, \n        /**\n         * The view is responsible for computing the final merged truth of what\n         * docs are in the query. It gets notified of local and remote changes,\n         * and applies the query filters and limits to determine the most correct\n         * possible results.\n         */\n        view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.resumeToken = resumeToken;\n        this.view = view;\n    }\n    return QueryView;\n}());\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngine’s methods should only ever be called by methods running in the\n * global async queue.\n */\nvar sync_engine_SyncEngine = /** @class */ (function () {\n    function SyncEngine(localStore, remoteStore, currentUser) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.currentUser = currentUser;\n        this.viewHandler = null;\n        this.errorHandler = null;\n        this.queryViewsByQuery = new obj_map_ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.queryViewsByTarget = {};\n        this.limboTargetsByKey = new sorted_map_SortedMap(document_key_DocumentKey.comparator);\n        this.limboKeysByTarget = {};\n        this.limboDocumentRefs = new reference_set_ReferenceSet();\n        this.limboCollector = new eager_garbage_collector_EagerGarbageCollector();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        this.targetIdGenerator = TargetIdGenerator.forSyncEngine();\n    }\n    /** Subscribes view and error handler. Can be called only once. */\n    SyncEngine.prototype.subscribe = function (viewHandler, errorHandler) {\n        assert(viewHandler !== null && errorHandler !== null, 'View and error handlers cannot be null');\n        assert(this.viewHandler === null && this.errorHandler === null, 'SyncEngine already has a subscriber.');\n        this.viewHandler = viewHandler;\n        this.errorHandler = errorHandler;\n        this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n    };\n    /**\n     * Initiates the new listen, resolves promise when listen enqueued to the\n     * server. All the subsequent view snapshots or errors are sent to the\n     * subscribed handlers. Returns the targetId of the query.\n     */\n    SyncEngine.prototype.listen = function (query) {\n        var _this = this;\n        this.assertSubscribed('listen()');\n        assert(!this.queryViewsByQuery.has(query), 'We already listen to the query: ' + query);\n        return this.localStore.allocateQuery(query).then(function (queryData) {\n            return _this.localStore\n                .executeQuery(query)\n                .then(function (docs) {\n                return _this.localStore\n                    .remoteDocumentKeys(queryData.targetId)\n                    .then(function (remoteKeys) {\n                    var view = new view_View(query, remoteKeys);\n                    var viewDocChanges = view.computeDocChanges(docs);\n                    var viewChange = view.applyChanges(viewDocChanges);\n                    assert(viewChange.limboChanges.length === 0, 'View returned limbo docs before target ack from the server.');\n                    assert(!!viewChange.snapshot, 'applyChanges for new view should always return a snapshot');\n                    var data = new QueryView(query, queryData.targetId, queryData.resumeToken, view);\n                    _this.queryViewsByQuery.set(query, data);\n                    _this.queryViewsByTarget[queryData.targetId] = data;\n                    _this.viewHandler([viewChange.snapshot]);\n                    _this.remoteStore.listen(queryData);\n                });\n            })\n                .then(function () {\n                return queryData.targetId;\n            });\n        });\n    };\n    /** Stops listening to the query. */\n    SyncEngine.prototype.unlisten = function (query) {\n        var _this = this;\n        this.assertSubscribed('unlisten()');\n        var queryView = this.queryViewsByQuery.get(query);\n        assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n        return this.localStore.releaseQuery(query).then(function () {\n            _this.remoteStore.unlisten(queryView.targetId);\n            return _this.removeAndCleanupQuery(queryView).then(function () {\n                return _this.localStore.collectGarbage();\n            });\n        });\n    };\n    /**\n     * Initiates the write of local mutation batch which involves adding the\n     * writes to the mutation queue, notifying the remote store about new\n     * mutations and raising events for any changes this write caused.\n     *\n     * The promise returned by this call is resolved when the above steps\n     * have completed, *not* when the write was acked by the backend. The\n     * userCallback is resolved once the write was acked/rejected by the\n     * backend (or failed locally for any other reason).\n     */\n    SyncEngine.prototype.write = function (batch, userCallback) {\n        var _this = this;\n        this.assertSubscribed('write()');\n        return this.localStore\n            .localWrite(batch)\n            .then(function (result) {\n            _this.addMutationCallback(result.batchId, userCallback);\n            return _this.emitNewSnapsAndNotifyLocalStore(result.changes);\n        })\n            .then(function () {\n            return _this.remoteStore.fillWritePipeline();\n        });\n    };\n    // TODO(klimt): Wrap the given error in a standard Firestore error object.\n    SyncEngine.prototype.wrapUpdateFunctionError = function (error) {\n        return error;\n    };\n    /**\n     * Takes an updateFunction in which a set of reads and writes can be performed\n     * atomically. In the updateFunction, the client can read and write values\n     * using the supplied transaction object. After the updateFunction, all\n     * changes will be committed. If some other client has changed any of the data\n     * referenced, then the updateFunction will be called again. If the\n     * updateFunction still fails after the given number of retries, then the\n     * transaction will be rejection.\n     *\n     * The transaction object passed to the updateFunction contains methods for\n     * accessing documents and collections. Unlike other datastore access, data\n     * accessed with the transaction will not reflect local changes that have not\n     * been committed. For this reason, it is required that all reads are\n     * performed before any writes. Transactions must be performed while online.\n     *\n     * The promise returned is resolved when the transaction is fully committed.\n     */\n    SyncEngine.prototype.runTransaction = function (updateFunction, retries) {\n        var _this = this;\n        if (retries === void 0) { retries = 5; }\n        assert(retries >= 0, 'Got negative number of retries for transaction.');\n        var transaction = this.remoteStore.createTransaction();\n        var wrappedUpdateFunction = function () {\n            try {\n                var userPromise = updateFunction(transaction);\n                if (isNullOrUndefined(userPromise) ||\n                    !userPromise.catch ||\n                    !userPromise.then) {\n                    return Promise.reject(Error('Transaction callback must return a Promise'));\n                }\n                return userPromise.catch(function (e) {\n                    return Promise.reject(_this.wrapUpdateFunctionError(e));\n                });\n            }\n            catch (e) {\n                return Promise.reject(_this.wrapUpdateFunctionError(e));\n            }\n        };\n        return wrappedUpdateFunction().then(function (result) {\n            return transaction\n                .commit()\n                .then(function () {\n                return result;\n            })\n                .catch(function (error) {\n                if (retries === 0) {\n                    return Promise.reject(error);\n                }\n                // TODO(klimt): Put in a retry delay?\n                return _this.runTransaction(updateFunction, retries - 1);\n            });\n        });\n    };\n    SyncEngine.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        this.assertSubscribed('applyRemoteEvent()');\n        // Make sure limbo documents are deleted if there were no results\n        forEachNumber(remoteEvent.targetChanges, function (targetId, targetChange) {\n            var limboKey = _this.limboKeysByTarget[targetId];\n            if (limboKey &&\n                targetChange.currentStatusUpdate ===\n                    CurrentStatusUpdate.MarkCurrent &&\n                !remoteEvent.documentUpdates.get(limboKey)) {\n                // When listening to a query the server responds with a snapshot\n                // containing documents matching the query and a current marker\n                // telling us we're now in sync. It's possible for these to arrive\n                // as separate remote events or as a single remote event.\n                // For a document query, there will be no documents sent in the\n                // response if the document doesn't exist.\n                //\n                // If the snapshot arrives separately from the current marker,\n                // we handle it normally and updateTrackedLimbos will resolve the\n                // limbo status of the document, removing it from limboDocumentRefs.\n                // This works because clients only initiate limbo resolution when\n                // a target is current and because all current targets are\n                // always at a consistent snapshot.\n                //\n                // However, if the document doesn't exist and the current marker\n                // arrives, the document is not present in the snapshot and our\n                // normal view handling would consider the document to remain in\n                // limbo indefinitely because there are no updates to the document.\n                // To avoid this, we specially handle this just this case here:\n                // synthesizing a delete.\n                //\n                // TODO(dimond): Ideally we would have an explicit lookup query\n                // instead resulting in an explicit delete message and we could\n                // remove this special logic.\n                remoteEvent.addDocumentUpdate(new document_NoDocument(limboKey, remoteEvent.snapshotVersion));\n            }\n        });\n        return this.localStore.applyRemoteEvent(remoteEvent).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n        });\n    };\n    SyncEngine.prototype.rejectListen = function (targetId, err) {\n        var _this = this;\n        this.assertSubscribed('rejectListens()');\n        var limboKey = this.limboKeysByTarget[targetId];\n        if (limboKey) {\n            // Since this query failed, we won't want to manually unlisten to it.\n            // So go ahead and remove it from bookkeeping.\n            this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n            delete this.limboKeysByTarget[targetId];\n            // TODO(klimt): We really only should do the following on permission\n            // denied errors, but we don't have the cause code here.\n            // It's a limbo doc. Create a synthetic event saying it was deleted.\n            // This is kind of a hack. Ideally, we would have a method in the local\n            // store to purge a document. However, it would be tricky to keep all of\n            // the local store's invariants with another method.\n            var docMap = new sorted_map_SortedMap(document_key_DocumentKey.comparator);\n            docMap = docMap.insert(limboKey, new document_NoDocument(limboKey, snapshot_version_SnapshotVersion.forDeletedDoc()));\n            var event_1 = new remote_event_RemoteEvent(snapshot_version_SnapshotVersion.MIN, {}, docMap);\n            return this.applyRemoteEvent(event_1);\n        }\n        else {\n            var queryView_1 = this.queryViewsByTarget[targetId];\n            assert(!!queryView_1, 'Unknown targetId: ' + targetId);\n            return this.localStore.releaseQuery(queryView_1.query).then(function () {\n                return _this.removeAndCleanupQuery(queryView_1).then(function () {\n                    _this.errorHandler(queryView_1.query, err);\n                });\n            });\n        }\n    };\n    SyncEngine.prototype.applySuccessfulWrite = function (mutationBatchResult) {\n        var _this = this;\n        this.assertSubscribed('applySuccessfulWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        this.processUserCallback(mutationBatchResult.batch.batchId, \n        /*error=*/ null);\n        return this.localStore\n            .acknowledgeBatch(mutationBatchResult)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.rejectFailedWrite = function (batchId, error) {\n        var _this = this;\n        this.assertSubscribed('rejectFailedWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        this.processUserCallback(batchId, error);\n        return this.localStore.rejectBatch(batchId).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.addMutationCallback = function (batchId, callback) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        if (!newCallbacks) {\n            newCallbacks = new sorted_map_SortedMap(primitiveComparator);\n        }\n        newCallbacks = newCallbacks.insert(batchId, callback);\n        this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    };\n    /**\n     * Resolves or rejects the user callback for the given batch and then discards\n     * it.\n     */\n    SyncEngine.prototype.processUserCallback = function (batchId, error) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        // NOTE: Mutations restored from persistence won't have callbacks, so it's\n        // okay for there to be no callback for this ID.\n        if (newCallbacks) {\n            var callback = newCallbacks.get(batchId);\n            if (callback) {\n                assert(batchId === newCallbacks.minKey(), 'Mutation callbacks processed out-of-order?');\n                if (error) {\n                    callback.reject(error);\n                }\n                else {\n                    callback.resolve();\n                }\n                newCallbacks = newCallbacks.remove(batchId);\n            }\n            this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n        }\n    };\n    SyncEngine.prototype.removeAndCleanupQuery = function (queryView) {\n        this.queryViewsByQuery.delete(queryView.query);\n        delete this.queryViewsByTarget[queryView.targetId];\n        this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.updateTrackedLimbos = function (targetId, limboChanges) {\n        for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {\n            var limboChange = limboChanges_1[_i];\n            if (limboChange instanceof AddedLimboDocument) {\n                this.limboDocumentRefs.addReference(limboChange.key, targetId);\n                this.trackLimboChange(limboChange);\n            }\n            else if (limboChange instanceof RemovedLimboDocument) {\n                debug(sync_engine_LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n                this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            }\n            else {\n                fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n            }\n        }\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.trackLimboChange = function (limboChange) {\n        var key = limboChange.key;\n        if (!this.limboTargetsByKey.get(key)) {\n            debug(sync_engine_LOG_TAG, 'New document in limbo: ' + key);\n            var limboTargetId = this.targetIdGenerator.next();\n            var query = query_Query.atPath(key.path);\n            this.limboKeysByTarget[limboTargetId] = key;\n            this.remoteStore.listen(new query_data_QueryData(query, limboTargetId, QueryPurpose.Listen));\n            this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);\n        }\n    };\n    SyncEngine.prototype.gcLimboDocuments = function () {\n        var _this = this;\n        // HACK: We can use a null transaction here, because we know that the\n        // reference set is entirely within memory and doesn't need a store engine.\n        return this.limboCollector\n            .collectGarbage(null)\n            .next(function (keys) {\n            keys.forEach(function (key) {\n                var limboTargetId = _this.limboTargetsByKey.get(key);\n                if (limboTargetId === null) {\n                    // This target already got removed, because the query failed.\n                    return;\n                }\n                _this.remoteStore.unlisten(limboTargetId);\n                _this.limboTargetsByKey = _this.limboTargetsByKey.remove(key);\n                delete _this.limboKeysByTarget[limboTargetId];\n            });\n        })\n            .toPromise();\n    };\n    // Visible for testing\n    SyncEngine.prototype.currentLimboDocs = function () {\n        return this.limboTargetsByKey;\n    };\n    SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function (changes, remoteEvent) {\n        var _this = this;\n        var newSnaps = [];\n        var docChangesInAllViews = [];\n        var queriesProcessed = [];\n        this.queryViewsByQuery.forEach(function (_, queryView) {\n            queriesProcessed.push(Promise.resolve()\n                .then(function () {\n                var viewDocChanges = queryView.view.computeDocChanges(changes);\n                if (!viewDocChanges.needsRefill) {\n                    return viewDocChanges;\n                }\n                // The query has a limit and some docs were removed, so we need\n                // to re-run the query against the local store to make sure we\n                // didn't lose any good docs that had been past the limit.\n                return _this.localStore.executeQuery(queryView.query).then(function (docs) {\n                    return queryView.view.computeDocChanges(docs, viewDocChanges);\n                });\n            })\n                .then(function (viewDocChanges) {\n                var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n                var viewChange = queryView.view.applyChanges(viewDocChanges, targetChange);\n                return _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges).then(function () {\n                    if (viewChange.snapshot) {\n                        newSnaps.push(viewChange.snapshot);\n                        var docChanges = local_view_changes_LocalViewChanges.fromSnapshot(viewChange.snapshot);\n                        docChangesInAllViews.push(docChanges);\n                    }\n                });\n            }));\n        });\n        return Promise.all(queriesProcessed)\n            .then(function () {\n            _this.viewHandler(newSnaps);\n            return _this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n        })\n            .then(function () {\n            return _this.localStore.collectGarbage();\n        });\n    };\n    SyncEngine.prototype.assertSubscribed = function (fnName) {\n        assert(this.viewHandler !== null && this.errorHandler !== null, 'Trying to call ' + fnName + ' before calling subscribe().');\n    };\n    SyncEngine.prototype.handleUserChange = function (user) {\n        var _this = this;\n        this.currentUser = user;\n        return this.localStore\n            .handleUserChange(user)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        })\n            .then(function () {\n            return _this.remoteStore.handleUserChange(user);\n        });\n    };\n    return SyncEngine;\n}());\n\n\n//# sourceMappingURL=sync_engine.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/mutation_batch.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar BATCHID_UNKNOWN = -1;\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nvar mutation_batch_MutationBatch = /** @class */ (function () {\n    function MutationBatch(batchId, localWriteTime, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to create a new remote document\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     * @param batchResult The result of applying the MutationBatch to the\n     * backend.\n     */\n    MutationBatch.prototype.applyToRemoteDocument = function (docKey, maybeDoc, batchResult) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(docKey), \"applyToRemoteDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        var mutationResults = batchResult.mutationResults;\n        assert(mutationResults.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + mutationResults.length + \").\");\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.equals(docKey)) {\n                var mutationResult = mutationResults[i];\n                maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n            }\n        }\n        return maybeDoc;\n    };\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     */\n    MutationBatch.prototype.applyToLocalView = function (docKey, maybeDoc) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(docKey), \"applyToLocalDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.equals(docKey)) {\n                maybeDoc = mutation.applyToLocalView(maybeDoc, this.localWriteTime);\n            }\n        }\n        return maybeDoc;\n    };\n    MutationBatch.prototype.keys = function () {\n        var keySet = documentKeySet();\n        for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {\n            var mutation = _a[_i];\n            keySet = keySet.add(mutation.key);\n        }\n        return keySet;\n    };\n    MutationBatch.prototype.equals = function (other) {\n        return (this.batchId === other.batchId &&\n            arrayEquals(this.mutations, other.mutations));\n    };\n    /**\n     * Returns true if this mutation batch has already been removed from the\n     * mutation queue.\n     *\n     * Note that not all implementations of the MutationQueue necessarily use\n     * tombstones as part of their implementation and generally speaking no code\n     * outside the mutation queues should really care about this.\n     */\n    MutationBatch.prototype.isTombstone = function () {\n        return this.mutations.length === 0;\n    };\n    /** Converts this batch into a tombstone */\n    MutationBatch.prototype.toTombstone = function () {\n        return new MutationBatch(this.batchId, this.localWriteTime, []);\n    };\n    return MutationBatch;\n}());\n\n/** The result of applying a mutation batch to the backend. */\nvar mutation_batch_MutationBatchResult = /** @class */ (function () {\n    function MutationBatchResult(batch, commitVersion, mutationResults, streamToken, \n        /**\n         * A pre-computed mapping from each mutated document to the resulting\n         * version.\n         */\n        docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.streamToken = streamToken;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=>version mapping (docVersions).\n     */\n    MutationBatchResult.from = function (batch, commitVersion, results, streamToken) {\n        assert(batch.mutations.length === results.length, 'Mutations sent ' +\n            batch.mutations.length +\n            ' must equal results received ' +\n            results.length);\n        var versionMap = documentVersionMap();\n        var mutations = batch.mutations;\n        for (var i = 0; i < mutations.length; i++) {\n            var version = results[i].version;\n            if (version === null) {\n                // deletes don't have a version, so we substitute the commitVersion\n                // of the entire batch.\n                version = commitVersion;\n            }\n            versionMap = versionMap.insert(mutations[i].key, version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);\n    };\n    return MutationBatchResult;\n}());\n\n\n//# sourceMappingURL=mutation_batch.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/encoded_resource_path.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar escapeChar = '\\u0001';\nvar encodedSeparatorChar = '\\u0001';\nvar encodedNul = '\\u0010';\nvar encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nfunction encode(path) {\n    var result = '';\n    for (var i = 0; i < path.length; i++) {\n        if (result.length > 0) {\n            result = encodeSeparator(result);\n        }\n        result = encodeSegment(path.get(i), result);\n    }\n    return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment, resultBuf) {\n    var result = resultBuf;\n    var length = segment.length;\n    for (var i = 0; i < length; i++) {\n        var c = segment.charAt(i);\n        switch (c) {\n            case '\\0':\n                result += escapeChar + encodedNul;\n                break;\n            case escapeChar:\n                result += escapeChar + encodedEscape;\n                break;\n            default:\n                result += c;\n        }\n    }\n    return result;\n}\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result) {\n    return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nfunction decode(path) {\n    // Event the empty path must encode as a path of at least length 2. A path\n    // with exactly 2 must be the empty path.\n    var length = path.length;\n    assert(length >= 2, 'Invalid path ' + path);\n    if (length === 2) {\n        assert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, 'Non-empty path ' + path + ' had length 2');\n        return path_ResourcePath.EMPTY_PATH;\n    }\n    // Escape characters cannot exist past the second-to-last position in the\n    // source value.\n    var lastReasonableEscapeIndex = length - 2;\n    var segments = [];\n    var segmentBuilder = '';\n    for (var start = 0; start < length;) {\n        // The last two characters of a valid encoded path must be a separator, so\n        // there must be an end to this segment.\n        var end = path.indexOf(escapeChar, start);\n        if (end < 0 || end > lastReasonableEscapeIndex) {\n            fail('Invalid encoded resource path: \"' + path + '\"');\n        }\n        var next = path.charAt(end + 1);\n        switch (next) {\n            case encodedSeparatorChar:\n                var currentPiece = path.substring(start, end);\n                var segment = void 0;\n                if (segmentBuilder.length === 0) {\n                    // Avoid copying for the common case of a segment that excludes \\0\n                    // and \\001\n                    segment = currentPiece;\n                }\n                else {\n                    segmentBuilder += currentPiece;\n                    segment = segmentBuilder;\n                    segmentBuilder = '';\n                }\n                segments.push(segment);\n                break;\n            case encodedNul:\n                segmentBuilder += path.substring(start, end);\n                segmentBuilder += '\\0';\n                break;\n            case encodedEscape:\n                // The escape character can be used in the output to encode itself.\n                segmentBuilder += path.substring(start, end + 1);\n                break;\n            default:\n                fail('Invalid encoded resource path: \"' + path + '\"');\n        }\n        start = end + 2;\n    }\n    return new path_ResourcePath(segments);\n}\n/**\n * Computes the prefix successor of the given path, computed by encode above.\n * A prefix successor is the first key that cannot be prefixed by the given\n * path. It's useful for defining the end of a prefix scan such that all keys\n * in the scan have the same prefix.\n *\n * Note that this is not a general prefix successor implementation, which is\n * tricky to get right with Strings, given that they encode down to UTF-8.\n * Instead this relies on the fact that all paths encoded by this class are\n * always terminated with a separator, and so a successor can always be\n * cheaply computed by incrementing the last character of the path.\n */\nfunction prefixSuccessor(path) {\n    var c = path.charCodeAt(path.length - 1);\n    // TODO(mcg): this really should be a general thing, but not worth it right\n    // now\n    assert(c === 1, 'successor may only operate on paths generated by encode');\n    return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);\n}\n\n//# sourceMappingURL=encoded_resource_path.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_schema.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar SCHEMA_VERSION = 1;\n/** Performs database creation and (in the future) upgrades between versions. */\nfunction createOrUpgradeDb(db, oldVersion) {\n    assert(oldVersion === 0, 'Unexpected upgrade from version ' + oldVersion);\n    db.createObjectStore(DbMutationQueue.store, {\n        keyPath: DbMutationQueue.keyPath\n    });\n    // TODO(mikelehen): Get rid of \"as any\" if/when TypeScript fixes their\n    // types. https://github.com/Microsoft/TypeScript/issues/14322\n    db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbMutationBatch.store, { keyPath: DbMutationBatch.keyPath });\n    var targetDocumentsStore = db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbTargetDocument.store, { keyPath: DbTargetDocument.keyPath });\n    targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });\n    var targetStore = db.createObjectStore(DbTarget.store, {\n        keyPath: DbTarget.keyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });\n    // NOTE: keys for these stores are specified explicitly rather than using a\n    // keyPath.\n    db.createObjectStore(indexeddb_schema_DbDocumentMutation.store);\n    db.createObjectStore(DbRemoteDocument.store);\n    db.createObjectStore(DbOwner.store);\n    db.createObjectStore(DbTargetGlobal.store);\n}\n/**\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\n */\nvar DbTimestamp = /** @class */ (function () {\n    function DbTimestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n    }\n    return DbTimestamp;\n}());\n\n/**\n * A singleton object to be stored in the 'owner' store in IndexedDb.\n *\n * A given database can be owned by a single tab at a given time. That tab\n * must validate that it is still the owner before every write operation and\n * should regularly write an updated timestamp to prevent other tabs from\n * \"stealing\" ownership of the db.\n */\nvar DbOwner = /** @class */ (function () {\n    function DbOwner(ownerId, leaseTimestampMs) {\n        this.ownerId = ownerId;\n        this.leaseTimestampMs = leaseTimestampMs;\n    }\n    /** Name of the IndexedDb object store. */\n    DbOwner.store = 'owner';\n    return DbOwner;\n}());\n\n/**\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\n *\n * Each user gets a single queue of MutationBatches to apply to the server.\n * DbMutationQueue tracks the metadata about the queue.\n */\nvar DbMutationQueue = /** @class */ (function () {\n    function DbMutationQueue(\n        /**\n           * The normalized user ID to which this queue belongs.\n           */\n        userId, \n        /**\n           * An identifier for the highest numbered batch that has been acknowledged\n           * by the server. All MutationBatches in this queue with batchIds less\n           * than or equal to this value are considered to have been acknowledged by\n           * the server.\n           */\n        lastAcknowledgedBatchId, \n        /**\n           * A stream token that was previously sent by the server.\n           *\n           * See StreamingWriteRequest in datastore.proto for more details about\n           * usage.\n           *\n           * After sending this token, earlier tokens may not be used anymore so\n           * only a single stream token is retained.\n           */\n        lastStreamToken) {\n        this.userId = userId;\n        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;\n        this.lastStreamToken = lastStreamToken;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationQueue.store = 'mutationQueues';\n    /** Keys are automatically assigned via the userId property. */\n    DbMutationQueue.keyPath = 'userId';\n    return DbMutationQueue;\n}());\n\n/**\n * An object to be stored in the 'mutations' store in IndexedDb.\n *\n * Represents a batch of user-level mutations intended to be sent to the server\n * in a single write. Each user-level batch gets a separate DbMutationBatch\n * with a new batchId.\n */\nvar DbMutationBatch = /** @class */ (function () {\n    function DbMutationBatch(\n        /**\n           * The normalized user ID to which this batch belongs.\n           */\n        userId, \n        /**\n           * An identifier for this batch, allocated by the mutation queue in a\n           * monotonically increasing manner.\n           */\n        batchId, \n        /**\n           * The local write time of the batch, stored as milliseconds since the\n           * epoch.\n           */\n        localWriteTimeMs, \n        /**\n           * A list of mutations to apply. All mutations will be applied atomically.\n           *\n           * Mutations are serialized via JsonProtoSerializer.toMutation().\n           */\n        mutations) {\n        this.userId = userId;\n        this.batchId = batchId;\n        this.localWriteTimeMs = localWriteTimeMs;\n        this.mutations = mutations;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationBatch.store = 'mutations';\n    /** Keys are automatically assigned via the userId, batchId properties. */\n    DbMutationBatch.keyPath = ['userId', 'batchId'];\n    return DbMutationBatch;\n}());\n\n/**\n * An object to be stored in the 'documentMutations' store in IndexedDb.\n *\n * A manually maintained index of all the mutation batches that affect a given\n * document key. The rows in this table are references based on the contents of\n * DbMutationBatch.mutations.\n */\nvar indexeddb_schema_DbDocumentMutation = /** @class */ (function () {\n    function DbDocumentMutation() {\n    }\n    /**\n     * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n     * over all of a user's document mutations.\n     */\n    DbDocumentMutation.prefixForUser = function (userId) {\n        return [userId];\n    };\n    /**\n     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n     * index to iterate over all at document mutations for a given path or lower.\n     */\n    DbDocumentMutation.prefixForPath = function (userId, path) {\n        return [userId, encode(path)];\n    };\n    /**\n     * Creates a full index key of [userId, encodedPath, batchId] for inserting\n     * and deleting into the DbDocumentMutations index.\n     */\n    DbDocumentMutation.key = function (userId, path, batchId) {\n        return [userId, encode(path), batchId];\n    };\n    DbDocumentMutation.store = 'documentMutations';\n    /**\n     * Because we store all the useful information for this store in the key,\n     * there is no useful information to store as the value. The raw (unencoded)\n     * path cannot be stored because IndexedDb doesn't store prototype\n     * information.\n     */\n    DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();\n    return DbDocumentMutation;\n}());\n\n/**\n * Represents the known absence of a document at a particular version.\n * Stored in IndexedDb as part of a DbRemoteDocument object.\n */\nvar DbNoDocument = /** @class */ (function () {\n    function DbNoDocument(path, readTime) {\n        this.path = path;\n        this.readTime = readTime;\n    }\n    return DbNoDocument;\n}());\n\n/**\n * An object to be stored in the 'remoteDocuments' store in IndexedDb. It\n * represents either a cached document (if it exists) or a cached \"no-document\"\n * (if it is known to not exist).\n *\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\n * be made more general if necessary.\n */\nvar DbRemoteDocument = /** @class */ (function () {\n    function DbRemoteDocument(\n        /**\n           * Set to an instance of a DbNoDocument if it is known that no document\n           * exists.\n           */\n        noDocument, \n        /**\n           * Set to an instance of a Document if there's a cached version of the\n           * document.\n           */\n        document) {\n        this.noDocument = noDocument;\n        this.document = document;\n    }\n    DbRemoteDocument.store = 'remoteDocuments';\n    return DbRemoteDocument;\n}());\n\n/**\n * An object to be stored in the 'targets' store in IndexedDb.\n *\n * This is based on and should be kept in sync with the proto used in the iOS\n * client.\n *\n * Each query the client listens to against the server is tracked on disk so\n * that the query can be efficiently resumed on restart.\n */\nvar DbTarget = /** @class */ (function () {\n    function DbTarget(\n        /**\n           * An auto-generated sequential numeric identifier for the query.\n           *\n           * Queries are stored using their canonicalId as the key, but these\n           * canonicalIds can be quite long so we additionally assign a unique\n           * queryId which can be used by referenced data structures (e.g.\n           * indexes) to minimize the on-disk cost.\n           */\n        targetId, \n        /**\n           * The canonical string representing this query. This is not unique.\n           */\n        canonicalId, \n        /**\n           * The last readTime received from the Watch Service for this query.\n           *\n           * This is the same value as TargetChange.read_time in the protos.\n           */\n        readTime, \n        /**\n           * An opaque, server-assigned token that allows watching a query to be\n           * resumed after disconnecting without retransmitting all the data\n           * that matches the query. The resume token essentially identifies a\n           * point in time from which the server should resume sending results.\n           *\n           * This is related to the snapshotVersion in that the resumeToken\n           * effectively also encodes that value, but the resumeToken is opaque\n           * and sometimes encodes additional information.\n           *\n           * A consequence of this is that the resumeToken should be used when\n           * asking the server to reason about where this client is in the watch\n           * stream, but the client should use the snapshotVersion for its own\n           * purposes.\n           *\n           * This is the same value as TargetChange.resume_token in the protos.\n           */\n        resumeToken, \n        /**\n           * A sequence number representing the last time this query was\n           * listened to, used for garbage collection purposes.\n           *\n           * Conventionally this would be a timestamp value, but device-local\n           * clocks are unreliable and they must be able to create new listens\n           * even while disconnected. Instead this should be a monotonically\n           * increasing number that's incremented on each listen call.\n           *\n           * This is different from the queryId since the queryId is an\n           * immutable identifier assigned to the Query on first use while\n           * lastListenSequenceNumber is updated every time the query is\n           * listened to.\n           */\n        lastListenSequenceNumber, \n        /**\n           * The query for this target.\n           *\n           * Because canonical ids are not unique we must store the actual query. We\n           * use the proto to have an object we can persist without having to\n           * duplicate translation logic to and from a `Query` object.\n           */\n        query) {\n        this.targetId = targetId;\n        this.canonicalId = canonicalId;\n        this.readTime = readTime;\n        this.resumeToken = resumeToken;\n        this.lastListenSequenceNumber = lastListenSequenceNumber;\n        this.query = query;\n    }\n    DbTarget.store = 'targets';\n    /** Keys are automatically assigned via the targetId property. */\n    DbTarget.keyPath = 'targetId';\n    /** The name of the queryTargets index. */\n    DbTarget.queryTargetsIndexName = 'queryTargetsIndex';\n    /**\n     * The index of all canonicalIds to the targets that they match. This is not\n     * a unique mapping because canonicalId does not promise a unique name for all\n     * possible queries, so we append the targetId to make the mapping unique.\n     */\n    DbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];\n    return DbTarget;\n}());\n\n/**\n * An object representing an association between a target and a document.\n * Stored in the targetDocument object store to store the documents tracked by a\n * particular target.\n */\nvar DbTargetDocument = /** @class */ (function () {\n    function DbTargetDocument(\n        /**\n           * The targetId identifying a target.\n           */\n        targetId, \n        /**\n           * The path to the document, as encoded in the key.\n           */\n        path) {\n        this.targetId = targetId;\n        this.path = path;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbTargetDocument.store = 'targetDocuments';\n    /** Keys are automatically assigned via the targetId, path properties. */\n    DbTargetDocument.keyPath = ['targetId', 'path'];\n    /** The index name for the reverse index. */\n    DbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';\n    /** We also need to create the reverse index for these properties. */\n    DbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];\n    return DbTargetDocument;\n}());\n\n/**\n * A record of global state tracked across all Targets, tracked separately\n * to avoid the need for extra indexes.\n *\n * This should be kept in-sync with the proto used in the iOS client.\n */\nvar DbTargetGlobal = /** @class */ (function () {\n    function DbTargetGlobal(\n        /**\n           * The highest numbered target id across all targets.\n           *\n           * See DbTarget.targetId.\n           */\n        highestTargetId, \n        /**\n           * The highest numbered lastListenSequenceNumber across all targets.\n           *\n           * See DbTarget.lastListenSequenceNumber.\n           */\n        highestListenSequenceNumber, \n        /**\n           * A global snapshot version representing the last consistent snapshot we\n           * received from the backend. This is monotonically increasing and any\n           * snapshots received from the backend prior to this version (e.g. for\n           * targets resumed with a resumeToken) should be suppressed (buffered)\n           * until the backend has caught up to this snapshot version again. This\n           * prevents our cache from ever going backwards in time.\n           */\n        lastRemoteSnapshotVersion) {\n        this.highestTargetId = highestTargetId;\n        this.highestListenSequenceNumber = highestListenSequenceNumber;\n        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n    }\n    /**\n     * The key string used for the single object that exists in the\n     * DbTargetGlobal store.\n     */\n    DbTargetGlobal.key = 'targetGlobalKey';\n    DbTargetGlobal.store = 'targetGlobal';\n    return DbTargetGlobal;\n}());\n\n/**\n * The list of all IndexedDB stored used by the SDK. This is used when creating\n * transactions so that access across all stores is done atomically.\n */\nvar ALL_STORES = [\n    DbMutationQueue.store,\n    DbMutationBatch.store,\n    indexeddb_schema_DbDocumentMutation.store,\n    DbRemoteDocument.store,\n    DbTarget.store,\n    DbOwner.store,\n    DbTargetGlobal.store,\n    DbTargetDocument.store\n];\n\n//# sourceMappingURL=indexeddb_schema.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/simple_db.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar simple_db_LOG_TAG = 'SimpleDb';\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nvar simple_db_SimpleDb = /** @class */ (function () {\n    function SimpleDb(db) {\n        this.db = db;\n    }\n    /** Opens the specified database, creating or upgrading it if necessary. */\n    SimpleDb.openOrCreate = function (name, version, runUpgrade) {\n        assert(SimpleDb.isAvailable(), 'IndexedDB not supported in current environment.');\n        debug(simple_db_LOG_TAG, 'Opening database:', name);\n        return new persistence_promise_PersistencePromise(function (resolve, reject) {\n            // TODO(mikelehen): Investigate browser compatibility.\n            // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n            // suggests IE9 and older WebKit browsers handle upgrade\n            // differently.\n            var request = window.indexedDB.open(name, version);\n            request.onsuccess = function (event) {\n                var db = event.target.result;\n                resolve(new SimpleDb(db));\n            };\n            request.onerror = function (event) {\n                reject(event.target.error);\n            };\n            request.onupgradeneeded = function (event) {\n                debug(simple_db_LOG_TAG, 'Database \"' + name + '\" requires upgrade from version:', event.oldVersion);\n                // TODO(mikelehen): If/when we need to do an actual data\n                // migration, we'll want to wrap db in a SimpleDb and have the\n                // runUpgrade function return a PersistencePromise, since we'll\n                // likely need to do async reads and writes. For now we're\n                // cheating and just passing the raw IndexedDB in, since\n                // createObjectStore(), etc. are synchronous.\n                var db = event.target.result;\n                runUpgrade(db, event.oldVersion);\n            };\n        }).toPromise();\n    };\n    /** Deletes the specified database. */\n    SimpleDb.delete = function (name) {\n        debug(simple_db_LOG_TAG, 'Removing database:', name);\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n    };\n    /** Returns true if IndexedDB is available in the current environment. */\n    SimpleDb.isAvailable = function () {\n        if (typeof window === 'undefined' || window.indexedDB == null) {\n            return false;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        var ua = window.navigator.userAgent;\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    SimpleDb.prototype.runTransaction = function (mode, objectStores, transactionFn) {\n        var transaction = new simple_db_SimpleDbTransaction(this.db, mode, objectStores);\n        var transactionFnResult = transactionFn(transaction)\n            .catch(function (error) {\n            // Abort the transaction if there was an\n            // error.\n            transaction.abort();\n            return persistence_promise_PersistencePromise.reject(error);\n        })\n            .toPromise();\n        // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n        // fire), but still return the original transactionFnResult back to the\n        // caller.\n        return transaction.completionPromise.then(function () { return transactionFnResult; });\n    };\n    SimpleDb.prototype.close = function () {\n        this.db.close();\n    };\n    return SimpleDb;\n}());\n\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nvar IterationController = /** @class */ (function () {\n    function IterationController(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    Object.defineProperty(IterationController.prototype, \"isDone\", {\n        get: function () {\n            return this.shouldStop;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"skipToKey\", {\n        get: function () {\n            return this.nextKey;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"cursor\", {\n        set: function (value) {\n            this.dbCursor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    IterationController.prototype.done = function () {\n        this.shouldStop = true;\n    };\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    IterationController.prototype.skip = function (key) {\n        this.nextKey = key;\n    };\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    IterationController.prototype.delete = function () {\n        return wrapRequest(this.dbCursor.delete());\n    };\n    return IterationController;\n}());\n\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nvar simple_db_SimpleDbTransaction = /** @class */ (function () {\n    function SimpleDbTransaction(db, mode, objectStoresNames) {\n        var _this = this;\n        this.aborted = false;\n        this.transaction = db.transaction(objectStoresNames, mode);\n        this.completionPromise = new Promise(function (resolve, reject) {\n            // We consider aborting to be \"normal\" and just resolve the promise.\n            // May need to revisit if/when we actually need to abort transactions.\n            _this.transaction.onabort = _this.transaction.oncomplete = function (event) {\n                resolve();\n            };\n            _this.transaction.onerror = function (event) {\n                reject(event.target.error);\n            };\n        });\n    }\n    SimpleDbTransaction.prototype.abort = function () {\n        if (!this.aborted) {\n            debug(simple_db_LOG_TAG, 'Aborting transaction.');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    };\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    SimpleDbTransaction.prototype.store = function (storeName) {\n        var store = this.transaction.objectStore(storeName);\n        assert(!!store, 'Object store not part of transaction: ' + storeName);\n        return new simple_db_SimpleDbStore(store);\n    };\n    return SimpleDbTransaction;\n}());\n\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nvar simple_db_SimpleDbStore = /** @class */ (function () {\n    function SimpleDbStore(store) {\n        this.store = store;\n    }\n    SimpleDbStore.prototype.put = function (keyOrValue, value) {\n        var request;\n        if (value !== undefined) {\n            debug(simple_db_LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            debug(simple_db_LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    };\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @return The object with the specified key or null if no object exists.\n     */\n    SimpleDbStore.prototype.get = function (key) {\n        var _this = this;\n        var request = this.store.get(key);\n        // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.\n        return wrapRequest(request).next(function (result) {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            debug(simple_db_LOG_TAG, 'GET', _this.store.name, key, result);\n            return result;\n        });\n    };\n    SimpleDbStore.prototype.delete = function (key) {\n        debug(simple_db_LOG_TAG, 'DELETE', this.store.name, key);\n        var request = this.store.delete(key);\n        return wrapRequest(request);\n    };\n    SimpleDbStore.prototype.loadAll = function (indexOrRange, range) {\n        var cursor = this.cursor(this.options(indexOrRange, range));\n        var results = [];\n        return this.iterateCursor(cursor, function (key, value) {\n            results.push(value);\n        }).next(function () {\n            return results;\n        });\n    };\n    SimpleDbStore.prototype.deleteAll = function (indexOrRange, range) {\n        debug(simple_db_LOG_TAG, 'DELETE ALL', this.store.name);\n        var options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, function (key, value, control) {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    };\n    SimpleDbStore.prototype.iterate = function (optionsOrCallback, callback) {\n        var options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    };\n    SimpleDbStore.prototype.iterateCursor = function (cursorRequest, fn) {\n        var results = [];\n        return new persistence_promise_PersistencePromise(function (resolve, reject) {\n            cursorRequest.onerror = function (event) {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                var controller = new IterationController(cursor);\n                var userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof persistence_promise_PersistencePromise) {\n                    results.push(userResult);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(function () {\n            return persistence_promise_PersistencePromise.waitFor(results);\n        });\n    };\n    SimpleDbStore.prototype.options = function (indexOrRange, range) {\n        var indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                assert(range === undefined, '3rd argument must not be defined if 2nd is a range.');\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range: range };\n    };\n    SimpleDbStore.prototype.cursor = function (options) {\n        var direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            var index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    };\n    return SimpleDbStore;\n}());\n\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new persistence_promise_PersistencePromise(function (resolve, reject) {\n        request.onsuccess = function (event) {\n            var result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = function (event) {\n            reject(event.target.error);\n        };\n    });\n}\n\n//# sourceMappingURL=simple_db.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_mutation_queue.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n/** A mutation queue for a specific user, backed by IndexedDB. */\nvar indexeddb_mutation_queue_IndexedDbMutationQueue = /** @class */ (function () {\n    function IndexedDbMutationQueue(\n        /**\n           * The normalized userId (e.g. null UID => \"\" userId) used to store /\n           * retrieve mutations.\n           */\n        userId, serializer) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.garbageCollector = null;\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user The user for which to create a mutation queue.\n     * @param serializer The serializer to use when persisting to IndexedDb.\n     */\n    IndexedDbMutationQueue.forUser = function (user, serializer) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        assert(user.uid !== '', 'UserID must not be an empty string.');\n        var userId = user.isUnauthenticated() ? '' : user.uid;\n        return new IndexedDbMutationQueue(userId, serializer);\n    };\n    IndexedDbMutationQueue.prototype.start = function (transaction) {\n        var _this = this;\n        return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction)\n            .next(function (nextBatchId) {\n            _this.nextBatchId = nextBatchId;\n            return mutationQueuesStore(transaction).get(_this.userId);\n        })\n            .next(function (metadata) {\n            if (!metadata) {\n                metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, \n                /*lastStreamToken=*/ '');\n            }\n            _this.metadata = metadata;\n            // On restart, nextBatchId may end up lower than\n            // lastAcknowledgedBatchId since it's computed from the queue\n            // contents, and there may be no mutations in the queue. In this\n            // case, we need to reset lastAcknowledgedBatchId (which is safe\n            // since the queue must be empty).\n            if (_this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId) {\n                return _this.checkEmpty(transaction).next(function (empty) {\n                    assert(empty, 'Reset nextBatchID is only possible when the queue is empty');\n                    _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n                    return mutationQueuesStore(transaction).put(_this.metadata);\n                });\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns one larger than the largest batch ID that has been stored. If there\n     * are no mutations returns 0. Note that batch IDs are global.\n     */\n    IndexedDbMutationQueue.loadNextBatchIdFromDb = function (txn) {\n        var maxBatchId = BATCHID_UNKNOWN;\n        return mutationsStore(txn)\n            .iterate({ reverse: true }, function (key, batch, control) {\n            var userId = key[0], batchId = key[1];\n            if (batchId > maxBatchId) {\n                maxBatchId = batch.batchId;\n            }\n            if (userId === '') {\n                // We can't compute a predecessor for the empty string, since it\n                // is lexographically first. That also means that no other\n                // userIds can come before this one, so we can just exit early.\n                control.done();\n            }\n            else {\n                var nextUser = immediatePredecessor(userId);\n                control.skip([nextUser]);\n            }\n        })\n            .next(function () { return maxBatchId + 1; });\n    };\n    IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {\n        var empty = true;\n        var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, value, control) {\n            empty = false;\n            control.done();\n        })\n            .next(function () { return empty; });\n    };\n    IndexedDbMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.nextBatchId);\n    };\n    IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n    };\n    IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        this.metadata.lastAcknowledgedBatchId = batchId;\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.metadata.lastStreamToken);\n    };\n    IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        var _this = this;\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        var batch = new mutation_batch_MutationBatch(batchId, localWriteTime, mutations);\n        var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n        return mutationsStore(transaction)\n            .put(dbBatch)\n            .next(function () {\n            var promises = [];\n            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n                var mutation = mutations_1[_i];\n                var encodedPath = encode(mutation.key.path);\n                var indexKey = indexeddb_schema_DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);\n                documentMutationsStore(transaction).put(indexKey, indexeddb_schema_DbDocumentMutation.PLACEHOLDER);\n            }\n            return persistence_promise_PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            return batch;\n        });\n    };\n    IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        var _this = this;\n        return mutationsStore(transaction)\n            .get(this.keyForBatchId(batchId))\n            .next(function (dbBatch) {\n            return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;\n        });\n    };\n    IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var _this = this;\n        var range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));\n        var foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, dbBatch, control) {\n            if (dbBatch.userId === _this.userId) {\n                assert(dbBatch.batchId > batchId, 'Should have found mutation after ' + batchId);\n                foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);\n            }\n            control.done();\n        })\n            .next(function () { return foundBatch; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        var indexPrefix = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        var results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            var path = decode(encodedPath);\n            if (userID !== _this.userId || !documentKey.path.equals(path)) {\n                control.done();\n                return;\n            }\n            var mutationKey = _this.keyForBatchId(batchID);\n            // Look up the mutation batch in the store.\n            // PORTING NOTE: because iteration is callback driven in the web,\n            // we just look up the key instead of keeping an open iterator\n            // like iOS.\n            return mutationsStore(transaction)\n                .get(mutationKey)\n                .next(function (dbBatch) {\n                if (dbBatch === null) {\n                    fail('Dangling document-mutation reference found: ' +\n                        indexKey +\n                        ' which points to ' +\n                        mutationKey);\n                }\n                results.push(_this.serializer.fromDbMutationBatch(dbBatch));\n            });\n        })\n            .next(function () { return results; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        assert(!query.isDocumentQuery(), \"Document queries shouldn't go down this path\");\n        var queryPath = query.path;\n        var immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        var indexPrefix = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, queryPath);\n        var encodedQueryPath = indexPrefix[1];\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        var uniqueBatchIDs = new sorted_set_SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            var path = decode(encodedPath);\n            if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(function () {\n            var results = [];\n            var promises = [];\n            // TODO(rockwood): Implement this using iterate.\n            uniqueBatchIDs.forEach(function (batchID) {\n                var mutationKey = _this.keyForBatchId(batchID);\n                promises.push(mutationsStore(transaction)\n                    .get(mutationKey)\n                    .next(function (mutation) {\n                    if (mutation === null) {\n                        fail('Dangling document-mutation reference found, ' +\n                            'which points to ' +\n                            mutationKey);\n                    }\n                    results.push(_this.serializer.fromDbMutationBatch(mutation));\n                }));\n            });\n            return persistence_promise_PersistencePromise.waitFor(promises).next(function () { return results; });\n        });\n    };\n    IndexedDbMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var txn = mutationsStore(transaction);\n        var indexTxn = documentMutationsStore(transaction);\n        var promises = [];\n        var _loop_1 = function (batch) {\n            var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));\n            var numDeleted = 0;\n            var removePromise = txn.iterate({ range: range }, function (key, value, control) {\n                numDeleted++;\n                return control.delete();\n            });\n            promises.push(removePromise.next(function () {\n                assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' +\n                    batch.batchId);\n            }));\n            for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {\n                var mutation = _a[_i];\n                var indexKey = indexeddb_schema_DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);\n                promises.push(indexTxn.delete(indexKey));\n                if (this_1.garbageCollector !== null) {\n                    this_1.garbageCollector.addPotentialGarbageKey(mutation.key);\n                }\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            _loop_1(batch);\n        }\n        return persistence_promise_PersistencePromise.waitFor(promises);\n    };\n    IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        var _this = this;\n        return this.checkEmpty(txn).next(function (empty) {\n            if (!empty) {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            var startRange = IDBKeyRange.lowerBound(indexeddb_schema_DbDocumentMutation.prefixForUser(_this.userId));\n            var danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, function (key, _, control) {\n                var userID = key[0];\n                if (userID !== _this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    var path = decode(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(function () {\n                assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' +\n                    danglingMutationReferences.map(function (p) { return p.canonicalString(); }));\n            });\n        });\n    };\n    IndexedDbMutationQueue.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {\n        var _this = this;\n        var indexKey = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, key.path);\n        var encodedPath = indexKey[1];\n        var startRange = IDBKeyRange.lowerBound(indexKey);\n        var containsKey = false;\n        return documentMutationsStore(txn)\n            .iterate({ range: startRange, keysOnly: true }, function (key, _, control) {\n            var userID = key[0], keyPath = key[1], batchID = key[2];\n            if (userID === _this.userId && keyPath === encodedPath) {\n                containsKey = true;\n            }\n            control.done();\n        })\n            .next(function () { return containsKey; });\n    };\n    /**\n     * Creates a [userId, batchId] key for use with the DbMutationQueue object\n     * store.\n     */\n    IndexedDbMutationQueue.prototype.keyForBatchId = function (batchId) {\n        return [this.userId, batchId];\n    };\n    return IndexedDbMutationQueue;\n}());\n\nfunction validateStreamToken(token) {\n    assert(typeof token === 'string', 'Persisting non-string stream token not supported.');\n    return token;\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatch.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, indexeddb_schema_DbDocumentMutation.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueue.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore(txn, store) {\n    if (txn instanceof simple_db_SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n//# sourceMappingURL=indexeddb_mutation_queue.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_query_cache.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\nvar indexeddb_query_cache_IndexedDbQueryCache = /** @class */ (function () {\n    function IndexedDbQueryCache(serializer) {\n        this.serializer = serializer;\n        /**\n         * The last received snapshot version. We store this seperately from the\n         * metadata to avoid the extra conversion to/from DbTimestamp.\n         */\n        this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.MIN;\n        /**\n         * A cached copy of the metadata for the query cache.\n         */\n        this.metadata = new DbTargetGlobal(\n        /*highestTargetId=*/ 0, \n        /*lastListenSequenceNumber=*/ 0, snapshot_version_SnapshotVersion.MIN.toTimestamp());\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n    }\n    IndexedDbQueryCache.prototype.start = function (transaction) {\n        var _this = this;\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobal.key)\n            .next(function (metadata) {\n            if (metadata !== null) {\n                _this.metadata = metadata;\n                var lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n                _this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.fromTimestamp(new timestamp_Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));\n            }\n            return persistence_promise_PersistencePromise.resolve();\n        });\n    };\n    IndexedDbQueryCache.prototype.getHighestTargetId = function () {\n        return this.metadata.highestTargetId;\n    };\n    IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n    };\n    IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        var _this = this;\n        var targetId = queryData.targetId;\n        var addedQueryPromise = targetsStore(transaction).put(this.serializer.toDbTarget(queryData));\n        if (targetId > this.metadata.highestTargetId) {\n            this.metadata.highestTargetId = targetId;\n            return addedQueryPromise.next(function () {\n                return globalTargetStore(transaction).put(DbTargetGlobal.key, _this.metadata);\n            });\n        }\n        else {\n            return addedQueryPromise;\n        }\n    };\n    IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function () {\n            targetsStore(transaction).delete(queryData.targetId);\n        });\n    };\n    IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {\n        var _this = this;\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficent.\n        var canonicalId = query.canonicalId();\n        var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        var result = null;\n        return targetsStore(transaction)\n            .iterate({ range: range, index: DbTarget.queryTargetsIndexName }, function (key, value, control) {\n            var found = _this.serializer.fromDbTarget(value);\n            // After finding a potential match, check that the query is\n            // actually equal to the requested query.\n            if (query.equals(found.query)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // Indexeddb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = encode(key.path);\n            promises.push(store.put(new DbTargetDocument(targetId, path)));\n        });\n        return persistence_promise_PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        var _this = this;\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = encode(key.path);\n            promises.push(store.delete([targetId, path]));\n            if (_this.garbageCollector !== null) {\n                _this.garbageCollector.addPotentialGarbageKey(key);\n            }\n        });\n        return persistence_promise_PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        var store = documentTargetStore(txn);\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return this.notifyGCForRemovedKeys(txn, range).next(function () {\n            return store.delete(range);\n        });\n    };\n    IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) {\n        var _this = this;\n        var store = documentTargetStore(txn);\n        if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n            // In order to generate garbage events properly, we need to read these\n            // keys before deleting.\n            return store.iterate({ range: range, keysOnly: true }, function (key, _, control) {\n                var path = decode(key[1]);\n                var docKey = new document_key_DocumentKey(path);\n                // Paranoid assertion in case the the collector is set to null\n                // during the iteration.\n                assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');\n                _this.garbageCollector.addPotentialGarbageKey(docKey);\n            });\n        }\n        else {\n            return persistence_promise_PersistencePromise.resolve();\n        }\n    };\n    IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var promises = [];\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var store = documentTargetStore(txn);\n        var result = documentKeySet();\n        return store\n            .iterate({ range: range, keysOnly: true }, function (key, _, control) {\n            var path = decode(key[1]);\n            var docKey = new document_key_DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbQueryCache.prototype.containsKey = function (txn, key) {\n        assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');\n        var path = encode(key.path);\n        var range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocument.documentTargetsIndex,\n            keysOnly: true,\n            range: range\n        }, function (key, _, control) {\n            count++;\n            control.done();\n        })\n            .next(function () { return count > 0; });\n    };\n    return IndexedDbQueryCache;\n}());\n\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return indexeddb_query_cache_getStore(txn, DbTarget.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return indexeddb_query_cache_getStore(txn, DbTargetGlobal.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return indexeddb_query_cache_getStore(txn, DbTargetDocument.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction indexeddb_query_cache_getStore(txn, store) {\n    if (txn instanceof simple_db_SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n//# sourceMappingURL=indexeddb_query_cache.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_remote_document_cache.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\nvar indexeddb_remote_document_cache_IndexedDbRemoteDocumentCache = /** @class */ (function () {\n    function IndexedDbRemoteDocumentCache(serializer) {\n        this.serializer = serializer;\n    }\n    IndexedDbRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        return remoteDocumentsStore(transaction).put(dbKey(maybeDocument.key), this.serializer.toDbRemoteDocument(maybeDocument));\n    };\n    IndexedDbRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        return remoteDocumentsStore(transaction).delete(dbKey(documentKey));\n    };\n    IndexedDbRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        var _this = this;\n        return remoteDocumentsStore(transaction)\n            .get(dbKey(documentKey))\n            .next(function (dbRemoteDoc) {\n            return dbRemoteDoc\n                ? _this.serializer.fromDbRemoteDocument(dbRemoteDoc)\n                : null;\n        });\n    };\n    IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var _this = this;\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var startKey = query.path.toArray();\n        var range = IDBKeyRange.lowerBound(startKey);\n        return remoteDocumentsStore(transaction)\n            .iterate({ range: range }, function (key, dbRemoteDoc, control) {\n            var maybeDoc = _this.serializer.fromDbRemoteDocument(dbRemoteDoc);\n            if (!query.path.isPrefixOf(maybeDoc.key.path)) {\n                control.done();\n            }\n            else if (maybeDoc instanceof document_Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        })\n            .next(function () { return results; });\n    };\n    return IndexedDbRemoteDocumentCache;\n}());\n\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(txn) {\n    if (txn instanceof simple_db_SimpleDbTransaction) {\n        return txn.store(DbRemoteDocument.store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\nfunction dbKey(docKey) {\n    return docKey.path.toArray();\n}\n\n//# sourceMappingURL=indexeddb_remote_document_cache.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/local_serializer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n/** Serializer for values stored in the LocalStore. */\nvar local_serializer_LocalSerializer = /** @class */ (function () {\n    function LocalSerializer(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n    /** Decodes a remote document from storage locally to a Document. */\n    LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {\n        if (remoteDoc.document) {\n            return this.remoteSerializer.fromDocument(remoteDoc.document);\n        }\n        else if (remoteDoc.noDocument) {\n            var key = document_key_DocumentKey.fromSegments(remoteDoc.noDocument.path);\n            var readTime = remoteDoc.noDocument.readTime;\n            var timestamp = new timestamp_Timestamp(readTime.seconds, readTime.nanos);\n            return new document_NoDocument(key, snapshot_version_SnapshotVersion.fromTimestamp(timestamp));\n        }\n        else {\n            return fail('Unexpected DbRemoteDocument');\n        }\n    };\n    /** Encodes a document for storage locally. */\n    LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {\n        if (maybeDoc instanceof document_Document) {\n            var doc = this.remoteSerializer.toDocument(maybeDoc);\n            return new DbRemoteDocument(null, doc);\n        }\n        else {\n            var path = maybeDoc.key.path.toArray();\n            var timestamp = maybeDoc.version.toTimestamp();\n            var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n            return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n        }\n    };\n    /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n    LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {\n        var _this = this;\n        var serializedMutations = batch.mutations.map(function (m) {\n            return _this.remoteSerializer.toMutation(m);\n        });\n        return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);\n    };\n    /** Decodes a DbMutationBatch into a MutationBatch */\n    LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {\n        var _this = this;\n        var mutations = dbBatch.mutations.map(function (m) {\n            return _this.remoteSerializer.fromMutation(m);\n        });\n        var timestamp = timestamp_Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n        return new mutation_batch_MutationBatch(dbBatch.batchId, timestamp, mutations);\n    };\n    /** Decodes a DbTarget into QueryData */\n    LocalSerializer.prototype.fromDbTarget = function (dbTarget) {\n        var readTime = new timestamp_Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);\n        var version = snapshot_version_SnapshotVersion.fromTimestamp(readTime);\n        var query;\n        if (isDocumentQuery(dbTarget.query)) {\n            query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n        }\n        else {\n            query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n        }\n        return new query_data_QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);\n    };\n    /** Encodes QueryData into a DbTarget for storage locally. */\n    LocalSerializer.prototype.toDbTarget = function (queryData) {\n        assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' +\n            QueryPurpose.Listen +\n            ' may be stored, got ' +\n            queryData.purpose);\n        var timestamp = queryData.snapshotVersion.toTimestamp();\n        var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n        var queryProto;\n        if (queryData.query.isDocumentQuery()) {\n            queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n        }\n        else {\n            queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n        }\n        assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');\n        var resumeToken = queryData.resumeToken;\n        // lastListenSequenceNumber is always 0 until we do real GC.\n        return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);\n    };\n    return LocalSerializer;\n}());\n\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n\n//# sourceMappingURL=local_serializer.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_persistence.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\nvar indexeddb_persistence_LOG_TAG = 'IndexedDbPersistence';\n/** If the owner lease is older than 5 seconds, try to take ownership. */\nvar OWNER_LEASE_MAX_AGE_MS = 5000;\n/** Refresh the owner lease every 4 seconds while owner. */\nvar OWNER_LEASE_REFRESH_INTERVAL_MS = 4000;\n/** LocalStorage location to indicate a zombied ownerId (see class comment). */\nvar ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = 'zombiedOwnerId';\n/** Error when the owner lease cannot be acquired or is lost. */\nvar EXISTING_OWNER_ERROR_MSG = 'There is another tab open with offline' +\n    ' persistence enabled. Only one such tab is allowed at a time. The' +\n    ' other tab must be closed or persistence must be disabled.';\nvar UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing' +\n    ' IndexedDB or is known to have an incomplete implementation. Offline' +\n    ' persistence has been disabled.';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * Currently the Firestore SDK only supports a single consumer of the database,\n * but browsers obviously support multiple tabs. IndexedDbPersistence ensures a\n * single consumer of the database via an \"owner lease\" stored in the database.\n *\n * On startup, IndexedDbPersistence assigns itself a random \"ownerId\" and writes\n * it to a special \"owner\" object in the database (if no entry exists already or\n * the current entry is expired). This owner lease is then verified inside every\n * transaction to ensure the lease has not been lost.\n *\n * If a tab opts not to acquire the owner lease (because there's an existing\n * non-expired owner) or loses the owner lease, IndexedDbPersistence enters a\n * failed state and all subsequent operations will automatically fail.\n *\n * The current owner regularly refreshes the owner lease with new timestamps to\n * prevent newly-opened tabs from taking over ownership.\n *\n * Additionally there is an optimization so that when a tab is closed, the owner\n * lease is released immediately (this is especially important to make sure that\n * a refreshed tab is able to immediately re-acquire the owner lease).\n * Unfortunately, IndexedDB cannot be reliably used in window.unload since it is\n * an asynchronous API. So in addition to attempting to give up the lease,\n * the owner writes its ownerId to a \"zombiedOwnerId\" entry in LocalStorage\n * which acts as an indicator that another tab should go ahead and take the\n * owner lease immediately regardless of the current lease timestamp.\n */\nvar indexeddb_persistence_IndexedDbPersistence = /** @class */ (function () {\n    function IndexedDbPersistence(prefix, serializer) {\n        this.ownerId = this.generateOwnerId();\n        this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;\n        this.serializer = new local_serializer_LocalSerializer(serializer);\n        this.localStoragePrefix = prefix;\n    }\n    IndexedDbPersistence.prototype.start = function () {\n        var _this = this;\n        if (!IndexedDbPersistence.isAvailable()) {\n            this.persistenceError = new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n            return Promise.reject(this.persistenceError);\n        }\n        assert(!this.started, 'IndexedDbPersistence double-started!');\n        this.started = true;\n        return simple_db_SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb)\n            .then(function (db) {\n            _this.simpleDb = db;\n        })\n            .then(function () { return _this.tryAcquireOwnerLease(); })\n            .then(function () {\n            _this.scheduleOwnerLeaseRefreshes();\n            _this.attachWindowUnloadHook();\n        });\n    };\n    IndexedDbPersistence.prototype.shutdown = function () {\n        var _this = this;\n        assert(this.started, 'IndexedDbPersistence shutdown without start!');\n        this.started = false;\n        this.detachWindowUnloadHook();\n        this.stopOwnerLeaseRefreshes();\n        return this.releaseOwnerLease().then(function () {\n            _this.simpleDb.close();\n        });\n    };\n    IndexedDbPersistence.prototype.getMutationQueue = function (user) {\n        return indexeddb_mutation_queue_IndexedDbMutationQueue.forUser(user, this.serializer);\n    };\n    IndexedDbPersistence.prototype.getQueryCache = function () {\n        return new indexeddb_query_cache_IndexedDbQueryCache(this.serializer);\n    };\n    IndexedDbPersistence.prototype.getRemoteDocumentCache = function () {\n        return new indexeddb_remote_document_cache_IndexedDbRemoteDocumentCache(this.serializer);\n    };\n    IndexedDbPersistence.prototype.runTransaction = function (action, operation) {\n        var _this = this;\n        if (this.persistenceError) {\n            return Promise.reject(this.persistenceError);\n        }\n        debug(indexeddb_persistence_LOG_TAG, 'Starting transaction:', action);\n        // Do all transactions as readwrite against all object stores, since we\n        // are the only reader/writer.\n        return this.simpleDb.runTransaction('readwrite', ALL_STORES, function (txn) {\n            // Verify that we still have the owner lease as part of every transaction.\n            return _this.ensureOwnerLease(txn).next(function () { return operation(txn); });\n        });\n    };\n    IndexedDbPersistence.isAvailable = function () {\n        return simple_db_SimpleDb.isAvailable();\n    };\n    /**\n     * Generates a string used as a prefix when storing data in IndexedDB and\n     * LocalStorage.\n     */\n    IndexedDbPersistence.buildStoragePrefix = function (databaseInfo) {\n        // Use two different prefix formats:\n        //\n        //   * firestore / persistenceKey / projectID . databaseID / ...\n        //   * firestore / persistenceKey / projectID / ...\n        //\n        // projectIDs are DNS-compatible names and cannot contain dots\n        // so there's no danger of collisions.\n        var database = databaseInfo.databaseId.projectId;\n        if (!databaseInfo.databaseId.isDefaultDatabase) {\n            database += '.' + databaseInfo.databaseId.database;\n        }\n        return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';\n    };\n    /**\n     * Acquires the owner lease if there's no valid owner. Else returns a rejected\n     * promise.\n     */\n    IndexedDbPersistence.prototype.tryAcquireOwnerLease = function () {\n        var _this = this;\n        // NOTE: Don't use this.runTransaction, since it requires us to already\n        // have the lease.\n        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n            var store = txn.store(DbOwner.store);\n            return store.get('owner').next(function (dbOwner) {\n                if (!_this.validOwner(dbOwner)) {\n                    var newDbOwner = new DbOwner(_this.ownerId, Date.now());\n                    debug(indexeddb_persistence_LOG_TAG, 'No valid owner. Acquiring owner lease. Current owner:', dbOwner, 'New owner:', newDbOwner);\n                    return store.put('owner', newDbOwner);\n                }\n                else {\n                    debug(indexeddb_persistence_LOG_TAG, 'Valid owner already. Failing. Current owner:', dbOwner);\n                    _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n                    return persistence_promise_PersistencePromise.reject(_this.persistenceError);\n                }\n            });\n        });\n    };\n    /** Checks the owner lease and deletes it if we are the current owner. */\n    IndexedDbPersistence.prototype.releaseOwnerLease = function () {\n        var _this = this;\n        // NOTE: Don't use this.runTransaction, since it requires us to already\n        // have the lease.\n        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n            var store = txn.store(DbOwner.store);\n            return store.get('owner').next(function (dbOwner) {\n                if (dbOwner !== null && dbOwner.ownerId === _this.ownerId) {\n                    debug(indexeddb_persistence_LOG_TAG, 'Releasing owner lease.');\n                    return store.delete('owner');\n                }\n                else {\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n            });\n        });\n    };\n    /**\n     * Checks the owner lease and returns a rejected promise if we are not the\n     * current owner. This should be included in every transaction to guard\n     * against losing the owner lease.\n     */\n    IndexedDbPersistence.prototype.ensureOwnerLease = function (txn) {\n        var _this = this;\n        var store = txn.store(DbOwner.store);\n        return store.get('owner').next(function (dbOwner) {\n            if (dbOwner === null || dbOwner.ownerId !== _this.ownerId) {\n                _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n                return persistence_promise_PersistencePromise.reject(_this.persistenceError);\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns true if the provided owner exists, has a recent timestamp, and\n     * isn't zombied.\n     *\n     * NOTE: To determine if the owner is zombied, this method reads from\n     * LocalStorage which could be mildly expensive.\n     */\n    IndexedDbPersistence.prototype.validOwner = function (dbOwner) {\n        var now = Date.now();\n        var minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;\n        var maxAcceptable = now;\n        if (dbOwner === null) {\n            return false; // no owner.\n        }\n        else if (dbOwner.leaseTimestampMs < minAcceptable) {\n            return false; // owner lease has expired.\n        }\n        else if (dbOwner.leaseTimestampMs > maxAcceptable) {\n            log_error('Persistence owner-lease is in the future. Discarding.', dbOwner);\n            return false;\n        }\n        else if (dbOwner.ownerId === this.getZombiedOwnerId()) {\n            return false; // owner's tab closed.\n        }\n        else {\n            return true;\n        }\n    };\n    /**\n     * Schedules a recurring timer to update the owner lease timestamp to prevent\n     * other tabs from taking the lease.\n     */\n    IndexedDbPersistence.prototype.scheduleOwnerLeaseRefreshes = function () {\n        var _this = this;\n        // NOTE: This doesn't need to be scheduled on the async queue and doing so\n        // would increase the chances of us not refreshing on time if the queue is\n        // backed up for some reason.\n        this.ownerLeaseRefreshHandle = setInterval(function () {\n            var txResult = _this.runTransaction('Refresh owner timestamp', function (txn) {\n                // NOTE: We don't need to validate the current owner contents, since\n                // runTransaction does that automatically.\n                var store = txn.store(DbOwner.store);\n                return store.put('owner', new DbOwner(_this.ownerId, Date.now()));\n            });\n            txResult.catch(function (reason) {\n                // Probably means we lost the lease. Report the error and stop trying to\n                // refresh the lease.\n                log_error(reason);\n                _this.stopOwnerLeaseRefreshes();\n            });\n        }, OWNER_LEASE_REFRESH_INTERVAL_MS);\n    };\n    IndexedDbPersistence.prototype.stopOwnerLeaseRefreshes = function () {\n        if (this.ownerLeaseRefreshHandle) {\n            clearInterval(this.ownerLeaseRefreshHandle);\n            this.ownerLeaseRefreshHandle = null;\n        }\n    };\n    /**\n     * Attaches a window.unload handler that will synchronously write our\n     * ownerId to a \"zombie owner id\" location in localstorage. This can be used\n     * by tabs trying to acquire the lease to determine that the lease should be\n     * acquired immediately even if the timestamp is recent. This is particularly\n     * important for the refresh case (so the tab correctly re-acquires the owner\n     * lease). LocalStorage is used for this rather than IndexedDb because it is\n     * a synchronous API and so can be used reliably from an unload handler.\n     */\n    IndexedDbPersistence.prototype.attachWindowUnloadHook = function () {\n        var _this = this;\n        this.windowUnloadHandler = function () {\n            // Record that we're zombied.\n            _this.setZombiedOwnerId(_this.ownerId);\n            // Attempt graceful shutdown (including releasing our owner lease), but\n            // there's no guarantee it will complete.\n            _this.shutdown();\n        };\n        window.addEventListener('unload', this.windowUnloadHandler);\n    };\n    IndexedDbPersistence.prototype.detachWindowUnloadHook = function () {\n        if (this.windowUnloadHandler) {\n            window.removeEventListener('unload', this.windowUnloadHandler);\n            this.windowUnloadHandler = null;\n        }\n    };\n    /**\n     * Returns any recorded \"zombied owner\" (i.e. a previous owner that became\n     * zombied due to their tab closing) from LocalStorage, or null if no such\n     * record exists.\n     */\n    IndexedDbPersistence.prototype.getZombiedOwnerId = function () {\n        try {\n            var zombiedOwnerId = window.localStorage.getItem(this.zombiedOwnerLocalStorageKey());\n            debug(indexeddb_persistence_LOG_TAG, 'Zombied ownerID from LocalStorage:', zombiedOwnerId);\n            return zombiedOwnerId;\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            log_error(indexeddb_persistence_LOG_TAG, 'Failed to get zombie owner id.', e);\n            return null;\n        }\n    };\n    /**\n     * Records a zombied owner (an owner that had its tab closed) in LocalStorage\n     * or, if passed null, deletes any recorded zombied owner.\n     */\n    IndexedDbPersistence.prototype.setZombiedOwnerId = function (zombieOwnerId) {\n        try {\n            if (zombieOwnerId === null) {\n                window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey());\n            }\n            else {\n                window.localStorage.setItem(this.zombiedOwnerLocalStorageKey(), zombieOwnerId);\n            }\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            log_error(indexeddb_persistence_LOG_TAG, 'Failed to set zombie owner id.', e);\n        }\n    };\n    IndexedDbPersistence.prototype.zombiedOwnerLocalStorageKey = function () {\n        return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;\n    };\n    IndexedDbPersistence.prototype.generateOwnerId = function () {\n        // For convenience, just use an AutoId.\n        return misc_AutoId.newId();\n    };\n    /**\n     * The name of the main (and currently only) IndexedDB database. this name is\n     * appended to the prefix provided to the IndexedDbPersistence constructor.\n     */\n    IndexedDbPersistence.MAIN_DATABASE = 'main';\n    return IndexedDbPersistence;\n}());\n\n\n//# sourceMappingURL=indexeddb_persistence.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/local_documents_view.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nvar local_documents_view_LocalDocumentsView = /** @class */ (function () {\n    function LocalDocumentsView(remoteDocumentCache, mutationQueue) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @return Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    LocalDocumentsView.prototype.getDocument = function (transaction, key) {\n        var _this = this;\n        return this.remoteDocumentCache\n            .getEntry(transaction, key)\n            .next(function (remoteDoc) {\n            return _this.computeLocalDocument(transaction, key, remoteDoc);\n        });\n    };\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {\n        var _this = this;\n        var promises = [];\n        var results = maybeDocumentMap();\n        keys.forEach(function (key) {\n            promises.push(_this.getDocument(transaction, key).next(function (maybeDoc) {\n                // TODO(http://b/32275378): Don't conflate missing / deleted.\n                if (!maybeDoc) {\n                    maybeDoc = new document_NoDocument(key, snapshot_version_SnapshotVersion.forDeletedDoc());\n                }\n                results = results.insert(key, maybeDoc);\n            }));\n        });\n        return persistence_promise_PersistencePromise.waitFor(promises).next(function () { return results; });\n    };\n    /** Performs a query against the local view of all documents. */\n    LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        if (document_key_DocumentKey.isDocumentKey(query.path)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query);\n        }\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new document_key_DocumentKey(docPath)).next(function (maybeDoc) {\n            var result = documentMap();\n            if (maybeDoc instanceof document_Document) {\n                result = result.insert(maybeDoc.key, maybeDoc);\n            }\n            return result;\n        });\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {\n        var _this = this;\n        // Query the remote documents and overlay mutations.\n        // TODO(mikelehen): There may be significant overlap between the mutations\n        // affecting these remote documents and the\n        // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n        var results;\n        return this.remoteDocumentCache\n            .getDocumentsMatchingQuery(transaction, query)\n            .next(function (queryResults) {\n            return _this.computeLocalDocuments(transaction, queryResults);\n        })\n            .next(function (promisedResults) {\n            results = promisedResults;\n            // Now use the mutation queue to discover any other documents that may\n            // match the query after applying mutations.\n            return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);\n        })\n            .next(function (matchingMutationBatches) {\n            var matchingKeys = documentKeySet();\n            for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {\n                var batch = matchingMutationBatches_1[_i];\n                for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                    var mutation = _b[_a];\n                    // TODO(mikelehen): PERF: Check if this mutation actually\n                    // affects the query to reduce work.\n                    if (!results.get(mutation.key)) {\n                        matchingKeys = matchingKeys.add(mutation.key);\n                    }\n                }\n            }\n            // Now add in the results for the matchingKeys.\n            var promises = [];\n            matchingKeys.forEach(function (key) {\n                promises.push(_this.getDocument(transaction, key).next(function (doc) {\n                    if (doc instanceof document_Document) {\n                        results = results.insert(doc.key, doc);\n                    }\n                }));\n            });\n            return persistence_promise_PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            // Finally, filter out any documents that don't actually match\n            // the query.\n            results.forEach(function (key, doc) {\n                if (!query.matches(doc)) {\n                    results = results.remove(key);\n                }\n            });\n            return results;\n        });\n    };\n    /**\n     * Takes a remote document and applies local mutations to generate the local\n     * view of the document.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the document (necessary when remoteDocument\n     *     is null).\n     * @param document The base remote document to apply mutations to or null.\n     */\n    LocalDocumentsView.prototype.computeLocalDocument = function (transaction, documentKey, document) {\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKey(transaction, documentKey)\n            .next(function (batches) {\n            for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n                var batch = batches_1[_i];\n                document = batch.applyToLocalView(documentKey, document);\n            }\n            return document;\n        });\n    };\n    /**\n     * Takes a set of remote documents and applies local mutations to generate the\n     * local view of the documents.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documents The base remote documents to apply mutations to.\n     * @return The local view of the documents.\n     */\n    LocalDocumentsView.prototype.computeLocalDocuments = function (transaction, documents) {\n        var _this = this;\n        var promises = [];\n        documents.forEach(function (key, doc) {\n            promises.push(_this.computeLocalDocument(transaction, key, doc).next(function (mutatedDoc) {\n                if (mutatedDoc instanceof document_Document) {\n                    documents = documents.insert(mutatedDoc.key, mutatedDoc);\n                }\n                else if (mutatedDoc instanceof document_NoDocument) {\n                    documents = documents.remove(mutatedDoc.key);\n                }\n                else {\n                    fail('Unknown MaybeDocument: ' + mutatedDoc);\n                }\n            }));\n        });\n        return persistence_promise_PersistencePromise.waitFor(promises).next(function () { return documents; });\n    };\n    return LocalDocumentsView;\n}());\n\n\n//# sourceMappingURL=local_documents_view.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/remote_document_change_buffer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * NOTE: This class was introduced in iOS to work around a limitation in\n * LevelDB. Given IndexedDb has full transaction support with\n * read-your-own-writes capability, this class is not technically needed, but\n * has been preserved as a convenience and to aid portability.\n */\nvar remote_document_change_buffer_RemoteDocumentChangeBuffer = /** @class */ (function () {\n    function RemoteDocumentChangeBuffer(remoteDocumentCache) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.changes = maybeDocumentMap();\n    }\n    /** Buffers a `RemoteDocumentCache.addEntry()` call. */\n    RemoteDocumentChangeBuffer.prototype.addEntry = function (maybeDocument) {\n        var changes = this.assertChanges();\n        this.changes = changes.insert(maybeDocument.key, maybeDocument);\n    };\n    // NOTE: removeEntry() is not presently necessary and so is omitted.\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the entry to look up.\n     * @return The cached Document or NoDocument entry, or null if we have nothing\n     * cached.\n     */\n    RemoteDocumentChangeBuffer.prototype.getEntry = function (transaction, documentKey) {\n        var changes = this.assertChanges();\n        var bufferedEntry = changes.get(documentKey);\n        if (bufferedEntry) {\n            return persistence_promise_PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.remoteDocumentCache.getEntry(transaction, documentKey);\n        }\n    };\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    RemoteDocumentChangeBuffer.prototype.apply = function (transaction) {\n        var _this = this;\n        var changes = this.assertChanges();\n        var promises = [];\n        changes.forEach(function (key, maybeDoc) {\n            promises.push(_this.remoteDocumentCache.addEntry(transaction, maybeDoc));\n        });\n        // We should not be used to buffer any more changes.\n        this.changes = null;\n        return persistence_promise_PersistencePromise.waitFor(promises);\n    };\n    /** Helper to assert this.changes is not null and return it. */\n    RemoteDocumentChangeBuffer.prototype.assertChanges = function () {\n        assert(this.changes !== null, 'Changes have already been applied.');\n        return this.changes;\n    };\n    return RemoteDocumentChangeBuffer;\n}());\n\n\n//# sourceMappingURL=remote_document_change_buffer.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/local_store.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar local_store_LOG_TAG = 'LocalStore';\n/**\n * Local storage in the Firestore client. Coordinates persistence components\n * like the mutation queue and remote document cache to present a\n * latency-compensated view of stored data.\n *\n * The LocalStore is responsible for accepting mutations from the Sync Engine.\n * Writes from the client are put into a queue as provisional Mutations until\n * they are processed by the RemoteStore and confirmed as having been written\n * to the server.\n *\n * The local store provides the local version of documents that have been\n * modified locally. It maintains the constraint:\n *\n *   LocalDocument = RemoteDocument + Active(LocalMutations)\n *\n * (Active mutations are those that are enqueued and have not been previously\n * acknowledged or rejected).\n *\n * The RemoteDocument (\"ground truth\") state is provided via the\n * applyChangeBatch method. It will be some version of a server-provided\n * document OR will be a server-provided document PLUS acknowledged mutations:\n *\n *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)\n *\n * Note that this \"dirty\" version of a RemoteDocument will not be identical to a\n * server base version, since it has LocalMutations added to it pending getting\n * an authoritative copy from the server.\n *\n * Since LocalMutations can be rejected by the server, we have to be able to\n * revert a LocalMutation that has already been applied to the LocalDocument\n * (typically done by replaying all remaining LocalMutations to the\n * RemoteDocument to re-apply).\n *\n * The LocalStore is responsible for the garbage collection of the documents it\n * contains. For now, it every doc referenced by a view, the mutation queue, or\n * the RemoteStore.\n *\n * It also maintains the persistence of mapping queries to resume tokens and\n * target ids. It needs to know this data about queries to properly know what\n * docs it would be allowed to garbage collect.\n *\n * The LocalStore must be able to efficiently execute queries against its local\n * cache of the documents, to provide the initial set of results before any\n * remote changes have been received.\n *\n * Note: In TypeScript, most methods return Promises since the implementation\n * may rely on fetching data from IndexedDB which is async.\n * These Promises will only be rejected on an I/O error or other internal\n * (unexpected) failure (e.g. failed assert) and always represent an\n * unrecoverable error (should be caught / reported by the async_queue).\n */\nvar local_store_LocalStore = /** @class */ (function () {\n    function LocalStore(\n        /** Manages our in-memory or durable persistence. */\n        persistence, initialUser, \n        /**\n           * The garbage collector collects documents that should no longer be\n           * cached (e.g. if they are no longer retained by the above reference sets\n           * and the garbage collector is performing eager collection).\n           */\n        garbageCollector) {\n        this.persistence = persistence;\n        this.garbageCollector = garbageCollector;\n        /**\n         * The set of document references maintained by any local views.\n         */\n        this.localViewReferences = new reference_set_ReferenceSet();\n        /** Maps a targetID to data about its query. */\n        this.targetIds = {};\n        /** Used to generate targetIDs for queries tracked locally. */\n        this.targetIdGenerator = TargetIdGenerator.forLocalStore();\n        /**\n         * A heldBatchResult is a mutation batch result (from a write acknowledgement)\n         * that arrived before the watch stream got notified of a snapshot that\n         * includes the write. So we \"hold\" it until the watch stream catches up. It\n         * ensures that the local write remains visible (latency compensation) and\n         * doesn't temporarily appear reverted because the watch stream is slower than\n         * the write stream and so wasn't reflecting it.\n         *\n         * NOTE: Eventually we want to move this functionality into the remote store.\n         */\n        this.heldBatchResults = [];\n        this.mutationQueue = persistence.getMutationQueue(initialUser);\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\n        this.queryCache = persistence.getQueryCache();\n        this.localDocuments = new local_documents_view_LocalDocumentsView(this.remoteDocuments, this.mutationQueue);\n        this.garbageCollector.addGarbageSource(this.localViewReferences);\n        this.garbageCollector.addGarbageSource(this.queryCache);\n        this.garbageCollector.addGarbageSource(this.mutationQueue);\n    }\n    /** Performs any initial startup actions required by the local store. */\n    LocalStore.prototype.start = function () {\n        var _this = this;\n        return this.persistence.runTransaction('Start LocalStore', function (txn) {\n            return _this.startMutationQueue(txn).next(function () { return _this.startQueryCache(txn); });\n        });\n    };\n    /**\n     * Tells the LocalStore that the currently authenticated user has changed.\n     *\n     * In response the local store switches the mutation queue to the new user and\n     * returns any resulting document changes.\n     */\n    LocalStore.prototype.handleUserChange = function (user) {\n        var _this = this;\n        return this.persistence.runTransaction('Handle user change', function (txn) {\n            // Swap out the mutation queue, grabbing the pending mutation batches\n            // before and after.\n            var oldBatches;\n            return _this.mutationQueue\n                .getAllMutationBatches(txn)\n                .next(function (promisedOldBatches) {\n                oldBatches = promisedOldBatches;\n                _this.garbageCollector.removeGarbageSource(_this.mutationQueue);\n                _this.mutationQueue = _this.persistence.getMutationQueue(user);\n                _this.garbageCollector.addGarbageSource(_this.mutationQueue);\n                return _this.startMutationQueue(txn);\n            })\n                .next(function () {\n                // Recreate our LocalDocumentsView using the new\n                // MutationQueue.\n                _this.localDocuments = new local_documents_view_LocalDocumentsView(_this.remoteDocuments, _this.mutationQueue);\n                return _this.mutationQueue.getAllMutationBatches(txn);\n            })\n                .next(function (newBatches) {\n                // Union the old/new changed keys.\n                var changedKeys = documentKeySet();\n                for (var _i = 0, _a = [oldBatches, newBatches]; _i < _a.length; _i++) {\n                    var batches = _a[_i];\n                    for (var _b = 0, batches_1 = batches; _b < batches_1.length; _b++) {\n                        var batch = batches_1[_b];\n                        for (var _c = 0, _d = batch.mutations; _c < _d.length; _c++) {\n                            var mutation = _d[_c];\n                            changedKeys = changedKeys.add(mutation.key);\n                        }\n                    }\n                }\n                // Return the set of all (potentially) changed documents as the\n                // result of the user change.\n                return _this.localDocuments.getDocuments(txn, changedKeys);\n            });\n        });\n    };\n    LocalStore.prototype.startQueryCache = function (txn) {\n        var _this = this;\n        return this.queryCache.start(txn).next(function () {\n            var targetId = _this.queryCache.getHighestTargetId();\n            _this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);\n        });\n    };\n    LocalStore.prototype.startMutationQueue = function (txn) {\n        var _this = this;\n        return this.mutationQueue\n            .start(txn)\n            .next(function () {\n            // If we have any leftover mutation batch results from a prior run,\n            // just drop them.\n            // TODO(http://b/33446471): We probably need to repopulate\n            // heldBatchResults or similar instead, but that is not\n            // straightforward since we're not persisting the write ack versions.\n            _this.heldBatchResults = [];\n            return _this.mutationQueue.getHighestAcknowledgedBatchId(txn);\n        })\n            .next(function (highestAck) {\n            // TODO(mikelehen): This is the only usage of\n            // getAllMutationBatchesThroughBatchId(). Consider removing it in\n            // favor of a getAcknowledgedBatches() method.\n            if (highestAck !== BATCHID_UNKNOWN) {\n                return _this.mutationQueue.getAllMutationBatchesThroughBatchId(txn, highestAck);\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve([]);\n            }\n        })\n            .next(function (ackedBatches) {\n            if (ackedBatches.length > 0) {\n                return _this.mutationQueue.removeMutationBatches(txn, ackedBatches);\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n        });\n    };\n    /* Accept locally generated Mutations and commit them to storage. */\n    LocalStore.prototype.localWrite = function (mutations) {\n        var _this = this;\n        return this.persistence.runTransaction('Locally write mutations', function (txn) {\n            var batch;\n            var localWriteTime = timestamp_Timestamp.now();\n            return _this.mutationQueue\n                .addMutationBatch(txn, localWriteTime, mutations)\n                .next(function (promisedBatch) {\n                batch = promisedBatch;\n                // TODO(koss): This is doing an N^2 update by replaying ALL the\n                // mutations on each document (instead of just the ones added) in\n                // this batch.\n                var keys = batch.keys();\n                return _this.localDocuments.getDocuments(txn, keys);\n            })\n                .next(function (changedDocuments) {\n                return { batchId: batch.batchId, changes: changedDocuments };\n            });\n        });\n    };\n    /**\n     * Acknowledge the given batch.\n     *\n     * On the happy path when a batch is acknowledged, the local store will\n     *\n     *  + remove the batch from the mutation queue;\n     *  + apply the changes to the remote document cache;\n     *  + recalculate the latency compensated view implied by those changes (there\n     *    may be mutations in the queue that affect the documents but haven't been\n     *    acknowledged yet); and\n     *  + give the changed documents back the sync engine\n     *\n     * @returns The resulting (modified) documents.\n     */\n    LocalStore.prototype.acknowledgeBatch = function (batchResult) {\n        var _this = this;\n        return this.persistence.runTransaction('Acknowledge batch', function (txn) {\n            var affected;\n            return _this.mutationQueue\n                .acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken)\n                .next(function () {\n                if (_this.shouldHoldBatchResult(batchResult.commitVersion)) {\n                    _this.heldBatchResults.push(batchResult);\n                    affected = documentKeySet();\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n                else {\n                    var documentBuffer_1 = new remote_document_change_buffer_RemoteDocumentChangeBuffer(_this.remoteDocuments);\n                    return _this.releaseBatchResults(txn, [batchResult], documentBuffer_1).next(function (promisedAffectedKeys) {\n                        affected = promisedAffectedKeys;\n                        return documentBuffer_1.apply(txn);\n                    });\n                }\n            })\n                .next(function () {\n                return _this.mutationQueue.performConsistencyCheck(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, affected);\n            });\n        });\n    };\n    /**\n     * Remove mutations from the MutationQueue for the specified batch;\n     * LocalDocuments will be recalculated.\n     *\n     * @returns The resulting modified documents.\n     */\n    LocalStore.prototype.rejectBatch = function (batchId) {\n        var _this = this;\n        return this.persistence.runTransaction('Reject batch', function (txn) {\n            var toReject;\n            var affectedKeys;\n            return _this.mutationQueue\n                .lookupMutationBatch(txn, batchId)\n                .next(function (promisedToReject) {\n                assert(promisedToReject != null, 'Attempt to reject nonexistent batch!');\n                toReject = promisedToReject;\n                return _this.mutationQueue\n                    .getHighestAcknowledgedBatchId(txn)\n                    .next(function (lastAcked) {\n                    assert(batchId > lastAcked, \"Acknowledged batches can't be rejected.\");\n                    return toReject;\n                });\n            })\n                .next(function () {\n                return _this.removeMutationBatch(txn, toReject);\n            })\n                .next(function (promisedAffectedKeys) {\n                affectedKeys = promisedAffectedKeys;\n                return _this.mutationQueue.performConsistencyCheck(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, affectedKeys);\n            });\n        });\n    };\n    /** Returns the last recorded stream token for the current user. */\n    LocalStore.prototype.getLastStreamToken = function () {\n        var _this = this;\n        return this.persistence.runTransaction('Get last stream token', function (txn) {\n            return _this.mutationQueue.getLastStreamToken(txn);\n        });\n    };\n    /**\n     * Sets the stream token for the current user without acknowledging any\n     * mutation batch. This is usually only useful after a stream handshake or in\n     * response to an error that requires clearing the stream token.\n     */\n    LocalStore.prototype.setLastStreamToken = function (streamToken) {\n        var _this = this;\n        return this.persistence.runTransaction('Set last stream token', function (txn) {\n            return _this.mutationQueue.setLastStreamToken(txn, streamToken);\n        });\n    };\n    /**\n     * Returns the last consistent snapshot processed (used by the RemoteStore to\n     * determine whether to buffer incoming snapshots from the backend).\n     */\n    LocalStore.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.queryCache.getLastRemoteSnapshotVersion();\n    };\n    /**\n     * Update the \"ground-state\" (remote) documents. We assume that the remote\n     * event reflects any write batches that have been acknowledged or rejected\n     * (i.e. we do not re-apply local mutations to updates from this event).\n     *\n     * LocalDocuments are re-calculated if there are remaining mutations in the\n     * queue.\n     */\n    LocalStore.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        var documentBuffer = new remote_document_change_buffer_RemoteDocumentChangeBuffer(this.remoteDocuments);\n        return this.persistence.runTransaction('Apply remote event', function (txn) {\n            var promises = [];\n            forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                // Do not ref/unref unassigned targetIds - it may lead to leaks.\n                var queryData = _this.targetIds[targetId];\n                if (!queryData)\n                    return;\n                var mapping = change.mapping;\n                if (mapping) {\n                    // First make sure that all references are deleted\n                    if (mapping instanceof ResetMapping) {\n                        promises.push(_this.queryCache\n                            .removeMatchingKeysForTargetId(txn, targetId)\n                            .next(function () {\n                            return _this.queryCache.addMatchingKeys(txn, mapping.documents, targetId);\n                        }));\n                    }\n                    else if (mapping instanceof UpdateMapping) {\n                        promises.push(_this.queryCache\n                            .removeMatchingKeys(txn, mapping.removedDocuments, targetId)\n                            .next(function () {\n                            return _this.queryCache.addMatchingKeys(txn, mapping.addedDocuments, targetId);\n                        }));\n                    }\n                    else {\n                        return fail('Unknown mapping type: ' + JSON.stringify(mapping));\n                    }\n                }\n                // Update the resume token if the change includes one. Don't clear\n                // any preexisting value.\n                var resumeToken = change.resumeToken;\n                if (resumeToken.length > 0) {\n                    queryData = queryData.update({\n                        resumeToken: resumeToken,\n                        snapshotVersion: change.snapshotVersion\n                    });\n                    _this.targetIds[targetId] = queryData;\n                    promises.push(_this.queryCache.addQueryData(txn, queryData));\n                }\n            });\n            var changedDocKeys = documentKeySet();\n            remoteEvent.documentUpdates.forEach(function (key, doc) {\n                changedDocKeys = changedDocKeys.add(key);\n                promises.push(documentBuffer.getEntry(txn, key).next(function (existingDoc) {\n                    // Make sure we don't apply an old document version to the remote\n                    // cache, though we make an exception for SnapshotVersion.MIN which\n                    // can happen for manufactured events (e.g. in the case of a limbo\n                    // document resolution failing).\n                    if (existingDoc == null ||\n                        doc.version.equals(snapshot_version_SnapshotVersion.MIN) ||\n                        doc.version.compareTo(existingDoc.version) >= 0) {\n                        documentBuffer.addEntry(doc);\n                    }\n                    else {\n                        debug(local_store_LOG_TAG, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n                    }\n                    // The document might be garbage because it was unreferenced by\n                    // everything. Make sure to mark it as garbage if it is...\n                    _this.garbageCollector.addPotentialGarbageKey(key);\n                }));\n            });\n            // HACK: The only reason we allow a null snapshot version is so that we\n            // can synthesize remote events when we get permission denied errors while\n            // trying to resolve the state of a locally cached document that is in\n            // limbo.\n            var lastRemoteVersion = _this.queryCache.getLastRemoteSnapshotVersion();\n            var remoteVersion = remoteEvent.snapshotVersion;\n            if (!remoteVersion.equals(snapshot_version_SnapshotVersion.MIN)) {\n                assert(remoteVersion.compareTo(lastRemoteVersion) >= 0, 'Watch stream reverted to previous snapshot?? ' +\n                    remoteVersion +\n                    ' < ' +\n                    lastRemoteVersion);\n                promises.push(_this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion));\n            }\n            var releasedWriteKeys;\n            return persistence_promise_PersistencePromise.waitFor(promises)\n                .next(function () { return _this.releaseHeldBatchResults(txn, documentBuffer); })\n                .next(function (promisedReleasedWriteKeys) {\n                releasedWriteKeys = promisedReleasedWriteKeys;\n                return documentBuffer.apply(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, changedDocKeys.unionWith(releasedWriteKeys));\n            });\n        });\n    };\n    /**\n     * Notify local store of the changed views to locally pin documents.\n     */\n    LocalStore.prototype.notifyLocalViewChanges = function (viewChanges) {\n        var _this = this;\n        return this.persistence.runTransaction('Notify local view changes', function (txn) {\n            var promises = [];\n            var _loop_1 = function (view) {\n                promises.push(_this.queryCache\n                    .getQueryData(txn, view.query)\n                    .next(function (queryData) {\n                    assert(queryData !== null, 'Local view changes contain unallocated query.');\n                    var targetId = queryData.targetId;\n                    _this.localViewReferences.addReferences(view.addedKeys, targetId);\n                    _this.localViewReferences.removeReferences(view.removedKeys, targetId);\n                }));\n            };\n            for (var _i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {\n                var view = viewChanges_1[_i];\n                _loop_1(view);\n            }\n            return persistence_promise_PersistencePromise.waitFor(promises);\n        });\n    };\n    /**\n     * Gets the mutation batch after the passed in batchId in the mutation queue\n     *  or null if empty.\n     *  @param afterBatchId If provided, the batch to search after.\n     *  @returns The next mutation or null if there wasn't one.\n     */\n    LocalStore.prototype.nextMutationBatch = function (afterBatchId) {\n        var _this = this;\n        return this.persistence.runTransaction('Get next mutation batch', function (txn) {\n            if (afterBatchId === undefined) {\n                afterBatchId = BATCHID_UNKNOWN;\n            }\n            return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n        });\n    };\n    /**\n     * Read the current value of a Document with a given key or null if not\n     * found - used for testing.\n     */\n    LocalStore.prototype.readDocument = function (key) {\n        var _this = this;\n        return this.persistence.runTransaction('read document', function (txn) {\n            return _this.localDocuments.getDocument(txn, key);\n        });\n    };\n    /**\n     * Assigns the given query an internal ID so that its results can be pinned so\n     * they don't get GC'd. A query must be allocated in the local store before\n     * the store can be used to manage its view.\n     */\n    LocalStore.prototype.allocateQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Allocate query', function (txn) {\n            var queryData;\n            return _this.queryCache\n                .getQueryData(txn, query)\n                .next(function (cached) {\n                if (cached) {\n                    // This query has been listened to previously, so reuse the\n                    // previous targetID.\n                    // TODO(mcg): freshen last accessed date?\n                    queryData = cached;\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n                else {\n                    var targetId = _this.targetIdGenerator.next();\n                    queryData = new query_data_QueryData(query, targetId, QueryPurpose.Listen);\n                    return _this.queryCache.addQueryData(txn, queryData);\n                }\n            })\n                .next(function () {\n                assert(!_this.targetIds[queryData.targetId], 'Tried to allocate an already allocated query: ' + query);\n                _this.targetIds[queryData.targetId] = queryData;\n                return queryData;\n            });\n        });\n    };\n    /** Unpin all the documents associated with the given query. */\n    LocalStore.prototype.releaseQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Release query', function (txn) {\n            return _this.queryCache\n                .getQueryData(txn, query)\n                .next(function (queryData) {\n                assert(queryData != null, 'Tried to release nonexistent query: ' + query);\n                _this.localViewReferences.removeReferencesForId(queryData.targetId);\n                delete _this.targetIds[queryData.targetId];\n                if (_this.garbageCollector.isEager) {\n                    return _this.queryCache.removeQueryData(txn, queryData);\n                }\n                else {\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n            })\n                .next(function () {\n                // If this was the last watch target, then we won't get any more\n                // watch snapshots, so we should release any held batch results.\n                if (isEmpty(_this.targetIds)) {\n                    var documentBuffer_2 = new remote_document_change_buffer_RemoteDocumentChangeBuffer(_this.remoteDocuments);\n                    return _this.releaseHeldBatchResults(txn, documentBuffer_2).next(function () {\n                        documentBuffer_2.apply(txn);\n                    });\n                }\n                else {\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n            });\n        });\n    };\n    /**\n     * Runs the specified query against all the documents in the local store and\n     * returns the results.\n     */\n    LocalStore.prototype.executeQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Execute query', function (txn) {\n            return _this.localDocuments.getDocumentsMatchingQuery(txn, query);\n        });\n    };\n    /**\n     * Returns the keys of the documents that are associated with the given\n     * target id in the remote table.\n     */\n    LocalStore.prototype.remoteDocumentKeys = function (targetId) {\n        var _this = this;\n        return this.persistence.runTransaction('Remote document keys', function (txn) {\n            return _this.queryCache.getMatchingKeysForTargetId(txn, targetId);\n        });\n    };\n    /**\n     * Collect garbage if necessary.\n     * Should be called periodically by Sync Engine to recover resources. The\n     * implementation must guarantee that GC won't happen in other places than\n     * this method call.\n     */\n    LocalStore.prototype.collectGarbage = function () {\n        var _this = this;\n        // Call collectGarbage regardless of whether isGCEnabled so the referenceSet\n        // doesn't continue to accumulate the garbage keys.\n        return this.persistence.runTransaction('Garbage collection', function (txn) {\n            return _this.garbageCollector.collectGarbage(txn).next(function (garbage) {\n                var promises = [];\n                garbage.forEach(function (key) {\n                    promises.push(_this.remoteDocuments.removeEntry(txn, key));\n                });\n                return persistence_promise_PersistencePromise.waitFor(promises);\n            });\n        });\n    };\n    LocalStore.prototype.releaseHeldBatchResults = function (txn, documentBuffer) {\n        var toRelease = [];\n        for (var _i = 0, _a = this.heldBatchResults; _i < _a.length; _i++) {\n            var batchResult = _a[_i];\n            if (!this.isRemoteUpToVersion(batchResult.commitVersion)) {\n                break;\n            }\n            toRelease.push(batchResult);\n        }\n        if (toRelease.length === 0) {\n            return persistence_promise_PersistencePromise.resolve(documentKeySet());\n        }\n        else {\n            this.heldBatchResults.splice(0, toRelease.length);\n            return this.releaseBatchResults(txn, toRelease, documentBuffer);\n        }\n    };\n    LocalStore.prototype.isRemoteUpToVersion = function (version) {\n        // If there are no watch targets, then we won't get remote snapshots, and\n        // we are always \"up-to-date.\"\n        var lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n        return (version.compareTo(lastRemoteVersion) <= 0 ||\n            isEmpty(this.targetIds));\n    };\n    LocalStore.prototype.shouldHoldBatchResult = function (version) {\n        // Check if watcher isn't up to date or prior results are already held.\n        return (!this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0);\n    };\n    LocalStore.prototype.releaseBatchResults = function (txn, batchResults, documentBuffer) {\n        var _this = this;\n        var promiseChain = persistence_promise_PersistencePromise.resolve();\n        var _loop_2 = function (batchResult) {\n            promiseChain = promiseChain.next(function () {\n                return _this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer);\n            });\n        };\n        for (var _i = 0, batchResults_1 = batchResults; _i < batchResults_1.length; _i++) {\n            var batchResult = batchResults_1[_i];\n            _loop_2(batchResult);\n        }\n        return promiseChain.next(function () {\n            return _this.removeMutationBatches(txn, batchResults.map(function (result) { return result.batch; }));\n        });\n    };\n    LocalStore.prototype.removeMutationBatch = function (txn, batch) {\n        return this.removeMutationBatches(txn, [batch]);\n    };\n    /** Removes all the mutation batches named in the given array. */\n    LocalStore.prototype.removeMutationBatches = function (txn, batches) {\n        var affectedDocs = documentKeySet();\n        for (var _i = 0, batches_2 = batches; _i < batches_2.length; _i++) {\n            var batch = batches_2[_i];\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                affectedDocs = affectedDocs.add(key);\n            }\n        }\n        return this.mutationQueue\n            .removeMutationBatches(txn, batches)\n            .next(function () { return affectedDocs; });\n    };\n    LocalStore.prototype.applyWriteToRemoteDocuments = function (txn, batchResult, documentBuffer) {\n        var batch = batchResult.batch;\n        var docKeys = batch.keys();\n        var promiseChain = persistence_promise_PersistencePromise.resolve();\n        docKeys.forEach(function (docKey) {\n            promiseChain = promiseChain\n                .next(function () {\n                return documentBuffer.getEntry(txn, docKey);\n            })\n                .next(function (remoteDoc) {\n                var doc = remoteDoc;\n                var ackVersion = batchResult.docVersions.get(docKey);\n                assert(ackVersion !== null, 'ackVersions should contain every doc in the write.');\n                if (!doc || doc.version.compareTo(ackVersion) < 0) {\n                    doc = batch.applyToRemoteDocument(docKey, doc, batchResult);\n                    if (!doc) {\n                        assert(!remoteDoc, 'Mutation batch ' +\n                            batch +\n                            ' applied to document ' +\n                            remoteDoc +\n                            ' resulted in null');\n                    }\n                    else {\n                        documentBuffer.addEntry(doc);\n                    }\n                }\n            });\n        });\n        return promiseChain;\n    };\n    return LocalStore;\n}());\n\n\n//# sourceMappingURL=local_store.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/memory_mutation_queue.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\nvar memory_mutation_queue_MemoryMutationQueue = /** @class */ (function () {\n    function MemoryMutationQueue() {\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** The highest acknowledged mutation in the queue. */\n        this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        /** The last received stream token from the server, used to acknowledge which\n         * responses the client has processed. Stream tokens are opaque checkpoint\n         * markers whose only real value is their inclusion in the next request.\n         */\n        this.lastStreamToken = emptyByteString();\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new sorted_set_SortedSet(reference_set_DocReference.compareByKey);\n    }\n    MemoryMutationQueue.prototype.start = function (transaction) {\n        // NOTE: The queue may be shutdown / started multiple times, since we\n        // maintain the queue for the duration of the app session in case a user\n        // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n        // accommodate tests that expect as much), we reset nextBatchId and\n        // highestAcknowledgedBatchId if the queue is empty.\n        if (this.mutationQueue.length === 0) {\n            this.nextBatchId = 1;\n            this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        }\n        assert(this.highestAcknowledgedBatchId < this.nextBatchId, 'highestAcknowledgedBatchId must be less than the nextBatchId');\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.checkEmpty = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.mutationQueue.length === 0);\n    };\n    MemoryMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.nextBatchId);\n    };\n    MemoryMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n    };\n    MemoryMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.highestAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        var batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');\n        // Verify that the batch in the queue is the one to be acknowledged.\n        var check = this.mutationQueue[batchIndex];\n        assert(batchId === check.batchId, 'Queue ordering failure: expected batch ' +\n            batchId +\n            ', got batch ' +\n            check.batchId);\n        assert(!check.isTombstone(), \"Can't acknowledge a previously removed batch\");\n        this.highestAcknowledgedBatchId = batchId;\n        this.lastStreamToken = streamToken;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.lastStreamToken);\n    };\n    MemoryMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.lastStreamToken = streamToken;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        assert(mutations.length !== 0, 'Mutation batches should not be empty');\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            var prior = this.mutationQueue[this.mutationQueue.length - 1];\n            assert(prior.batchId < batchId, 'Mutation batchIDs must be monotonically increasing order');\n        }\n        var batch = new mutation_batch_MutationBatch(batchId, localWriteTime, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key.\n        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n            var mutation = mutations_1[_i];\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new reference_set_DocReference(mutation.key, batchId));\n        }\n        return persistence_promise_PersistencePromise.resolve(batch);\n    };\n    MemoryMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        return persistence_promise_PersistencePromise.resolve(this.findMutationBatch(batchId));\n    };\n    MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var size = this.mutationQueue.length;\n        // All batches with batchId <= this.highestAcknowledgedBatchId have been\n        // acknowledged so the first unacknowledged batch after batchID will have a\n        // batchID larger than both of these values.\n        batchId = Math.max(batchId + 1, this.highestAcknowledgedBatchId);\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        var rawIndex = this.indexOfBatchId(batchId);\n        var index = rawIndex < 0 ? 0 : rawIndex;\n        // Finally return the first non-tombstone batch.\n        for (; index < size; index++) {\n            var batch = this.mutationQueue[index];\n            if (!batch.isTombstone()) {\n                return persistence_promise_PersistencePromise.resolve(batch);\n            }\n        }\n        return persistence_promise_PersistencePromise.resolve(null);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var count = this.mutationQueue.length;\n        var endIndex = this.indexOfBatchId(batchId);\n        if (endIndex < 0) {\n            endIndex = 0;\n        }\n        else if (endIndex >= count) {\n            endIndex = count;\n        }\n        else {\n            // The endIndex is in the queue so increment to pull everything in the\n            // queue including it.\n            endIndex++;\n        }\n        return persistence_promise_PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(endIndex));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        var start = new reference_set_DocReference(documentKey, 0);\n        var end = new reference_set_DocReference(documentKey, Number.POSITIVE_INFINITY);\n        var result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {\n            assert(documentKey.equals(ref.key), \"Should only iterate over a single key's batches\");\n            var batch = _this.findMutationBatch(ref.targetOrBatchId);\n            assert(batch !== null, 'Batches in the index must exist in the main table');\n            result.push(batch);\n        });\n        return persistence_promise_PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        var prefix = query.path;\n        var immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        var startPath = prefix;\n        if (!document_key_DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        var start = new reference_set_DocReference(new document_key_DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        var uniqueBatchIDs = new sorted_set_SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(function (ref) {\n            var rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        var result = [];\n        uniqueBatchIDs.forEach(function (batchId) {\n            var batch = _this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return persistence_promise_PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var batchCount = batches.length;\n        assert(batchCount > 0, 'Should not remove mutations when none exist.');\n        var firstBatchId = batches[0].batchId;\n        var queueCount = this.mutationQueue.length;\n        // Find the position of the first batch for removal. This need not be the\n        // first entry in the queue.\n        var startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n        assert(this.mutationQueue[startIndex].batchId === firstBatchId, 'Removed batches must exist in the queue');\n        // Check that removed batches are contiguous (while excluding tombstones).\n        var batchIndex = 1;\n        var queueIndex = startIndex + 1;\n        while (batchIndex < batchCount && queueIndex < queueCount) {\n            var batch = this.mutationQueue[queueIndex];\n            if (batch.isTombstone()) {\n                queueIndex++;\n                continue;\n            }\n            assert(batch.batchId === batches[batchIndex].batchId, 'Removed batches must be contiguous in the queue');\n            batchIndex++;\n            queueIndex++;\n        }\n        // Only actually remove batches if removing at the front of the queue.\n        // Previously rejected batches may have left tombstones in the queue, so\n        // expand the removal range to include any tombstones.\n        if (startIndex === 0) {\n            for (; queueIndex < queueCount; queueIndex++) {\n                var batch = this.mutationQueue[queueIndex];\n                if (!batch.isTombstone()) {\n                    break;\n                }\n            }\n            var length_1 = queueIndex - startIndex;\n            this.mutationQueue.splice(startIndex, length_1);\n        }\n        else {\n            // Mark the tombstones\n            for (var i = startIndex; i < queueIndex; i++) {\n                this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n            }\n        }\n        var references = this.batchesByDocumentKey;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            var batchId = batch.batchId;\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                if (this.garbageCollector !== null) {\n                    this.garbageCollector.addPotentialGarbageKey(key);\n                }\n                var ref = new reference_set_DocReference(key, batchId);\n                references = references.delete(ref);\n            }\n        }\n        this.batchesByDocumentKey = references;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    MemoryMutationQueue.prototype.containsKey = function (txn, key) {\n        var ref = new reference_set_DocReference(key, 0);\n        var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return persistence_promise_PersistencePromise.resolve(key.equals(firstRef && firstRef.key));\n    };\n    MemoryMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        if (this.mutationQueue.length === 0) {\n            assert(this.batchesByDocumentKey.isEmpty(), 'Document leak -- detected dangling mutation references when queue is empty.');\n        }\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    /**\n     * A private helper that collects all the mutations batches in the queue up to\n     * but not including the given endIndex. All tombstones in the queue are\n     * excluded.\n     */\n    MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function (endIndex) {\n        var result = [];\n        for (var i = 0; i < endIndex; i++) {\n            var batch = this.mutationQueue[i];\n            if (!batch.isTombstone()) {\n                result.push(batch);\n            }\n        }\n        return result;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId The batchId to search for\n     * @param action A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    MemoryMutationQueue.prototype.indexOfExistingBatchId = function (batchId, action) {\n        var index = this.indexOfBatchId(batchId);\n        assert(index >= 0 && index < this.mutationQueue.length, 'Batches must exist to be ' + action);\n        return index;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @return The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been remvoed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    MemoryMutationQueue.prototype.indexOfBatchId = function (batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        var firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    };\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficent.\n     */\n    MemoryMutationQueue.prototype.findMutationBatch = function (batchId) {\n        var index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        var batch = this.mutationQueue[index];\n        assert(batch.batchId === batchId, 'If found batch must match');\n        return batch.isTombstone() ? null : batch;\n    };\n    return MemoryMutationQueue;\n}());\n\n\n//# sourceMappingURL=memory_mutation_queue.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/memory_query_cache.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\nvar memory_query_cache_MemoryQueryCache = /** @class */ (function () {\n    function MemoryQueryCache() {\n        /**\n         * Maps a query to the data about that query\n         */\n        this.queries = new obj_map_ObjectMap(function (q) { return q.canonicalId(); });\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.MIN;\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new reference_set_ReferenceSet();\n    }\n    MemoryQueryCache.prototype.start = function (transaction) {\n        // Nothing to do.\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    MemoryQueryCache.prototype.getHighestTargetId = function () {\n        return this.highestTargetId;\n    };\n    MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        this.queries.set(queryData.query, queryData);\n        var targetId = queryData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.highestTargetId = targetId;\n        }\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        this.queries.delete(queryData.query);\n        this.references.removeReferencesForId(queryData.targetId);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getQueryData = function (transaction, query) {\n        var queryData = this.queries.get(query) || null;\n        return persistence_promise_PersistencePromise.resolve(queryData);\n    };\n    MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var matchingKeys = this.references.referencesForId(targetId);\n        return persistence_promise_PersistencePromise.resolve(matchingKeys);\n    };\n    MemoryQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.references.setGarbageCollector(gc);\n    };\n    MemoryQueryCache.prototype.containsKey = function (txn, key) {\n        return this.references.containsKey(txn, key);\n    };\n    return MemoryQueryCache;\n}());\n\n\n//# sourceMappingURL=memory_query_cache.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/memory_remote_document_cache.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\nvar memory_remote_document_cache_MemoryRemoteDocumentCache = /** @class */ (function () {\n    function MemoryRemoteDocumentCache() {\n        this.docs = maybeDocumentMap();\n    }\n    MemoryRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        this.docs = this.docs.insert(maybeDocument.key, maybeDocument);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        this.docs = this.docs.remove(documentKey);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        return persistence_promise_PersistencePromise.resolve(this.docs.get(documentKey));\n    };\n    MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var prefix = new document_key_DocumentKey(query.path.child(''));\n        var iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            var _a = iterator.getNext(), key = _a.key, maybeDoc = _a.value;\n            if (!query.path.isPrefixOf(key.path)) {\n                break;\n            }\n            if (maybeDoc instanceof document_Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        }\n        return persistence_promise_PersistencePromise.resolve(results);\n    };\n    return MemoryRemoteDocumentCache;\n}());\n\n\n//# sourceMappingURL=memory_remote_document_cache.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/memory_persistence.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\nvar memory_persistence_LOG_TAG = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nvar memory_persistence_MemoryPersistence = /** @class */ (function () {\n    function MemoryPersistence() {\n        /**\n         * Note that these are retained here to make it easier to write tests\n         * affecting both the in-memory and IndexedDB-backed persistence layers. Tests\n         * can create a new LocalStore wrapping this Persistence instance and this\n         * will make the in-memory persistence layer behave as if it were actually\n         * persisting values.\n         */\n        this.mutationQueues = {};\n        this.remoteDocumentCache = new memory_remote_document_cache_MemoryRemoteDocumentCache();\n        this.queryCache = new memory_query_cache_MemoryQueryCache();\n        this.started = false;\n    }\n    MemoryPersistence.prototype.start = function () {\n        assert(!this.started, 'MemoryPersistence double-started!');\n        this.started = true;\n        // No durable state to read on startup.\n        return Promise.resolve();\n    };\n    MemoryPersistence.prototype.shutdown = function () {\n        // No durable state to ensure is closed on shutdown.\n        assert(this.started, 'MemoryPersistence shutdown without start!');\n        this.started = false;\n        return Promise.resolve();\n    };\n    MemoryPersistence.prototype.getMutationQueue = function (user) {\n        var queue = this.mutationQueues[user.toKey()];\n        if (!queue) {\n            queue = new memory_mutation_queue_MemoryMutationQueue();\n            this.mutationQueues[user.toKey()] = queue;\n        }\n        return queue;\n    };\n    MemoryPersistence.prototype.getQueryCache = function () {\n        return this.queryCache;\n    };\n    MemoryPersistence.prototype.getRemoteDocumentCache = function () {\n        return this.remoteDocumentCache;\n    };\n    MemoryPersistence.prototype.runTransaction = function (action, operation) {\n        debug(memory_persistence_LOG_TAG, 'Starting transaction:', action);\n        return operation(new MemoryPersistenceTransaction()).toPromise();\n    };\n    return MemoryPersistence;\n}());\n\n/** Dummy class since memory persistence doesn't actually use transactions. */\nvar MemoryPersistenceTransaction = /** @class */ (function () {\n    function MemoryPersistenceTransaction() {\n    }\n    return MemoryPersistenceTransaction;\n}());\n\n//# sourceMappingURL=memory_persistence.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/no_op_garbage_collector.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A garbage collector implementation that does absolutely nothing. It ignores\n * all addGarbageSource and addPotentialGarbageKey messages and and never\n * produces any garbage.\n */\nvar no_op_garbage_collector_NoOpGarbageCollector = /** @class */ (function () {\n    function NoOpGarbageCollector() {\n        this.isEager = false;\n    }\n    NoOpGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        // Not tracking garbage so don't track sources.\n    };\n    NoOpGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        // Not tracking garbage so don't track sources.\n    };\n    NoOpGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        // Not tracking garbage so ignore.\n    };\n    NoOpGarbageCollector.prototype.collectGarbage = function (txn) {\n        return persistence_promise_PersistencePromise.resolve(documentKeySet());\n    };\n    return NoOpGarbageCollector;\n}());\n\n\n//# sourceMappingURL=no_op_garbage_collector.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/promise.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Deferred = /** @class */ (function () {\n    function Deferred() {\n        var _this = this;\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n    }\n    return Deferred;\n}());\n\n/**\n * Takes an array of values and sequences them using the promise (or value)\n * returned by the supplied callback. The callback for each item is called\n * after the promise is resolved for the previous item.\n * The function returns a promise which is resolved after the promise for\n * the last item is resolved.\n */\nfunction sequence(values, fn, initialValue) {\n    var result = Promise.resolve(initialValue);\n    values.forEach(function (value) {\n        result = result.then(function (lastResult) { return fn(value, lastResult); });\n    });\n    return result;\n}\n\n//# sourceMappingURL=promise.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/backoff.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar backoff_LOG_TAG = 'ExponentialBackoff';\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nvar backoff_ExponentialBackoff = /** @class */ (function () {\n    function ExponentialBackoff(\n        /**\n           * The initial delay (used as the base delay on the first retry attempt).\n           * Note that jitter will still be applied, so the actual delay could be as\n           * little as 0.5*initialDelayMs.\n           */\n        initialDelayMs, \n        /**\n           * The multiplier to use to determine the extended base delay after each\n           * attempt.\n           */\n        backoffFactor, \n        /**\n           * The maximum base delay after which no further backoff is performed.\n           * Note that jitter will still be applied, so the actual delay could be as\n           * much as 1.5*maxDelayMs.\n           */\n        maxDelayMs) {\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    ExponentialBackoff.prototype.reset = function () {\n        this.currentBaseMs = 0;\n    };\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    ExponentialBackoff.prototype.resetToMax = function () {\n        this.currentBaseMs = this.maxDelayMs;\n    };\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts.\n     */\n    ExponentialBackoff.prototype.backoffAndWait = function () {\n        var def = new Deferred();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n        if (this.currentBaseMs > 0) {\n            debug(backoff_LOG_TAG, \"Backing off for \" + delayWithJitterMs + \" ms \" +\n                (\"(base delay: \" + this.currentBaseMs + \" ms)\"));\n        }\n        setTimeout(function () {\n            def.resolve();\n        }, delayWithJitterMs);\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n        return def.promise;\n    };\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    ExponentialBackoff.prototype.jitterDelayMs = function () {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    };\n    return ExponentialBackoff;\n}());\n\n\n//# sourceMappingURL=backoff.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/persistent_stream.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar persistent_stream___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar persistent_stream_LOG_TAG = 'PersistentStream';\nvar PersistentStreamState;\n(function (PersistentStreamState) {\n    /**\n     * The streaming RPC is not running and there's no error condition.\n     * Calling `start` will start the stream immediately without backoff.\n     * While in this state isStarted will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Initial\"] = 0] = \"Initial\";\n    /**\n     * The stream is starting, and is waiting for an auth token to attach to\n     * the initial request. While in this state, isStarted will return\n     * true but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Auth\"] = 1] = \"Auth\";\n    /**\n     * The streaming RPC is up and running. Requests and responses can flow\n     * freely. Both isStarted and isOpen will return true.\n     */\n    PersistentStreamState[PersistentStreamState[\"Open\"] = 2] = \"Open\";\n    /**\n     * The stream encountered an error. The next start attempt will back off.\n     * While in this state isStarted() will return false.\n     *\n     */\n    PersistentStreamState[PersistentStreamState[\"Error\"] = 3] = \"Error\";\n    /**\n     * An in-between state after an error where the stream is waiting before\n     * re-starting. After\n     * waiting is complete, the stream will try to open. While in this\n     * state isStarted() will return YES but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Backoff\"] = 4] = \"Backoff\";\n    /**\n     * The stream has been explicitly stopped; no further events will be emitted.\n     */\n    PersistentStreamState[PersistentStreamState[\"Stopped\"] = 5] = \"Stopped\";\n})(PersistentStreamState || (PersistentStreamState = {}));\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nvar BACKOFF_INITIAL_DELAY_MS = 1000;\n/** Maximum backoff time in milliseconds */\nvar BACKOFF_MAX_DELAY_MS = 60 * 1000;\nvar BACKOFF_FACTOR = 1.5;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nvar persistent_stream_PersistentStream = /** @class */ (function () {\n    function PersistentStream(queue, connection, credentialsProvider, listener, \n        // Used for faster retries in testing\n        initialBackoffDelay) {\n        this.queue = queue;\n        this.connection = connection;\n        this.credentialsProvider = credentialsProvider;\n        this.stream = null;\n        this.listener = null;\n        this.backoff = new backoff_ExponentialBackoff(initialBackoffDelay ? initialBackoffDelay : BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);\n        this.state = PersistentStreamState.Initial;\n        this.listener = listener;\n    }\n    /**\n     * Returns true if `start` has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    PersistentStream.prototype.isStarted = function () {\n        return (this.state === PersistentStreamState.Backoff ||\n            this.state === PersistentStreamState.Auth ||\n            this.state === PersistentStreamState.Open);\n    };\n    /**\n     * Returns true if the underlying RPC is open (the openHandler has been\n     * called) and the stream is ready for outbound requests.\n     */\n    PersistentStream.prototype.isOpen = function () {\n        return this.state === PersistentStreamState.Open;\n    };\n    /**\n     * Starts the RPC. Only allowed if isStarted returns false. The stream is\n     * not immediately ready for use: onOpen will be invoked when the RPC is ready\n     * for outbound requests, at which point isOpen will return true.\n     *\n     *  When start returns, isStarted will return true.\n     */\n    PersistentStream.prototype.start = function () {\n        if (this.state === PersistentStreamState.Error) {\n            this.performBackoff();\n            return;\n        }\n        assert(this.state === PersistentStreamState.Initial, 'Already started');\n        this.auth();\n    };\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted state.\n     *\n     * When stop returns, isStarted and isOpen will both return false.\n     */\n    PersistentStream.prototype.stop = function () {\n        // Prevent any possible future restart of this stream\n        this.state = PersistentStreamState.Stopped;\n        // Clear the listener to avoid bleeding of events from the underlying\n        // streams\n        this.listener = null;\n        // Clean up the underlying stream because we are no longer interested in\n        // events\n        if (this.stream !== null) {\n            this.stream.close();\n            this.stream = null;\n        }\n    };\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose function. That function can decide to\n     * inhibit backoff if required.\n     */\n    PersistentStream.prototype.inhibitBackoff = function () {\n        assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n        this.state = PersistentStreamState.Initial;\n        this.backoff.reset();\n    };\n    PersistentStream.prototype.auth = function () {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');\n        this.state = PersistentStreamState.Auth;\n        this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(function (token) {\n            // Normally we'd have to schedule the callback on the AsyncQueue.\n            // However, the following calls are safe to be called outside the\n            // AsyncQueue since they don't chain asynchronous calls\n            _this.startStream(token);\n        }, function (error) {\n            _this.queue.schedule(function () {\n                if (_this.state !== PersistentStreamState.Stopped) {\n                    // Stream can be stopped while waiting for authorization.\n                    var rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                    return _this.handleStreamClose(rpcError);\n                }\n                else {\n                    return Promise.resolve();\n                }\n            });\n        });\n    };\n    PersistentStream.prototype.startStream = function (token) {\n        var _this = this;\n        if (this.state === PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            return;\n        }\n        assert(this.state === PersistentStreamState.Auth, 'Trying to start stream in a non-auth state');\n        // Helper function to dispatch to AsyncQueue and make sure that any\n        // close will seem instantaneous and events are prevented from being\n        // raised after the close call\n        var dispatchIfNotStopped = function (fn) {\n            _this.queue.schedule(function () {\n                // Only raise events if the listener has not changed\n                if (_this.state !== PersistentStreamState.Stopped) {\n                    return fn();\n                }\n                else {\n                    return Promise.resolve();\n                }\n            });\n        };\n        // Only start stream if listener has not changed\n        if (this.listener !== null) {\n            this.stream = this.startRpc(token);\n            this.stream.onOpen(function () {\n                dispatchIfNotStopped(function () {\n                    assert(_this.state === PersistentStreamState.Auth, 'Expected stream to be in state auth, but was ' + _this.state);\n                    _this.state = PersistentStreamState.Open;\n                    return _this.listener.onOpen();\n                });\n            });\n            this.stream.onClose(function (error) {\n                dispatchIfNotStopped(function () {\n                    return _this.handleStreamClose(error);\n                });\n            });\n            this.stream.onMessage(function (msg) {\n                dispatchIfNotStopped(function () {\n                    return _this.onMessage(msg);\n                });\n            });\n        }\n    };\n    PersistentStream.prototype.performBackoff = function () {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Error, 'Should only perform backoff in an error case');\n        this.state = PersistentStreamState.Backoff;\n        this.backoff.backoffAndWait().then(function () {\n            // Backoff does not run on the AsyncQueue, so we need to reschedule to\n            // make sure the queue blocks\n            _this.queue.schedule(function () {\n                if (_this.state === PersistentStreamState.Stopped) {\n                    // Stream can be stopped while waiting for backoff to complete.\n                    return Promise.resolve();\n                }\n                _this.state = PersistentStreamState.Initial;\n                _this.start();\n                assert(_this.isStarted(), 'PersistentStream should have started');\n                return Promise.resolve();\n            });\n        });\n    };\n    PersistentStream.prototype.handleStreamClose = function (error) {\n        assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n        debug(persistent_stream_LOG_TAG, \"close with error: \" + error);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        this.state = PersistentStreamState.Error;\n        if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n            debug(persistent_stream_LOG_TAG, 'Using maximum backoff delay to prevent overloading the backend.');\n            this.backoff.resetToMax();\n        }\n        return this.listener.onClose(error);\n    };\n    return PersistentStream;\n}());\n\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nvar PersistentListenStream = /** @class */ (function (_super) {\n    persistent_stream___extends(PersistentListenStream, _super);\n    function PersistentListenStream(databaseInfo, queue, connection, credentials, serializer, listener, initialBackoffDelay) {\n        var _this = _super.call(this, queue, connection, credentials, listener, initialBackoffDelay) || this;\n        _this.databaseInfo = databaseInfo;\n        _this.serializer = serializer;\n        return _this;\n    }\n    PersistentListenStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Listen', token);\n    };\n    PersistentListenStream.prototype.onMessage = function (watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        var watchChange = this.serializer.fromWatchChange(watchChangeProto);\n        var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    };\n    /**\n     * Registers interest in the results of the given query. If the query\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the query will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    PersistentListenStream.prototype.watch = function (queryData) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.addTarget = this.serializer.toTarget(queryData);\n        var labels = this.serializer.toListenRequestLabels(queryData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.stream.send(request);\n    };\n    /**\n     * Unregisters interest in the results of the query associated with the\n     * given targetId.\n     */\n    PersistentListenStream.prototype.unwatch = function (targetId) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.removeTarget = targetId;\n        this.stream.send(request);\n    };\n    return PersistentListenStream;\n}(persistent_stream_PersistentStream));\n\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nvar persistent_stream_PersistentWriteStream = /** @class */ (function (_super) {\n    persistent_stream___extends(PersistentWriteStream, _super);\n    function PersistentWriteStream(databaseInfo, queue, connection, credentials, serializer, listener, initialBackoffDelay) {\n        var _this = _super.call(this, queue, connection, credentials, listener, initialBackoffDelay) || this;\n        _this.databaseInfo = databaseInfo;\n        _this.serializer = serializer;\n        _this.handshakeComplete_ = false;\n        return _this;\n    }\n    Object.defineProperty(PersistentWriteStream.prototype, \"handshakeComplete\", {\n        /**\n         * Tracks whether or not a handshake has been successfully exchanged and\n         * the stream is ready to accept mutations.\n         */\n        get: function () {\n            return this.handshakeComplete_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Override of PersistentStream.start\n    PersistentWriteStream.prototype.start = function () {\n        this.handshakeComplete_ = false;\n        _super.prototype.start.call(this);\n    };\n    PersistentWriteStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Write', token);\n    };\n    PersistentWriteStream.prototype.onMessage = function (responseProto) {\n        // Always capture the last stream token.\n        assert(!!responseProto.streamToken, 'Got a write response without a stream token');\n        this.lastStreamToken = responseProto.streamToken;\n        if (!this.handshakeComplete_) {\n            // The first response is always the handshake response\n            assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');\n            this.handshakeComplete_ = true;\n            return this.listener.onHandshakeComplete();\n        }\n        else {\n            // A successful first write response means the stream is healthy,\n            // Note, that we could consider a successful handshake healthy, however,\n            // the write itself might be causing an error we want to back off from.\n            this.backoff.reset();\n            var results = this.serializer.fromWriteResults(responseProto.writeResults);\n            var commitVersion = this.serializer.fromVersion(responseProto.commitTime);\n            return this.listener.onMutationResult(commitVersion, results);\n        }\n    };\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    PersistentWriteStream.prototype.writeHandshake = function () {\n        assert(this.isOpen(), 'Writing handshake requires an opened stream');\n        assert(!this.handshakeComplete_, 'Handshake already completed');\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        this.stream.send(request);\n    };\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    PersistentWriteStream.prototype.writeMutations = function (mutations) {\n        var _this = this;\n        assert(this.isOpen(), 'Writing mutations requires an opened stream');\n        assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');\n        assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');\n        var request = {\n            // Protos are typed with string, but we support UInt8Array on Node\n            // tslint:disable-next-line:no-any\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(function (mutation) { return _this.serializer.toMutation(mutation); })\n        };\n        this.stream.send(request);\n    };\n    return PersistentWriteStream;\n}(persistent_stream_PersistentStream));\n\n\n//# sourceMappingURL=persistent_stream.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/datastore.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\nvar datastore_Datastore = /** @class */ (function () {\n    function Datastore(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {\n        this.databaseInfo = databaseInfo;\n        this.queue = queue;\n        this.connection = connection;\n        this.credentials = credentials;\n        this.serializer = serializer;\n        this.initialBackoffDelay = initialBackoffDelay;\n    }\n    Datastore.prototype.newPersistentWriteStream = function (listener) {\n        return new persistent_stream_PersistentWriteStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, listener, this.initialBackoffDelay);\n    };\n    Datastore.prototype.newPersistentWatchStream = function (listener) {\n        return new PersistentListenStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, listener, this.initialBackoffDelay);\n    };\n    Datastore.prototype.commit = function (mutations) {\n        var _this = this;\n        var params = {\n            writes: mutations.map(function (m) { return _this.serializer.toMutation(m); })\n        };\n        return this.invokeRPC('commit', params).then(function (response) {\n            return _this.serializer.fromWriteResults(response.writeResults);\n        });\n    };\n    Datastore.prototype.lookup = function (keys) {\n        var _this = this;\n        var params = {\n            documents: keys.map(function (k) { return _this.serializer.toName(k); })\n        };\n        return this.invokeRPC('batchGet', params).then(function (response) {\n            var docs = maybeDocumentMap();\n            response.forEach(function (proto) {\n                var doc = _this.serializer.fromMaybeDocument(proto);\n                docs = docs.insert(doc.key, doc);\n            });\n            var result = [];\n            keys.forEach(function (key) {\n                var doc = docs.get(key);\n                assert(!!doc, 'Missing entity in write response for ' + key);\n                result.push(doc);\n            });\n            return result;\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC. */\n    Datastore.prototype.invokeRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invoke(rpcName, request, token);\n        });\n    };\n    return Datastore;\n}());\n\n\n//# sourceMappingURL=datastore.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/transaction.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nvar transaction_Transaction = /** @class */ (function () {\n    function Transaction(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = documentVersionMap();\n        this.mutations = [];\n        this.committed = false;\n    }\n    Transaction.prototype.recordVersion = function (doc) {\n        var docVersion = doc.version;\n        if (doc instanceof document_NoDocument) {\n            // For deleted docs, we must use baseVersion 0 when we overwrite them.\n            docVersion = snapshot_version_SnapshotVersion.forDeletedDoc();\n        }\n        var existingVersion = this.readVersions.get(doc.key);\n        if (existingVersion !== null) {\n            if (!docVersion.equals(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions = this.readVersions.insert(doc.key, docVersion);\n        }\n    };\n    Transaction.prototype.lookup = function (keys) {\n        var _this = this;\n        if (this.committed) {\n            return Promise.reject('Transaction has already completed.');\n        }\n        if (this.mutations.length > 0) {\n            return Promise.reject('Transactions lookups are invalid after writes.');\n        }\n        return this.datastore.lookup(keys).then(function (docs) {\n            docs.forEach(function (doc) { return _this.recordVersion(doc); });\n            return docs;\n        });\n    };\n    Transaction.prototype.write = function (mutations) {\n        if (this.committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');\n        }\n        this.mutations = this.mutations.concat(mutations);\n    };\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    Transaction.prototype.precondition = function (key) {\n        var version = this.readVersions.get(key);\n        if (version) {\n            return mutation_Precondition.updateTime(version);\n        }\n        else {\n            return mutation_Precondition.NONE;\n        }\n    };\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    Transaction.prototype.preconditionForUpdate = function (key) {\n        var version = this.readVersions.get(key);\n        if (version && version.equals(snapshot_version_SnapshotVersion.forDeletedDoc())) {\n            // The document doesn't exist, so fail the transaction.\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n        }\n        else if (version) {\n            // Document exists, base precondition on document update time.\n            return mutation_Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return mutation_Precondition.exists(true);\n        }\n    };\n    Transaction.prototype.set = function (key, data) {\n        this.write(data.toMutations(key, this.precondition(key)));\n    };\n    Transaction.prototype.update = function (key, data) {\n        this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n    };\n    Transaction.prototype.delete = function (key) {\n        this.write([new mutation_DeleteMutation(key, this.precondition(key))]);\n        // Since the delete will be applied before all following writes, we need to\n        // ensure that the precondition for the next write will be exists: false.\n        this.readVersions = this.readVersions.insert(key, snapshot_version_SnapshotVersion.forDeletedDoc());\n    };\n    Transaction.prototype.commit = function () {\n        var _this = this;\n        var unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(function (mutation) {\n            unwritten = unwritten.remove(mutation.key);\n        });\n        if (!unwritten.isEmpty()) {\n            return Promise.reject(Error('Every document read in a transaction must also be written.'));\n        }\n        return this.datastore.commit(this.mutations).then(function () {\n            _this.committed = true;\n        });\n    };\n    return Transaction;\n}());\n\n\n//# sourceMappingURL=transaction.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/remote_store.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar remote_store_LOG_TAG = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nvar MAX_PENDING_WRITES = 10;\n// The RemoteStore notifies an onlineStateHandler with OnlineState.Failed if we\n// fail to connect to the backend. This subsequently triggers get() requests to\n// fail or use cached data, etc. Unfortunately, our connections have\n// historically been subject to various transient failures. So we wait for\n// multiple failures before notifying the onlineStateHandler.\nvar ONLINE_ATTEMPTS_BEFORE_FAILURE = 2;\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nvar remote_store_RemoteStore = /** @class */ (function () {\n    function RemoteStore(databaseInfo, asyncQueue, \n        /**\n         * The local store, used to fill the write pipeline with outbound\n         * mutations and resolve existence filter mismatches.\n         */\n        localStore, \n        /** The client-side proxy for interacting with the backend. */\n        datastore, onlineStateHandler) {\n        this.databaseInfo = databaseInfo;\n        this.asyncQueue = asyncQueue;\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.onlineStateHandler = onlineStateHandler;\n        this.pendingWrites = [];\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = {};\n        /**\n         * A mapping of targetId to pending acks needed.\n         *\n         * If a targetId is present in this map, then we're waiting for watch to\n         * acknowledge a removal or addition of the target. If a target is not in this\n         * mapping, and it's in the listenTargets map, then we consider the target to\n         * be active.\n         *\n         * We increment the count here every time we issue a request over the stream\n         * to watch or unwatch. We then decrement the count every time we get a target\n         * added or target removed message from the server. Once the count is equal to\n         * 0 we know that the client and server are in the same state (once this state\n         * is reached the targetId is removed from the map to free the memory).\n         */\n        this.pendingTargetResponses = {};\n        this.accumulatedWatchChanges = [];\n        this.watchStream = null;\n        this.writeStream = null;\n        /**\n         * The online state of the watch stream. The state is set to healthy if and\n         * only if there are messages received by the backend.\n         */\n        this.watchStreamOnlineState = OnlineState.Unknown;\n        /** A count of consecutive failures to open the stream. */\n        this.watchStreamFailures = 0;\n    }\n    /**\n     * Starts up the remote store, creating streams, restoring state from\n     * LocalStore, etc.\n     */\n    RemoteStore.prototype.start = function () {\n        return this.enableNetwork();\n    };\n    RemoteStore.prototype.setOnlineStateToHealthy = function () {\n        this.updateAndBroadcastOnlineState(OnlineState.Healthy);\n    };\n    RemoteStore.prototype.setOnlineStateToUnknown = function () {\n        // The state is set to unknown when a healthy stream is closed (e.g. due to\n        // a token timeout) or when we have no active listens and therefore there's\n        // no need to start the stream. Assuming there is (possibly in the future)\n        // an active listen, then we will eventually move to state Online or Failed,\n        // but we always want to make at least ONLINE_ATTEMPTS_BEFORE_FAILURE\n        // attempts before failing, so we reset the count here.\n        this.watchStreamFailures = 0;\n        this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n    };\n    RemoteStore.prototype.updateOnlineStateAfterFailure = function () {\n        // The first failure after we are successfully connected moves us to the\n        // 'Unknown' state. We then may make multiple attempts (based on\n        // ONLINE_ATTEMPTS_BEFORE_FAILURE) before we actually report failure.\n        if (this.watchStreamOnlineState === OnlineState.Healthy) {\n            this.setOnlineStateToUnknown();\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= ONLINE_ATTEMPTS_BEFORE_FAILURE) {\n                this.updateAndBroadcastOnlineState(OnlineState.Failed);\n            }\n        }\n    };\n    RemoteStore.prototype.updateAndBroadcastOnlineState = function (onlineState) {\n        var didChange = this.watchStreamOnlineState !== onlineState;\n        this.watchStreamOnlineState = onlineState;\n        if (didChange) {\n            this.onlineStateHandler(onlineState);\n        }\n    };\n    RemoteStore.prototype.isNetworkEnabled = function () {\n        assert((this.watchStream == null) == (this.writeStream == null), 'WatchStream and WriteStream should both be null or non-null');\n        return this.watchStream != null;\n    };\n    /** Re-enables the network. Only to be called as the counterpart to disableNetwork(). */\n    RemoteStore.prototype.enableNetwork = function () {\n        var _this = this;\n        assert(this.watchStream == null, 'enableNetwork() called with non-null watchStream.');\n        assert(this.writeStream == null, 'enableNetwork() called with non-null writeStream.');\n        // Create new streams (but note they're not started yet).\n        this.watchStream = this.datastore.newPersistentWatchStream({\n            onOpen: this.onWatchStreamOpen.bind(this),\n            onClose: this.onWatchStreamClose.bind(this),\n            onWatchChange: this.onWatchStreamChange.bind(this)\n        });\n        this.writeStream = this.datastore.newPersistentWriteStream({\n            onOpen: this.onWriteStreamOpen.bind(this),\n            onClose: this.onWriteStreamClose.bind(this),\n            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n            onMutationResult: this.onMutationResult.bind(this)\n        });\n        // Load any saved stream token from persistent storage\n        return this.localStore.getLastStreamToken().then(function (token) {\n            _this.writeStream.lastStreamToken = token;\n            if (_this.shouldStartWatchStream()) {\n                _this.startWatchStream();\n            }\n            _this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n            return _this.fillWritePipeline(); // This may start the writeStream.\n        });\n    };\n    /** Temporarily disables the network. The network can be re-enabled using enableNetwork(). */\n    RemoteStore.prototype.disableNetwork = function () {\n        this.updateAndBroadcastOnlineState(OnlineState.Failed);\n        // NOTE: We're guaranteed not to get any further events from these streams (not even a close\n        // event).\n        this.watchStream.stop();\n        this.writeStream.stop();\n        this.cleanUpWatchStreamState();\n        this.cleanUpWriteStreamState();\n        this.writeStream = null;\n        this.watchStream = null;\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.shutdown = function () {\n        debug(remote_store_LOG_TAG, 'RemoteStore shutting down.');\n        this.disableNetwork();\n        return Promise.resolve(undefined);\n    };\n    /** Starts new listen for the given query. Uses resume token if provided */\n    RemoteStore.prototype.listen = function (queryData) {\n        assert(!contains(this.listenTargets, queryData.targetId), 'listen called with duplicate targetId!');\n        // Mark this as something the client is currently listening for.\n        this.listenTargets[queryData.targetId] = queryData;\n        if (this.shouldStartWatchStream()) {\n            // The listen will be sent in onWatchStreamOpen\n            this.startWatchStream();\n        }\n        else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n            this.sendWatchRequest(queryData);\n        }\n    };\n    /** Removes the listen from server */\n    RemoteStore.prototype.unlisten = function (targetId) {\n        assert(contains(this.listenTargets, targetId), 'unlisten called without assigned target ID!');\n        var queryData = this.listenTargets[targetId];\n        delete this.listenTargets[targetId];\n        if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n            this.sendUnwatchRequest(targetId);\n        }\n    };\n    /**\n     * We need to increment the the expected number of pending responses we're due\n     * from watch so we wait for the ack to process any messages from this target.\n     */\n    RemoteStore.prototype.sendWatchRequest = function (queryData) {\n        this.recordPendingTargetRequest(queryData.targetId);\n        this.watchStream.watch(queryData);\n    };\n    /**\n     * We need to increment the expected number of pending responses we're due\n     * from watch so we wait for the removal on the server before we process any\n     * messages from this target.\n     */\n    RemoteStore.prototype.sendUnwatchRequest = function (targetId) {\n        this.recordPendingTargetRequest(targetId);\n        this.watchStream.unwatch(targetId);\n    };\n    /**\n     * Increment the mapping of how many acks are needed from watch before we can\n     * consider the server to be 'in-sync' with the client's active targets.\n     */\n    RemoteStore.prototype.recordPendingTargetRequest = function (targetId) {\n        // For each request we get we need to record we need a response for it.\n        this.pendingTargetResponses[targetId] =\n            (this.pendingTargetResponses[targetId] || 0) + 1;\n    };\n    RemoteStore.prototype.startWatchStream = function () {\n        assert(this.shouldStartWatchStream(), 'startWriteStream() called when shouldStartWatchStream() is false.');\n        this.watchStream.start();\n    };\n    /**\n     * Returns whether the watch stream should be started because there are\n     * active targets trying to be listened too\n     */\n    RemoteStore.prototype.shouldStartWatchStream = function () {\n        return (this.isNetworkEnabled() &&\n            !this.watchStream.isStarted() &&\n            !isEmpty(this.listenTargets));\n    };\n    RemoteStore.prototype.cleanUpWatchStreamState = function () {\n        // If the connection is closed then we'll never get a snapshot version for\n        // the accumulated changes and so we'll never be able to complete the batch.\n        // When we start up again the server is going to resend these changes\n        // anyway, so just toss the accumulated state.\n        this.accumulatedWatchChanges = [];\n        this.pendingTargetResponses = {};\n    };\n    RemoteStore.prototype.onWatchStreamOpen = function () {\n        var _this = this;\n        // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n        // targets are active\n        forEachNumber(this.listenTargets, function (targetId, queryData) {\n            _this.sendWatchRequest(queryData);\n        });\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWatchStreamClose = function (error) {\n        assert(this.isNetworkEnabled(), 'onWatchStreamClose() should only be called when the network is enabled');\n        this.cleanUpWatchStreamState();\n        // If there was an error, retry the connection.\n        if (this.shouldStartWatchStream()) {\n            this.updateOnlineStateAfterFailure();\n            this.startWatchStream();\n        }\n        else {\n            // No need to restart watch stream because there are no active targets.\n            // The online state is set to unknown because there is no active attempt\n            // at establishing a connection\n            this.setOnlineStateToUnknown();\n        }\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWatchStreamChange = function (watchChange, snapshotVersion) {\n        // Mark the connection as healthy because we got a message from the server\n        this.setOnlineStateToHealthy();\n        if (watchChange instanceof watch_change_WatchTargetChange &&\n            watchChange.state === WatchTargetChangeState.Removed &&\n            watchChange.cause) {\n            // There was an error on a target, don't wait for a consistent snapshot\n            // to raise events\n            return this.handleTargetError(watchChange);\n        }\n        // Accumulate watch changes but don't process them if there's no\n        // snapshotVersion or it's older than a previous snapshot we've processed\n        // (can happen after we resume a target using a resume token).\n        this.accumulatedWatchChanges.push(watchChange);\n        if (!snapshotVersion.equals(snapshot_version_SnapshotVersion.MIN) &&\n            snapshotVersion.compareTo(this.localStore.getLastRemoteSnapshotVersion()) >= 0) {\n            var changes = this.accumulatedWatchChanges;\n            this.accumulatedWatchChanges = [];\n            return this.handleWatchChangeBatch(snapshotVersion, changes);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    /**\n     * Takes a batch of changes from the Datastore, repackages them as a\n     * RemoteEvent, and passes that on to the listener, which is typically the\n     * SyncEngine.\n     */\n    RemoteStore.prototype.handleWatchChangeBatch = function (snapshotVersion, changes) {\n        var _this = this;\n        var aggregator = new watch_change_WatchChangeAggregator(snapshotVersion, this.listenTargets, this.pendingTargetResponses);\n        aggregator.addChanges(changes);\n        var remoteEvent = aggregator.createRemoteEvent();\n        // Get the new response counts from the aggregator\n        this.pendingTargetResponses = aggregator.pendingTargetResponses;\n        var promises = [];\n        // Handle existence filters and existence filter mismatches.\n        forEachNumber(aggregator.existenceFilters, function (targetId, filter) {\n            var queryData = _this.listenTargets[targetId];\n            if (!queryData) {\n                // A watched target might have been removed already.\n                return;\n            }\n            var query = queryData.query;\n            if (query.isDocumentQuery()) {\n                if (filter.count === 0) {\n                    // The existence filter told us the document does not exist.\n                    // We need to deduce that this document does not exist and apply\n                    // a deleted document to our updates. Without applying a deleted\n                    // document there might be another query that will raise this\n                    // document as part of a snapshot until it is resolved,\n                    // essentially exposing inconsistency between queries.\n                    var key = new document_key_DocumentKey(query.path);\n                    var deletedDoc = new document_NoDocument(key, snapshotVersion);\n                    remoteEvent.addDocumentUpdate(deletedDoc);\n                }\n                else {\n                    assert(filter.count === 1, 'Single document existence filter with count: ' + filter.count);\n                }\n            }\n            else {\n                // Not a document query.\n                var promise = _this.localStore\n                    .remoteDocumentKeys(targetId)\n                    .then(function (trackedRemote) {\n                    if (remoteEvent.targetChanges[targetId]) {\n                        var mapping = remoteEvent.targetChanges[targetId].mapping;\n                        if (mapping !== null) {\n                            if (mapping instanceof UpdateMapping) {\n                                trackedRemote = mapping.applyToKeySet(trackedRemote);\n                            }\n                            else {\n                                assert(mapping instanceof ResetMapping, 'Expected either reset or update mapping but got something else: ' +\n                                    mapping);\n                                trackedRemote = mapping.documents;\n                            }\n                        }\n                    }\n                    if (trackedRemote.size !== filter.count) {\n                        // Existence filter mismatch, resetting mapping.\n                        // Make sure the mismatch is exposed in the remote event.\n                        remoteEvent.handleExistenceFilterMismatch(targetId);\n                        // Clear the resume token for the query, since we're in a\n                        // known mismatch state.\n                        var newQueryData = new query_data_QueryData(query, targetId, queryData.purpose);\n                        _this.listenTargets[targetId] = newQueryData;\n                        // Cause a hard reset by unwatching and rewatching\n                        // immediately, but deliberately don't send a resume token\n                        // so that we get a full update.\n                        // Make sure we expect that this acks are going to happen.\n                        _this.sendUnwatchRequest(targetId);\n                        // Mark the query we send as being on behalf of an existence\n                        // filter mismatch, but don't actually retain that in\n                        // listenTargets. This ensures that we flag the first\n                        // re-listen this way without impacting future listens of\n                        // this target (that might happen e.g. on reconnect).\n                        var requestQueryData = new query_data_QueryData(query, targetId, QueryPurpose.ExistenceFilterMismatch);\n                        _this.sendWatchRequest(requestQueryData);\n                    }\n                });\n                promises.push(promise);\n            }\n        });\n        return Promise.all(promises).then(function () {\n            // Update in-memory resume tokens. LocalStore will update the\n            // persistent view of these when applying the completed RemoteEvent.\n            forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                if (change.resumeToken.length > 0) {\n                    var queryData = _this.listenTargets[targetId];\n                    // A watched target might have been removed already.\n                    if (queryData) {\n                        _this.listenTargets[targetId] = queryData.update({\n                            resumeToken: change.resumeToken,\n                            snapshotVersion: change.snapshotVersion\n                        });\n                    }\n                }\n            });\n            // Finally handle remote event\n            return _this.syncEngine.applyRemoteEvent(remoteEvent);\n        });\n    };\n    /** Handles an error on a target */\n    RemoteStore.prototype.handleTargetError = function (watchChange) {\n        var _this = this;\n        assert(!!watchChange.cause, 'Handling target error without a cause');\n        var error = watchChange.cause;\n        var promiseChain = Promise.resolve();\n        watchChange.targetIds.forEach(function (targetId) {\n            promiseChain = promiseChain.then(function () {\n                if (contains(_this.listenTargets, targetId)) {\n                    delete _this.listenTargets[targetId];\n                    return _this.syncEngine.rejectListen(targetId, error);\n                }\n                else {\n                    // A watched target might have been removed already.\n                    return Promise.resolve();\n                }\n            });\n        });\n        return promiseChain;\n    };\n    RemoteStore.prototype.cleanUpWriteStreamState = function () {\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        this.pendingWrites = [];\n    };\n    /**\n     * Notifies that there are new mutations to process in the queue. This is\n     * typically called by SyncEngine after it has sent mutations to LocalStore.\n     *\n     */\n    RemoteStore.prototype.fillWritePipeline = function () {\n        var _this = this;\n        if (!this.canWriteMutations()) {\n            return Promise.resolve();\n        }\n        else {\n            return this.localStore\n                .nextMutationBatch(this.lastBatchSeen)\n                .then(function (batch) {\n                if (batch === null) {\n                    return Promise.resolve();\n                }\n                else {\n                    _this.commit(batch);\n                    return _this.fillWritePipeline();\n                }\n            });\n        }\n    };\n    /**\n     * Returns true if the backend can accept additional write requests.\n     *\n     * When sending mutations to the write stream (e.g. in fillWritePipeline),\n     * call this method first to check if more mutations can be sent.\n     *\n     * Currently the only thing that can prevent the backend from accepting\n     * write requests is if there are too many requests already outstanding. As\n     * writes complete the backend will be able to accept more.\n     */\n    RemoteStore.prototype.canWriteMutations = function () {\n        return (this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES);\n    };\n    // For testing\n    RemoteStore.prototype.outstandingWrites = function () {\n        return this.pendingWrites.length;\n    };\n    /**\n     * Given mutations to commit, actually commits them to the Datastore. Note\n     * that this does *not* return a Promise specifically because the AsyncQueue\n     * should not block operations for this.\n     */\n    RemoteStore.prototype.commit = function (batch) {\n        assert(this.canWriteMutations(), \"commit called when batches can't be written\");\n        this.lastBatchSeen = batch.batchId;\n        this.pendingWrites.push(batch);\n        if (this.shouldStartWriteStream()) {\n            this.startWriteStream();\n        }\n        else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {\n            this.writeStream.writeMutations(batch.mutations);\n        }\n    };\n    RemoteStore.prototype.shouldStartWriteStream = function () {\n        return (this.isNetworkEnabled() &&\n            !this.writeStream.isStarted() &&\n            this.pendingWrites.length > 0);\n    };\n    RemoteStore.prototype.startWriteStream = function () {\n        assert(this.shouldStartWriteStream(), 'startWriteStream() called when shouldStartWriteStream() is false.');\n        this.writeStream.start();\n    };\n    RemoteStore.prototype.onWriteStreamOpen = function () {\n        this.writeStream.writeHandshake();\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWriteHandshakeComplete = function () {\n        var _this = this;\n        // Record the stream token.\n        return this.localStore\n            .setLastStreamToken(this.writeStream.lastStreamToken)\n            .then(function () {\n            // Drain any pending writes.\n            //\n            // Note that at this point pendingWrites contains mutations that\n            // have already been accepted by fillWritePipeline/commitBatch. If\n            // the pipeline is full, canWriteMutations will be false, despite\n            // the fact that we actually need to send mutations over.\n            //\n            // This also means that this method indirectly respects the limits\n            // imposed by canWriteMutations since writes can't be added to the\n            // pendingWrites array when canWriteMutations is false. If the\n            // limits imposed by canWriteMutations actually protect us from\n            // DOSing ourselves then those limits won't be exceeded here and\n            // we'll continue to make progress.\n            for (var _i = 0, _a = _this.pendingWrites; _i < _a.length; _i++) {\n                var batch = _a[_i];\n                _this.writeStream.writeMutations(batch.mutations);\n            }\n        });\n    };\n    RemoteStore.prototype.onMutationResult = function (commitVersion, results) {\n        var _this = this;\n        // This is a response to a write containing mutations and should be\n        // correlated to the first pending write.\n        assert(this.pendingWrites.length > 0, 'Got result for empty pending writes');\n        var batch = this.pendingWrites.shift();\n        var success = mutation_batch_MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);\n        return this.syncEngine.applySuccessfulWrite(success).then(function () {\n            // It's possible that with the completion of this mutation another\n            // slot has freed up.\n            return _this.fillWritePipeline();\n        });\n    };\n    RemoteStore.prototype.onWriteStreamClose = function (error) {\n        var _this = this;\n        assert(this.isNetworkEnabled(), 'onWriteStreamClose() should only be called when the network is enabled');\n        // Ignore close if there are no pending writes.\n        if (this.pendingWrites.length > 0) {\n            assert(!!error, 'We have pending writes, but the write stream closed without an error');\n            // A promise that is resolved after we processed the error\n            var errorHandling = void 0;\n            if (this.writeStream.handshakeComplete) {\n                // This error affects the actual write.\n                errorHandling = this.handleWriteError(error);\n            }\n            else {\n                // If there was an error before the handshake has finished, it's\n                // possible that the server is unable to process the stream token\n                // we're sending. (Perhaps it's too old?)\n                errorHandling = this.handleHandshakeError(error);\n            }\n            return errorHandling.then(function () {\n                // The write stream might have been started by refilling the write\n                // pipeline for failed writes\n                if (_this.shouldStartWriteStream()) {\n                    _this.startWriteStream();\n                }\n            });\n        }\n        else {\n            // No pending writes, nothing to do\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.handleHandshakeError = function (error) {\n        // Reset the token if it's a permanent error or the error code is\n        // ABORTED, signaling the write stream is no longer valid.\n        if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n            debug(remote_store_LOG_TAG, 'RemoteStore error before completed handshake; resetting stream token: ', this.writeStream.lastStreamToken);\n            this.writeStream.lastStreamToken = emptyByteString();\n            return this.localStore.setLastStreamToken(emptyByteString());\n        }\n        else {\n            // Some other error, don't reset stream token. Our stream logic will\n            // just retry with exponential backoff.\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.handleWriteError = function (error) {\n        var _this = this;\n        if (isPermanentError(error.code)) {\n            // This was a permanent error, the request itself was the problem\n            // so it's not going to succeed if we resend it.\n            var batch = this.pendingWrites.shift();\n            // In this case it's also unlikely that the server itself is melting\n            // down -- this was just a bad request so inhibit backoff on the next\n            // restart.\n            this.writeStream.inhibitBackoff();\n            return this.syncEngine\n                .rejectFailedWrite(batch.batchId, error)\n                .then(function () {\n                // It's possible that with the completion of this mutation\n                // another slot has freed up.\n                return _this.fillWritePipeline();\n            });\n        }\n        else {\n            // Transient error, just let the retry logic kick in.\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.createTransaction = function () {\n        return new transaction_Transaction(this.datastore);\n    };\n    RemoteStore.prototype.handleUserChange = function (user) {\n        debug(remote_store_LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n        // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n        // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n        // (since mutations are per-user).\n        this.disableNetwork();\n        return this.enableNetwork();\n    };\n    return RemoteStore;\n}());\n\n\n//# sourceMappingURL=remote_store.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/firestore_client.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar firestore_client_LOG_TAG = 'FirestoreClient';\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\nvar firestore_client_FirestoreClient = /** @class */ (function () {\n    function FirestoreClient(platform, databaseInfo, credentials, \n        /**\n           * Asynchronous queue responsible for all of our internal processing. When\n           * we get incoming work from the user (via public API) or the network\n           * (incoming GRPC messages), we should always schedule onto this queue.\n           * This ensures all of our work is properly serialized (e.g. we don't\n           * start processing a new operation while the previous one is waiting for\n           * an async I/O to complete).\n           */\n        asyncQueue) {\n        this.platform = platform;\n        this.databaseInfo = databaseInfo;\n        this.credentials = credentials;\n        this.asyncQueue = asyncQueue;\n    }\n    /**\n     * Starts up the FirestoreClient, returning only whether or not enabling\n     * persistence succeeded.\n     *\n     * The intent here is to \"do the right thing\" as far as users are concerned.\n     * Namely, in cases where offline persistence is requested and possible,\n     * enable it, but otherwise fall back to persistence disabled. For the most\n     * part we expect this to succeed one way or the other so we don't expect our\n     * users to actually wait on the firestore.enablePersistence Promise since\n     * they generally won't care.\n     *\n     * Of course some users actually do care about whether or not persistence\n     * was successfully enabled, so the Promise returned from this method\n     * indicates this outcome.\n     *\n     * This presents a problem though: even before enablePersistence resolves or\n     * rejects, users may have made calls to e.g. firestore.collection() which\n     * means that the FirestoreClient in there will be available and will be\n     * enqueuing actions on the async queue.\n     *\n     * Meanwhile any failure of an operation on the async queue causes it to\n     * panic and reject any further work, on the premise that unhandled errors\n     * are fatal.\n     *\n     * Consequently the fallback is handled internally here in start, and if the\n     * fallback succeeds we signal success to the async queue even though the\n     * start() itself signals failure.\n     *\n     * @param usePersistence Whether or not to attempt to enable persistence.\n     * @returns A deferred result indicating the user-visible result of enabling\n     *     offline persistence. This method will reject this if IndexedDB fails to\n     *     start for any reason. If usePersistence is false this is\n     *     unconditionally resolved.\n     */\n    FirestoreClient.prototype.start = function (usePersistence) {\n        var _this = this;\n        // We defer our initialization until we get the current user from\n        // setUserChangeListener(). We block the async queue until we got the\n        // initial user and the initialization is completed. This will prevent\n        // any scheduled work from happening before initialization is completed.\n        //\n        // If initializationDone resolved then the FirestoreClient is in a usable\n        // state.\n        var initializationDone = new Deferred();\n        // If usePersistence is true, certain classes of errors while starting are\n        // recoverable but only by falling back to persistence disabled.\n        //\n        // If there's an error in the first case but not in recovery we cannot\n        // reject the promise blocking the async queue because this will cause the\n        // async queue to panic.\n        var persistenceResult = new Deferred();\n        var initialized = false;\n        this.credentials.setUserChangeListener(function (user) {\n            if (!initialized) {\n                initialized = true;\n                _this.initializePersistence(usePersistence, persistenceResult)\n                    .then(function () { return _this.initializeRest(user); })\n                    .then(initializationDone.resolve, initializationDone.reject);\n            }\n            else {\n                _this.asyncQueue.schedule(function () {\n                    return _this.handleUserChange(user);\n                });\n            }\n        });\n        // Block the async queue until initialization is done\n        this.asyncQueue.schedule(function () {\n            return initializationDone.promise;\n        });\n        // Return only the result of enabling persistence. Note that this does not\n        // need to await the completion of initializationDone because the result of\n        // this method should not reflect any other kind of failure to start.\n        return persistenceResult.promise;\n    };\n    /** Enables the network connection and requeues all pending operations. */\n    FirestoreClient.prototype.enableNetwork = function () {\n        var _this = this;\n        return this.asyncQueue.schedule(function () {\n            return _this.remoteStore.enableNetwork();\n        });\n    };\n    /**\n     * Initializes persistent storage, attempting to use IndexedDB if\n     * usePersistence is true or memory-only if false.\n     *\n     * If IndexedDB fails because it's already open in another tab or because the\n     * platform can't possibly support our implementation then this method rejects\n     * the persistenceResult and falls back on memory-only persistence.\n     *\n     * @param usePersistence indicates whether or not to use offline persistence\n     * @param persistenceResult A deferred result indicating the user-visible\n     *     result of enabling offline persistence. This method will reject this if\n     *     IndexedDB fails to start for any reason. If usePersistence is false\n     *     this is unconditionally resolved.\n     * @returns a Promise indicating whether or not initialization should\n     *     continue, i.e. that one of the persistence implementations actually\n     *     succeeded.\n     */\n    FirestoreClient.prototype.initializePersistence = function (usePersistence, persistenceResult) {\n        var _this = this;\n        if (usePersistence) {\n            return this.startIndexedDbPersistence()\n                .then(persistenceResult.resolve)\n                .catch(function (error) {\n                // Regardless of whether or not the retry succeeds, from an user\n                // perspective, offline persistence has failed.\n                persistenceResult.reject(error);\n                // An unknown failure on the first stage shuts everything down.\n                if (!_this.canFallback(error)) {\n                    return Promise.reject(error);\n                }\n                console.warn('Error enabling offline storage. Falling back to' +\n                    ' storage disabled: ' +\n                    error);\n                return _this.startMemoryPersistence();\n            });\n        }\n        else {\n            // When usePersistence == false, enabling offline persistence is defined\n            // to unconditionally succeed. This allows start() to have the same\n            // signature for both cases, despite the fact that the returned promise\n            // is only used in the enablePersistence call.\n            persistenceResult.resolve();\n            return this.startMemoryPersistence();\n        }\n    };\n    FirestoreClient.prototype.canFallback = function (error) {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    };\n    /**\n     * Starts IndexedDB-based persistence.\n     *\n     * @returns A promise indicating success or failure.\n     */\n    FirestoreClient.prototype.startIndexedDbPersistence = function () {\n        // TODO(http://b/33384523): For now we just disable garbage collection\n        // when persistence is enabled.\n        this.garbageCollector = new no_op_garbage_collector_NoOpGarbageCollector();\n        var storagePrefix = indexeddb_persistence_IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);\n        // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.\n        var serializer = new serializer_JsonProtoSerializer(this.databaseInfo.databaseId, {\n            useProto3Json: true\n        });\n        this.persistence = new indexeddb_persistence_IndexedDbPersistence(storagePrefix, serializer);\n        return this.persistence.start();\n    };\n    /**\n     * Starts Memory-backed persistence. In practice this cannot fail.\n     *\n     * @returns A promise that will successfully resolve.\n     */\n    FirestoreClient.prototype.startMemoryPersistence = function () {\n        this.garbageCollector = new eager_garbage_collector_EagerGarbageCollector();\n        this.persistence = new memory_persistence_MemoryPersistence();\n        return this.persistence.start();\n    };\n    /**\n     * Initializes the rest of the FirestoreClient, assuming the initial user\n     * has been obtained from the credential provider and some persistence\n     * implementation is available in this.persistence.\n     */\n    FirestoreClient.prototype.initializeRest = function (user) {\n        var _this = this;\n        return this.platform\n            .loadConnection(this.databaseInfo)\n            .then(function (connection) {\n            _this.localStore = new local_store_LocalStore(_this.persistence, user, _this.garbageCollector);\n            var serializer = _this.platform.newSerializer(_this.databaseInfo.databaseId);\n            var datastore = new datastore_Datastore(_this.databaseInfo, _this.asyncQueue, connection, _this.credentials, serializer);\n            var onlineStateChangedHandler = function (onlineState) {\n                _this.eventMgr.onOnlineStateChanged(onlineState);\n            };\n            _this.remoteStore = new remote_store_RemoteStore(_this.databaseInfo, _this.asyncQueue, _this.localStore, datastore, onlineStateChangedHandler);\n            _this.syncEngine = new sync_engine_SyncEngine(_this.localStore, _this.remoteStore, user);\n            // Setup wiring between sync engine and remote store\n            _this.remoteStore.syncEngine = _this.syncEngine;\n            _this.eventMgr = new event_manager_EventManager(_this.syncEngine);\n            // NOTE: RemoteStore depends on LocalStore (for persisting stream\n            // tokens, refilling mutation queue, etc.) so must be started after\n            // LocalStore.\n            return _this.localStore.start();\n        })\n            .then(function () {\n            return _this.remoteStore.start();\n        });\n    };\n    FirestoreClient.prototype.handleUserChange = function (user) {\n        this.asyncQueue.verifyOperationInProgress();\n        debug(firestore_client_LOG_TAG, 'User Changed: ' + user.uid);\n        return this.syncEngine.handleUserChange(user);\n    };\n    /** Disables the network connection. Pending operations will not complete. */\n    FirestoreClient.prototype.disableNetwork = function () {\n        var _this = this;\n        return this.asyncQueue.schedule(function () {\n            return _this.remoteStore.disableNetwork();\n        });\n    };\n    FirestoreClient.prototype.shutdown = function () {\n        var _this = this;\n        return this.asyncQueue\n            .schedule(function () {\n            _this.credentials.removeUserChangeListener();\n            return _this.remoteStore.shutdown();\n        })\n            .then(function () {\n            // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n            return _this.persistence.shutdown();\n        });\n    };\n    FirestoreClient.prototype.listen = function (query, observer, options) {\n        var _this = this;\n        var listener = new event_manager_QueryListener(query, observer, options);\n        this.asyncQueue.schedule(function () {\n            return _this.eventMgr.listen(listener);\n        });\n        return listener;\n    };\n    FirestoreClient.prototype.unlisten = function (listener) {\n        var _this = this;\n        this.asyncQueue.schedule(function () {\n            return _this.eventMgr.unlisten(listener);\n        });\n    };\n    FirestoreClient.prototype.write = function (mutations) {\n        var _this = this;\n        var deferred = new Deferred();\n        this.asyncQueue.schedule(function () { return _this.syncEngine.write(mutations, deferred); });\n        return deferred.promise;\n    };\n    FirestoreClient.prototype.databaseId = function () {\n        return this.databaseInfo.databaseId;\n    };\n    FirestoreClient.prototype.transaction = function (updateFunction) {\n        var _this = this;\n        // We have to wait for the async queue to be sure syncEngine is initialized.\n        return this.asyncQueue\n            .schedule(function () {\n            return Promise.resolve();\n        })\n            .then(function () {\n            return _this.syncEngine.runTransaction(updateFunction);\n        });\n    };\n    return FirestoreClient;\n}());\n\n\n//# sourceMappingURL=firestore_client.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/async_observer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nvar AsyncObserver = /** @class */ (function () {\n    function AsyncObserver(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    AsyncObserver.prototype.next = function (value) {\n        this.scheduleEvent(this.observer.next, value);\n    };\n    AsyncObserver.prototype.error = function (error) {\n        this.scheduleEvent(this.observer.error, error);\n    };\n    AsyncObserver.prototype.mute = function () {\n        this.muted = true;\n    };\n    AsyncObserver.prototype.scheduleEvent = function (eventHandler, event) {\n        var _this = this;\n        if (!this.muted) {\n            setTimeout(function () {\n                if (!_this.muted) {\n                    eventHandler(event);\n                }\n            }, 0);\n        }\n    };\n    return AsyncObserver;\n}());\n\n\n//# sourceMappingURL=async_observer.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/async_queue.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar async_queue_AsyncQueue = /** @class */ (function () {\n    function AsyncQueue() {\n        // The last promise in the queue.\n        this.tail = Promise.resolve();\n        // The number of ops that are queued to be run in the future (i.e. they had a\n        // delay that has not yet elapsed).\n        this.delayedOpCount = 0;\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n    }\n    /**\n     * Adds a new operation to the queue. Returns a promise that will be resolved\n     * when the promise returned by the new operation is (with its value).\n     *\n     * Can optionally specify a delay to wait before queuing the operation.\n     */\n    AsyncQueue.prototype.schedule = function (op, delay) {\n        var _this = this;\n        if (this.failure) {\n            fail('AsyncQueue is already failed: ' + this.failure.message);\n        }\n        if ((delay || 0) > 0) {\n            this.delayedOpCount++;\n            var deferred_1 = new Deferred();\n            setTimeout(function () {\n                _this.scheduleInternal(function () {\n                    return op().then(function (result) {\n                        deferred_1.resolve(result);\n                    });\n                });\n                _this.delayedOpCount--; // decrement once it's actually queued.\n            }, delay);\n            return deferred_1.promise;\n        }\n        else {\n            return this.scheduleInternal(op);\n        }\n    };\n    AsyncQueue.prototype.scheduleInternal = function (op) {\n        var _this = this;\n        this.tail = this.tail.then(function () {\n            _this.operationInProgress = true;\n            return op()\n                .catch(function (error) {\n                _this.failure = error;\n                _this.operationInProgress = false;\n                log_error('INTERNAL UNHANDLED ERROR: ', error.stack || error.message);\n                throw error;\n            })\n                .then(function () {\n                _this.operationInProgress = false;\n            });\n        });\n        return this.tail;\n    };\n    /**\n     * Verifies there's an operation currently in-progress on the AsyncQueue.\n     * Unfortunately we can't verify that the running code is in the promise chain\n     * of that operation, so this isn't a foolproof check, but it should be enough\n     * to catch some bugs.\n     */\n    AsyncQueue.prototype.verifyOperationInProgress = function () {\n        assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');\n    };\n    AsyncQueue.prototype.drain = function () {\n        // TODO(mikelehen): This should perhaps also drain items that are queued to\n        // run in the future (perhaps by artificially running them early), but since\n        // no tests need that yet, I didn't bother for now.\n        assert(this.delayedOpCount === 0, \"draining doesn't handle delayed ops.\");\n        return this.schedule(function () { return Promise.resolve(undefined); });\n    };\n    return AsyncQueue;\n}());\n\n\n//# sourceMappingURL=async_queue.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/auth/user.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nvar User = /** @class */ (function () {\n    function User(uid) {\n        this.uid = uid;\n    }\n    User.prototype.isUnauthenticated = function () {\n        return this.uid == null;\n    };\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n    User.prototype.toKey = function () {\n        if (this.isUnauthenticated()) {\n            return 'anonymous-user';\n        }\n        else {\n            return 'uid:' + this.uid;\n        }\n    };\n    User.prototype.equals = function (otherUser) {\n        return otherUser.uid === this.uid;\n    };\n    /** A user with a null UID. */\n    User.UNAUTHENTICATED = new User(null);\n    // TODO(mikelehen): Look into getting a proper uid-equivalent for\n    // non-FirebaseAuth providers.\n    User.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\n    User.FIRST_PARTY = new User('first-party-uid');\n    return User;\n}());\n\n\n//# sourceMappingURL=user.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/credentials.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar OAuthToken = /** @class */ (function () {\n    function OAuthToken(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.authHeaders = { Authorization: \"Bearer \" + value };\n    }\n    return OAuthToken;\n}());\n\n/** A CredentialsProvider that always yields an empty token. */\nvar credentials_EmptyCredentialsProvider = /** @class */ (function () {\n    function EmptyCredentialsProvider() {\n        /**\n         * Stores the User listener registered with setUserChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.userListener = null;\n    }\n    EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(null);\n    };\n    EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire with initial user.\n        listener(User.UNAUTHENTICATED);\n    };\n    EmptyCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');\n        this.userListener = null;\n    };\n    return EmptyCredentialsProvider;\n}());\n\nvar credentials_FirebaseCredentialsProvider = /** @class */ (function () {\n    function FirebaseCredentialsProvider(app) {\n        var _this = this;\n        this.app = app;\n        /**\n         * The auth token listener registered with FirebaseApp, retained here so we\n         * can unregister it.\n         */\n        this.tokenListener = null;\n        /**\n         * Counter used to detect if the user changed while a getToken request was\n         * outstanding.\n         */\n        this.userCounter = 0;\n        /** The User listener registered with setUserChangeListener(). */\n        this.userListener = null;\n        // We listen for token changes but all we really care about is knowing when\n        // the uid may have changed.\n        this.tokenListener = function () {\n            var newUser = _this.getUser();\n            if (!_this.currentUser || !newUser.equals(_this.currentUser)) {\n                _this.currentUser = newUser;\n                _this.userCounter++;\n                if (_this.userListener) {\n                    _this.userListener(_this.currentUser);\n                }\n            }\n        };\n        this.userCounter = 0;\n        // Will fire at least once where we set this.currentUser\n        this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n    }\n    FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');\n        // Take note of the current value of the userCounter so that this method can\n        // fail (with an ABORTED error) if there is a user change while the request\n        // is outstanding.\n        var initialUserCounter = this.userCounter;\n        return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {\n            // Cancel the request since the user changed while the request was\n            // outstanding so the response is likely for a previous user (which\n            // user, we can't be sure).\n            if (_this.userCounter !== initialUserCounter) {\n                throw new FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');\n            }\n            else {\n                if (tokenData) {\n                    assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);\n                    return new OAuthToken(tokenData.accessToken, _this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    };\n    FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire the initial event, but only if we received the initial user\n        if (this.currentUser) {\n            listener(this.currentUser);\n        }\n    };\n    FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.tokenListener != null, 'removeUserChangeListener() called twice');\n        assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');\n        this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);\n        this.tokenListener = null;\n        this.userListener = null;\n    };\n    FirebaseCredentialsProvider.prototype.getUser = function () {\n        // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n        if (typeof this.app.INTERNAL.getUid !== 'function') {\n            fail('This version of the Firestore SDK requires at least version' +\n                ' 3.7.0 of firebase.js.');\n        }\n        var currentUid = this.app.INTERNAL.getUid();\n        assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);\n        return new User(currentUid);\n    };\n    return FirebaseCredentialsProvider;\n}());\n\n// Wrap a google-auth-library client as a CredentialsProvider.\n// NOTE: grpc-connection can natively accept a google-auth-library\n// client via createFromGoogleCredential(), but we opt to plumb the tokens\n// through our CredentialsProvider interface, at least for now.\nvar credentials_GoogleCredentialsProvider = /** @class */ (function () {\n    function GoogleCredentialsProvider(authClient) {\n        this.authClient = authClient;\n    }\n    GoogleCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // TODO(b/32935141): ideally this would be declared as an extern\n            _this.authClient['getAccessToken'](function (error, tokenLiteral) {\n                if (error) {\n                    reject(error);\n                }\n                else {\n                    resolve(new OAuthToken(tokenLiteral, User.GOOGLE_CREDENTIALS));\n                }\n            });\n        });\n    };\n    // NOTE: A google-auth-library client represents an immutable \"user\", so\n    // once we fire the initial event, it'll never change.\n    GoogleCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        // Fire with initial uid.\n        listener(User.GOOGLE_CREDENTIALS);\n    };\n    GoogleCredentialsProvider.prototype.removeUserChangeListener = function () { };\n    return GoogleCredentialsProvider;\n}());\n\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\nvar credentials_FirstPartyToken = /** @class */ (function () {\n    function FirstPartyToken(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    Object.defineProperty(FirstPartyToken.prototype, \"authHeaders\", {\n        get: function () {\n            return {\n                Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n                'X-Goog-AuthUser': this.sessionIndex\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FirstPartyToken;\n}());\n\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nvar credentials_FirstPartyCredentialsProvider = /** @class */ (function () {\n    function FirstPartyCredentialsProvider(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(new credentials_FirstPartyToken(this.gapi, this.sessionIndex));\n    };\n    // TODO(33108925): can someone switch users w/o a page refresh?\n    // TODO(33110621): need to understand token/session lifecycle\n    FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        // Fire with initial uid.\n        listener(User.FIRST_PARTY);\n    };\n    FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () { };\n    return FirstPartyCredentialsProvider;\n}());\n\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nfunction makeCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new credentials_EmptyCredentialsProvider();\n    }\n    switch (credentials.type) {\n        case 'google-auth':\n            return new credentials_GoogleCredentialsProvider(credentials.client);\n        case 'gapi':\n            return new credentials_FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');\n        case 'provider':\n            return credentials.client;\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n//# sourceMappingURL=credentials.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/observer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isPartialObserver(obj) {\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    var object = obj;\n    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n        var method = methods_1[_i];\n        if (method in object && typeof object[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n\n//# sourceMappingURL=observer.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/field_value.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar api_field_value___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/**\n * An opaque base class for FieldValue sentinel objects in our public API,\n * with public static methods for creating said sentinel objects.\n */\n// tslint:disable-next-line:class-as-namespace  We use this as a base class.\nvar FieldValueImpl = /** @class */ (function () {\n    function FieldValueImpl() {\n    }\n    FieldValueImpl.delete = function () {\n        return DeleteFieldValueImpl.instance;\n    };\n    FieldValueImpl.serverTimestamp = function () {\n        return ServerTimestampFieldValueImpl.instance;\n    };\n    return FieldValueImpl;\n}());\n\nvar DeleteFieldValueImpl = /** @class */ (function (_super) {\n    api_field_value___extends(DeleteFieldValueImpl, _super);\n    function DeleteFieldValueImpl() {\n        return _super.call(this) || this;\n    }\n    /** Singleton instance. */\n    DeleteFieldValueImpl.instance = new DeleteFieldValueImpl();\n    return DeleteFieldValueImpl;\n}(FieldValueImpl));\n\nvar ServerTimestampFieldValueImpl = /** @class */ (function (_super) {\n    api_field_value___extends(ServerTimestampFieldValueImpl, _super);\n    function ServerTimestampFieldValueImpl() {\n        return _super.call(this) || this;\n    }\n    /** Singleton instance. */\n    ServerTimestampFieldValueImpl.instance = new ServerTimestampFieldValueImpl();\n    return ServerTimestampFieldValueImpl;\n}(FieldValueImpl));\n\n// Public instance that disallows construction at runtime. This constructor is\n// used when exporting FieldValueImpl on firebase.firestore.FieldValue and will\n// be called FieldValue publicly. Internally we still use FieldValueImpl which\n// has a type-checked private constructor. Note that FieldValueImpl and\n// PublicFieldValue can be used interchangeably in instanceof checks.\n// For our internal TypeScript code PublicFieldValue doesn't exist as a type,\n// and so we need to use FieldValueImpl as type and export it too.\n// tslint:disable-next-line:variable-name  We treat this as a class name.\nvar PublicFieldValue = makeConstructorPrivate(FieldValueImpl, 'Use FieldValue.<field>() instead.');\n\n//# sourceMappingURL=field_value.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/user_data_converter.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nvar user_data_converter_ParsedSetData = /** @class */ (function () {\n    function ParsedSetData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedSetData.prototype.toMutations = function (key, precondition) {\n        var mutations = [];\n        if (this.fieldMask !== null) {\n            mutations.push(new mutation_PatchMutation(key, this.data, this.fieldMask, precondition));\n        }\n        else {\n            mutations.push(new mutation_SetMutation(key, this.data, precondition));\n        }\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new mutation_TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedSetData;\n}());\n\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nvar user_data_converter_ParsedUpdateData = /** @class */ (function () {\n    function ParsedUpdateData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedUpdateData.prototype.toMutations = function (key, precondition) {\n        var mutations = [\n            new mutation_PatchMutation(key, this.data, this.fieldMask, precondition)\n        ];\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new mutation_TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedUpdateData;\n}());\n\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nvar UserDataSource;\n(function (UserDataSource) {\n    UserDataSource[UserDataSource[\"Set\"] = 0] = \"Set\";\n    UserDataSource[UserDataSource[\"Update\"] = 1] = \"Update\";\n    UserDataSource[UserDataSource[\"MergeSet\"] = 2] = \"MergeSet\";\n    UserDataSource[UserDataSource[\"QueryValue\"] = 3] = \"QueryValue\"; // from a where clause or cursor bound\n})(UserDataSource || (UserDataSource = {}));\nfunction isWrite(dataSource) {\n    switch (dataSource) {\n        case UserDataSource.Set: // fall through\n        case UserDataSource.MergeSet: // fall through\n        case UserDataSource.Update:\n            return true;\n        case UserDataSource.QueryValue:\n            return false;\n        default:\n            throw fail(\"Unexpected case for UserDataSource: \" + dataSource);\n    }\n}\n/** A \"context\" object passed around while parsing user data. */\nvar user_data_converter_ParseContext = /** @class */ (function () {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param dataSource Indicates what kind of API method this data came from.\n     * @param methodName The name of the method the user called to create this\n     *     ParseContext.\n     * @param path A path within the object being parsed. This could be an empty\n     *     path (in which case the context represents the root of the data being\n     *     parsed), or a nonempty path (indicating the context represents a nested\n     *     location within the data).\n     * @param arrayElement Whether or not this context corresponds to an element\n     *     of an array.\n     * @param fieldTransforms A mutable list of field transforms encountered while\n     *     parsing the data.\n     * @param fieldMask A mutable list of field paths encountered while parsing\n     *     the data.\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     */\n    function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) {\n        this.dataSource = dataSource;\n        this.methodName = methodName;\n        this.path = path;\n        this.arrayElement = arrayElement;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.arrayElement = arrayElement !== undefined ? arrayElement : false;\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    ParseContext.prototype.childContextForField = function (field) {\n        var childPath = this.path == null ? null : this.path.child(field);\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, \n        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);\n        context.validatePathSegment(field);\n        return context;\n    };\n    ParseContext.prototype.childContextForFieldPath = function (field) {\n        var childPath = this.path == null ? null : this.path.child(field);\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, \n        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);\n        context.validatePath();\n        return context;\n    };\n    ParseContext.prototype.childContextForArray = function (index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // null.\n        return new ParseContext(this.dataSource, this.methodName, \n        /*path=*/ null, \n        /*arrayElement=*/ true, this.fieldTransforms, this.fieldMask);\n    };\n    ParseContext.prototype.createError = function (reason) {\n        var fieldDescription = this.path === null || this.path.isEmpty()\n            ? ''\n            : \" (found in field \" + this.path.toString() + \")\";\n        return new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" +\n            reason +\n            fieldDescription);\n    };\n    ParseContext.prototype.validatePath = function () {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (this.path === null) {\n            return;\n        }\n        for (var i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    };\n    ParseContext.prototype.validatePathSegment = function (segment) {\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with __');\n        }\n    };\n    ParseContext.prototype.isWrite = function () {\n        return (this.dataSource === UserDataSource.Set ||\n            this.dataSource === UserDataSource.Update);\n    };\n    return ParseContext;\n}());\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\nvar DocumentKeyReference = /** @class */ (function () {\n    function DocumentKeyReference(databaseId, key) {\n        this.databaseId = databaseId;\n        this.key = key;\n    }\n    return DocumentKeyReference;\n}());\n\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nvar user_data_converter_UserDataConverter = /** @class */ (function () {\n    function UserDataConverter(preConverter) {\n        this.preConverter = preConverter;\n    }\n    /** Parse document data from a non-merge set() call.*/\n    UserDataConverter.prototype.parseSetData = function (methodName, input) {\n        var context = new user_data_converter_ParseContext(UserDataSource.Set, methodName, path_FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var updateData = this.parseData(input, context);\n        return new user_data_converter_ParsedSetData(updateData, \n        /* fieldMask= */ null, context.fieldTransforms);\n    };\n    /** Parse document data from a set() call with '{merge:true}'. */\n    UserDataConverter.prototype.parseMergeData = function (methodName, input) {\n        var context = new user_data_converter_ParseContext(UserDataSource.MergeSet, methodName, path_FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var updateData = this.parseData(input, context);\n        var fieldMask = new mutation_FieldMask(context.fieldMask);\n        return new user_data_converter_ParsedSetData(updateData, fieldMask, context.fieldTransforms);\n    };\n    /** Parse update data from an update() call. */\n    UserDataConverter.prototype.parseUpdateData = function (methodName, input) {\n        var _this = this;\n        var context = new user_data_converter_ParseContext(UserDataSource.Update, methodName, path_FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var fieldMaskPaths = [];\n        var updateData = field_value_ObjectValue.EMPTY;\n        forEach(input, function (key, value) {\n            var path = fieldPathFromDotSeparatedString(methodName, key);\n            var childContext = context.childContextForFieldPath(path);\n            value = _this.runPreConverter(value, childContext);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = _this.parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        });\n        var mask = new mutation_FieldMask(fieldMaskPaths);\n        return new user_data_converter_ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /** Parse update data from a list of field/value arguments. */\n    UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) {\n        var context = new user_data_converter_ParseContext(UserDataSource.Update, methodName, path_FieldPath.EMPTY_PATH);\n        var keys = [fieldPathFromArgument(methodName, field)];\n        var values = [value];\n        if (moreFieldsAndValues.length % 2 !== 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() needs to be called with an even number \" +\n                'of arguments that alternate between field names and values.');\n        }\n        for (var i = 0; i < moreFieldsAndValues.length; i += 2) {\n            keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));\n            values.push(moreFieldsAndValues[i + 1]);\n        }\n        var fieldMaskPaths = [];\n        var updateData = field_value_ObjectValue.EMPTY;\n        for (var i = 0; i < keys.length; ++i) {\n            var path = keys[i];\n            var childContext = context.childContextForFieldPath(path);\n            var value_1 = this.runPreConverter(values[i], childContext);\n            if (value_1 instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = this.parseData(value_1, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        }\n        var mask = new mutation_FieldMask(fieldMaskPaths);\n        return new user_data_converter_ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /**\n     * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n     * bound).\n     */\n    UserDataConverter.prototype.parseQueryValue = function (methodName, input) {\n        var context = new user_data_converter_ParseContext(UserDataSource.QueryValue, methodName, path_FieldPath.EMPTY_PATH);\n        var parsed = this.parseData(input, context);\n        assert(parsed != null, 'Parsed data should not be null.');\n        assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');\n        return parsed;\n    };\n    /** Sends data through this.preConverter, handling any thrown errors. */\n    UserDataConverter.prototype.runPreConverter = function (input, context) {\n        try {\n            return this.preConverter(input);\n        }\n        catch (e) {\n            var message = errorMessage(e);\n            throw context.createError(message);\n        }\n    };\n    /**\n     * Internal helper for parsing user data.\n     *\n     * @param input Data to be parsed.\n     * @param context A context object representing the current path being parsed,\n     * the source of the data being parsed, etc.\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseData = function (input, context) {\n        input = this.runPreConverter(input, context);\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            if (context.arrayElement) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            // If context.path is null we are already inside an array and we don't\n            // support field mask paths more granular than the top-level array.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseArray(input, context);\n        }\n        else if (looksLikeJsonObject(input)) {\n            validatePlainObject('Unsupported field value:', context, input);\n            return this.parseObject(input, context);\n        }\n        else {\n            // If context.path is null, we are inside an array and we should have\n            // already added the root of the array to the field mask.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseScalarValue(input, context);\n        }\n    };\n    UserDataConverter.prototype.parseArray = function (array, context) {\n        var result = [];\n        var entryIndex = 0;\n        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n            var entry = array_1[_i];\n            var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));\n            if (parsedEntry == null) {\n                // Just include nulls in the array for fields being replaced with a\n                // sentinel.\n                parsedEntry = NullValue.INSTANCE;\n            }\n            result.push(parsedEntry);\n            entryIndex++;\n        }\n        return new field_value_ArrayValue(result);\n    };\n    UserDataConverter.prototype.parseObject = function (obj, context) {\n        var _this = this;\n        var result = new sorted_map_SortedMap(primitiveComparator);\n        forEach(obj, function (key, val) {\n            var parsedValue = _this.parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                result = result.insert(key, parsedValue);\n            }\n        });\n        return new field_value_ObjectValue(result);\n    };\n    /**\n     * Helper to parse a scalar value (i.e. not an Object or Array)\n     *\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseScalarValue = function (value, context) {\n        if (value === null) {\n            return NullValue.INSTANCE;\n        }\n        else if (typeof value === 'number') {\n            if (isSafeInteger(value)) {\n                return new IntegerValue(value);\n            }\n            else {\n                return new DoubleValue(value);\n            }\n        }\n        else if (typeof value === 'boolean') {\n            return field_value_BooleanValue.of(value);\n        }\n        else if (typeof value === 'string') {\n            return new field_value_StringValue(value);\n        }\n        else if (value instanceof Date) {\n            return new TimestampValue(timestamp_Timestamp.fromDate(value));\n        }\n        else if (value instanceof geo_point_GeoPoint) {\n            return new GeoPointValue(value);\n        }\n        else if (value instanceof blob_Blob) {\n            return new BlobValue(value);\n        }\n        else if (value instanceof DocumentKeyReference) {\n            return new field_value_RefValue(value.databaseId, value.key);\n        }\n        else if (value instanceof FieldValueImpl) {\n            if (value instanceof DeleteFieldValueImpl) {\n                if (context.dataSource == UserDataSource.MergeSet) {\n                    return null;\n                }\n                else if (context.dataSource === UserDataSource.Update) {\n                    assert(context.path == null || context.path.length > 0, 'FieldValue.delete() at the top level should have already' +\n                        ' been handled.');\n                    throw context.createError('FieldValue.delete() can only appear at the top level ' +\n                        'of your update data');\n                }\n                else {\n                    // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n                    throw context.createError('FieldValue.delete() can only be used with update() and set() with {merge:true}');\n                }\n            }\n            else if (value instanceof ServerTimestampFieldValueImpl) {\n                if (!isWrite(context.dataSource)) {\n                    throw context.createError('FieldValue.serverTimestamp() can only be used with set()' +\n                        ' and update()');\n                }\n                if (context.path === null) {\n                    throw context.createError('FieldValue.serverTimestamp() is not currently' +\n                        ' supported inside arrays');\n                }\n                context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance));\n                // Return null so this value is omitted from the parsed result.\n                return null;\n            }\n            else {\n                return fail('Unknown FieldValue type: ' + value);\n            }\n        }\n        else {\n            throw context.createError(\"Unsupported field value: \" + valueDescription(value));\n        }\n    };\n    return UserDataConverter;\n}());\n\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof geo_point_GeoPoint) &&\n        !(input instanceof blob_Blob) &&\n        !(input instanceof DocumentKeyReference) &&\n        !(input instanceof FieldValueImpl));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        var description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nfunction fieldPathFromArgument(methodName, path) {\n    if (path instanceof field_path_FieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        var message = 'Field path arguments must be of type string or FieldPath.';\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path) {\n    try {\n        return fromDotSeparatedString(path)._internalPath;\n    }\n    catch (e) {\n        var message = errorMessage(e);\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error) {\n    return error instanceof Error ? error.message : error.toString();\n}\n\n//# sourceMappingURL=user_data_converter.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/database.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar database___extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\nvar DEFAULT_HOST = 'firestore.googleapis.com';\nvar DEFAULT_SSL = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nvar database_FirestoreSettings = /** @class */ (function () {\n    function FirestoreSettings(settings) {\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            validateNamedType('settings', 'string', 'host', settings.host);\n            this.host = settings.host;\n            validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n            this.ssl = defaulted(settings.ssl, DEFAULT_SSL);\n        }\n        validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);\n        validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);\n        this.credentials = settings.credentials;\n    }\n    FirestoreSettings.prototype.equals = function (other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials);\n    };\n    return FirestoreSettings;\n}());\nvar FirestoreConfig = /** @class */ (function () {\n    function FirestoreConfig() {\n    }\n    return FirestoreConfig;\n}());\n/**\n * The root reference to the database.\n */\nvar database_Firestore = /** @class */ (function () {\n    function Firestore(databaseIdOrApp) {\n        var _this = this;\n        this.INTERNAL = {\n            delete: function () {\n                if (_this._firestoreClient) {\n                    return _this._firestoreClient.shutdown();\n                }\n                else {\n                    return Promise.resolve();\n                }\n            },\n            // Exposed via INTERNAL for use in tests.\n            disableNetwork: function () { return _this._firestoreClient.disableNetwork(); },\n            enableNetwork: function () { return _this._firestoreClient.enableNetwork(); }\n        };\n        var config = new FirestoreConfig();\n        if (typeof databaseIdOrApp.options === 'object') {\n            // This is very likely a Firebase app object\n            // TODO(b/34177605): Can we somehow use instanceof?\n            var app = databaseIdOrApp;\n            config.firebaseApp = app;\n            config.databaseId = Firestore.databaseIdFromApp(app);\n            config.persistenceKey = config.firebaseApp.name;\n            config.credentials = new credentials_FirebaseCredentialsProvider(app);\n        }\n        else {\n            var external_1 = databaseIdOrApp;\n            if (!external_1.projectId) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');\n            }\n            config.databaseId = new database_info_DatabaseId(external_1.projectId, external_1.database);\n            // Use a default persistenceKey that lines up with FirebaseApp.\n            config.persistenceKey = '[DEFAULT]';\n            config.credentials = new credentials_EmptyCredentialsProvider();\n        }\n        config.settings = new database_FirestoreSettings({});\n        this._config = config;\n        this._databaseId = config.databaseId;\n    }\n    Firestore.prototype.settings = function (settingsLiteral) {\n        validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n        validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n        if (contains(settingsLiteral, 'persistence')) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to ' +\n                'firestore.enablePersistence().');\n        }\n        var newSettings = new database_FirestoreSettings(settingsLiteral);\n        if (this._firestoreClient && !this._config.settings.equals(newSettings)) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only call settings() before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._config.settings = newSettings;\n        if (newSettings.credentials !== undefined) {\n            this._config.credentials = makeCredentialsProvider(newSettings.credentials);\n        }\n    };\n    Firestore.prototype.enablePersistence = function () {\n        if (this._firestoreClient) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' +\n                'be enabled. You can only call enablePersistence() before calling ' +\n                'any other methods on a Firestore object.');\n        }\n        return this.configureClient(/* persistence= */ true);\n    };\n    Firestore.prototype.ensureClientConfigured = function () {\n        if (!this._firestoreClient) {\n            this.configureClient(/* persistence= */ false);\n        }\n        return this._firestoreClient;\n    };\n    Firestore.prototype.configureClient = function (persistence) {\n        var _this = this;\n        assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');\n        assert(!this._firestoreClient, 'configureClient() called multiple times');\n        var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);\n        var preConverter = function (value) {\n            if (value instanceof database_DocumentReference) {\n                var thisDb = _this._config.databaseId;\n                var otherDb = value.firestore._config.databaseId;\n                if (!otherDb.equals(thisDb)) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' +\n                        (otherDb.projectId + \"/\" + otherDb.database + \" but should be \") +\n                        (\"for database \" + thisDb.projectId + \"/\" + thisDb.database));\n                }\n                return new DocumentKeyReference(_this._config.databaseId, value._key);\n            }\n            else {\n                return value;\n            }\n        };\n        this._dataConverter = new user_data_converter_UserDataConverter(preConverter);\n        this._firestoreClient = new firestore_client_FirestoreClient(platform_PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, new async_queue_AsyncQueue());\n        return this._firestoreClient.start(persistence);\n    };\n    Firestore.databaseIdFromApp = function (app) {\n        var options = app.options;\n        if (!contains(options, 'projectId')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreId' once alpha testers have upgraded.\n            if (contains(options, 'firestoreId')) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreId\" is now specified as \"projectId\" in ' +\n                    'firebase.initializeApp.');\n            }\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n        }\n        if (contains(options, 'firestoreOptions')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreOptions' once alpha testers have upgraded.\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreOptions\" values are now specified with ' +\n                'Firestore.settings()');\n        }\n        var projectId = options['projectId'];\n        if (!projectId || typeof projectId !== 'string') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in FirebaseApp.options');\n        }\n        return new database_info_DatabaseId(projectId);\n    };\n    Object.defineProperty(Firestore.prototype, \"app\", {\n        get: function () {\n            if (!this._config.firebaseApp) {\n                throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                    'not available');\n            }\n            return this._config.firebaseApp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n        validateArgType('Firestore.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');\n        }\n        this.ensureClientConfigured();\n        return new database_CollectionReference(path_ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.doc = function (pathString) {\n        validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n        validateArgType('Firestore.doc', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');\n        }\n        this.ensureClientConfigured();\n        return database_DocumentReference.forPath(path_ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.runTransaction = function (updateFunction) {\n        var _this = this;\n        validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n        validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n        return this.ensureClientConfigured().transaction(function (transaction) {\n            return updateFunction(new database_Transaction(_this, transaction));\n        });\n    };\n    Firestore.prototype.batch = function () {\n        this.ensureClientConfigured();\n        return new database_WriteBatch(this);\n    };\n    Object.defineProperty(Firestore, \"logLevel\", {\n        get: function () {\n            switch (getLogLevel()) {\n                case LogLevel.DEBUG:\n                    return 'debug';\n                case LogLevel.ERROR:\n                    return 'error';\n                case LogLevel.SILENT:\n                    return 'silent';\n                default:\n                    return fail('Unknown log level: ' + getLogLevel());\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.setLogLevel = function (level) {\n        validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n        validateArgType('Firestore.setLogLevel', 'string', 1, level);\n        switch (level) {\n            case 'debug':\n                setLogLevel(LogLevel.DEBUG);\n                break;\n            case 'error':\n                setLogLevel(LogLevel.ERROR);\n                break;\n            case 'silent':\n                setLogLevel(LogLevel.SILENT);\n                break;\n            default:\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);\n        }\n    };\n    return Firestore;\n}());\n\n/**\n * A reference to a transaction.\n */\nvar database_Transaction = /** @class */ (function () {\n    function Transaction(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n    }\n    Transaction.prototype.get = function (documentRef) {\n        var _this = this;\n        validateExactNumberOfArgs('Transaction.get', arguments, 1);\n        var ref = validateReference('Transaction.get', documentRef, this._firestore);\n        return this._transaction\n            .lookup([ref._key])\n            .then(function (docs) {\n            if (!docs || docs.length !== 1) {\n                return fail('Mismatch in docs returned from document lookup.');\n            }\n            var doc = docs[0];\n            if (doc instanceof document_NoDocument) {\n                return new database_DocumentSnapshot(_this._firestore, ref._key, null, false);\n            }\n            return new database_DocumentSnapshot(_this._firestore, ref._key, doc, false);\n        });\n    };\n    Transaction.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n        var ref = validateReference('Transaction.set', documentRef, this._firestore);\n        options = validateSetOptions('Transaction.set', options);\n        var parsed = options.merge\n            ? this._firestore._dataConverter.parseMergeData('Transaction.set', value)\n            : this._firestore._dataConverter.parseSetData('Transaction.set', value);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof field_path_FieldPath) {\n            validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('Transaction.update', arguments, 2);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n        var ref = validateReference('Transaction.delete', documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    };\n    return Transaction;\n}());\n\nvar database_WriteBatch = /** @class */ (function () {\n    function WriteBatch(_firestore) {\n        this._firestore = _firestore;\n        this._mutations = [];\n        this._committed = false;\n    }\n    WriteBatch.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.set', documentRef, this._firestore);\n        options = validateSetOptions('WriteBatch.set', options);\n        var parsed = options.merge\n            ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value)\n            : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, mutation_Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        this.verifyNotCommitted();\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof field_path_FieldPath) {\n            validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);\n        }\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, mutation_Precondition.exists(true)));\n        return this;\n    };\n    WriteBatch.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new mutation_DeleteMutation(ref._key, mutation_Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.commit = function () {\n        this.verifyNotCommitted();\n        this._committed = true;\n        if (this._mutations.length > 0) {\n            return this._firestore.ensureClientConfigured().write(this._mutations);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    WriteBatch.prototype.verifyNotCommitted = function () {\n        if (this._committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    };\n    return WriteBatch;\n}());\n\n/**\n * A reference to a particular document in a collection in the database.\n */\nvar database_DocumentReference = /** @class */ (function () {\n    function DocumentReference(_key, firestore) {\n        this._key = _key;\n        this.firestore = firestore;\n        this._firestoreClient = this.firestore.ensureClientConfigured();\n    }\n    DocumentReference.forPath = function (path, firestore) {\n        if (path.length % 2 !== 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' +\n                'references must have an even number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return new DocumentReference(new document_key_DocumentKey(path), firestore);\n    };\n    Object.defineProperty(DocumentReference.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"parent\", {\n        get: function () {\n            return new database_CollectionReference(this._key.path.popLast(), this.firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"path\", {\n        get: function () {\n            return this._key.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentReference.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n        validateArgType('DocumentReference.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');\n        }\n        var path = path_ResourcePath.fromString(pathString);\n        return new database_CollectionReference(this._key.path.child(path), this.firestore);\n    };\n    DocumentReference.prototype.isEqual = function (other) {\n        if (!(other instanceof DocumentReference)) {\n            throw invalidClassError('isEqual', 'DocumentReference', 1, other);\n        }\n        return this.firestore === other.firestore && this._key.equals(other._key);\n    };\n    DocumentReference.prototype.set = function (value, options) {\n        validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n        options = validateSetOptions('DocumentReference.set', options);\n        var parsed = options.merge\n            ? this.firestore._dataConverter.parseMergeData('DocumentReference.set', value)\n            : this.firestore._dataConverter.parseSetData('DocumentReference.set', value);\n        return this._firestoreClient.write(parsed.toMutations(this._key, mutation_Precondition.NONE));\n    };\n    DocumentReference.prototype.update = function (fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 2] = arguments[_i];\n        }\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof field_path_FieldPath) {\n            validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n            parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n            parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);\n        }\n        return this._firestoreClient.write(parsed.toMutations(this._key, mutation_Precondition.exists(true)));\n    };\n    DocumentReference.prototype.delete = function () {\n        validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n        return this._firestoreClient.write([\n            new mutation_DeleteMutation(this._key, mutation_Precondition.NONE)\n        ]);\n    };\n    DocumentReference.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);\n        var options = {\n            includeMetadataChanges: false\n        };\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('DocumentReference.onSnapshot', options, [\n                'includeMetadataChanges'\n            ]);\n            validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);\n            currArg++;\n        }\n        var internalOptions = {\n            includeDocumentMetadataChanges: options.includeMetadataChanges,\n            includeQueryMetadataChanges: options.includeMetadataChanges\n        };\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(internalOptions, observer);\n    };\n    DocumentReference.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (snapshot) {\n                if (observer.next) {\n                    assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');\n                    var doc = snapshot.docs.get(_this._key);\n                    observer.next(new database_DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));\n                }\n            },\n            error: errHandler\n        });\n        var internalListener = this._firestoreClient.listen(query_Query.atPath(this._key.path), asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            _this._firestoreClient.unlisten(internalListener);\n        };\n    };\n    DocumentReference.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('DocumentReference.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeQueryMetadataChanges: true,\n                includeDocumentMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (snap) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    if (!snap.exists && snap.metadata.fromCache) {\n                        // TODO(dimond): If we're online and the document doesn't\n                        // exist then we resolve with a doc.exists set to false. If\n                        // we're offline however, we reject the Promise in this\n                        // case. Two options: 1) Cache the negative response from\n                        // the server so we can deliver that even when you're\n                        // offline 2) Actually reject the Promise in the online case\n                        // if the document doesn't exist.\n                        reject(new FirestoreError(Code.ABORTED, 'Failed to get document because the client is ' + 'offline.'));\n                    }\n                    else {\n                        resolve(snap);\n                    }\n                },\n                error: reject\n            });\n        });\n    };\n    return DocumentReference;\n}());\n\nvar database_DocumentSnapshot = /** @class */ (function () {\n    function DocumentSnapshot(_firestore, _key, _document, _fromCache) {\n        this._firestore = _firestore;\n        this._key = _key;\n        this._document = _document;\n        this._fromCache = _fromCache;\n    }\n    DocumentSnapshot.prototype.data = function () {\n        validateExactNumberOfArgs('DocumentSnapshot.data', arguments, 0);\n        if (!this._document) {\n            throw new FirestoreError(Code.NOT_FOUND, \"This document doesn't exist. Check doc.exists to make sure \" +\n                'the document exists before calling doc.data().');\n        }\n        return this.convertObject(this._document.data);\n    };\n    DocumentSnapshot.prototype.get = function (fieldPath) {\n        validateExactNumberOfArgs('DocumentSnapshot.get', arguments, 1);\n        if (!this._document) {\n            throw new FirestoreError(Code.NOT_FOUND, \"This document doesn't exist. Check doc.exists to make sure \" +\n                'the document exists before calling doc.get().');\n        }\n        var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n        return value === undefined ? undefined : this.convertValue(value);\n    };\n    Object.defineProperty(DocumentSnapshot.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"ref\", {\n        get: function () {\n            return new database_DocumentReference(this._key, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"exists\", {\n        get: function () {\n            return this._document !== null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"metadata\", {\n        get: function () {\n            return {\n                hasPendingWrites: this._document !== null && this._document.hasLocalMutations,\n                fromCache: this._fromCache\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentSnapshot.prototype.convertObject = function (data) {\n        var _this = this;\n        var result = {};\n        data.forEach(function (key, value) {\n            result[key] = _this.convertValue(value);\n        });\n        return result;\n    };\n    DocumentSnapshot.prototype.convertValue = function (value) {\n        if (value instanceof field_value_ObjectValue) {\n            return this.convertObject(value);\n        }\n        else if (value instanceof field_value_ArrayValue) {\n            return this.convertArray(value);\n        }\n        else if (value instanceof field_value_RefValue) {\n            var key = value.value();\n            var database = this._firestore.ensureClientConfigured().databaseId();\n            if (!value.databaseId.equals(database)) {\n                // TODO(b/64130202): Somehow support foreign references.\n                log_error(\"Document \" + this._key.path + \" contains a document \" +\n                    \"reference within a different database (\" +\n                    (value.databaseId.projectId + \"/\" + value.databaseId\n                        .database + \") which is not \") +\n                    \"supported. It will be treated as a reference in the current \" +\n                    (\"database (\" + database.projectId + \"/\" + database.database + \") \") +\n                    \"instead.\");\n            }\n            return new database_DocumentReference(key, this._firestore);\n        }\n        else {\n            return value.value();\n        }\n    };\n    DocumentSnapshot.prototype.convertArray = function (data) {\n        var _this = this;\n        return data.internalValue.map(function (value) {\n            return _this.convertValue(value);\n        });\n    };\n    return DocumentSnapshot;\n}());\n\nvar database_Query = /** @class */ (function () {\n    function Query(_query, firestore) {\n        this._query = _query;\n        this.firestore = firestore;\n    }\n    Query.prototype.where = function (field, opStr, value) {\n        validateExactNumberOfArgs('Query.where', arguments, 3);\n        validateArgType('Query.where', 'string', 2, opStr);\n        validateDefined('Query.where', 3, value);\n        var fieldValue;\n        var fieldPath = fieldPathFromArgument('Query.where', field);\n        if (fieldPath.isKeyField()) {\n            if (typeof value === 'string') {\n                if (value.indexOf('/') !== -1) {\n                    // TODO(dimond): Allow slashes once ancestor queries are supported\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it contains a slash.');\n                }\n                if (value === '') {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it was an empty string.');\n                }\n                var path = this._query.path.child(new path_ResourcePath([value]));\n                assert(path.length % 2 === 0, 'Path should be a document key');\n                fieldValue = new field_value_RefValue(this.firestore._databaseId, new document_key_DocumentKey(path));\n            }\n            else if (value instanceof database_DocumentReference) {\n                var ref = value;\n                fieldValue = new field_value_RefValue(this.firestore._databaseId, ref._key);\n            }\n            else {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a \" +\n                    \"string or a DocumentReference if the first parameter is \" +\n                    \"FieldPath.documentId(), but it was: \" +\n                    (valueDescription(value) + \".\"));\n            }\n        }\n        else {\n            fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);\n        }\n        var filter = fieldFilter(fieldPath, query_RelationOp.fromString(opStr), fieldValue);\n        this.validateNewFilter(filter);\n        return new Query(this._query.addFilter(filter), this.firestore);\n    };\n    Query.prototype.orderBy = function (field, directionStr) {\n        validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n        validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);\n        var direction;\n        if (directionStr === undefined || directionStr === 'asc') {\n            direction = Direction.ASCENDING;\n        }\n        else if (directionStr === 'desc') {\n            direction = Direction.DESCENDING;\n        }\n        else {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + directionStr + \"', \" +\n                \"expected 'asc' or 'desc'.\");\n        }\n        if (this._query.startAt !== null) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' +\n                'Query.startAfter() before calling Query.orderBy().');\n        }\n        if (this._query.endAt !== null) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' +\n                'Query.endBefore() before calling Query.orderBy().');\n        }\n        var fieldPath = fieldPathFromArgument('Query.orderBy', field);\n        var orderBy = new query_OrderBy(fieldPath, direction);\n        this.validateNewOrderBy(orderBy);\n        return new Query(this._query.addOrderBy(orderBy), this.firestore);\n    };\n    Query.prototype.limit = function (n) {\n        validateExactNumberOfArgs('Query.limit', arguments, 1);\n        validateArgType('Query.limit', 'number', 1, n);\n        if (n <= 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + n + \") is invalid. Limit must be \" +\n                'positive.');\n        }\n        return new Query(this._query.withLimit(n), this.firestore);\n    };\n    Query.prototype.startAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.startAfter = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.endBefore = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.endAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.isEqual = function (other) {\n        if (!(other instanceof Query)) {\n            throw invalidClassError('isEqual', 'Query', 1, other);\n        }\n        return (this.firestore === other.firestore && this._query.equals(other._query));\n    };\n    /** Helper function to create a bound from a document or fields */\n    Query.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) {\n        validateDefined(methodName, 1, docOrField);\n        if (docOrField instanceof database_DocumentSnapshot) {\n            if (fields.length > 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"().\");\n            }\n            var snap = docOrField;\n            if (!snap.exists) {\n                throw new FirestoreError(Code.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" +\n                    (methodName + \"().\"));\n            }\n            return this.boundFromDocument(methodName, snap._document, before);\n        }\n        else {\n            var allFields = [docOrField].concat(fields);\n            return this.boundFromFields(methodName, allFields, before);\n        }\n    };\n    /**\n     * Create a Bound from a query and a document.\n     *\n     * Note that the Bound will always include the key of the document\n     * and so only the provided document will compare equal to the returned\n     * position.\n     *\n     * Will throw if the document does not contain all fields of the order by\n     * of the query.\n     */\n    Query.prototype.boundFromDocument = function (methodName, doc, before) {\n        var components = [];\n        // Because people expect to continue/end a query at the exact document\n        // provided, we need to use the implicit sort order rather than the explicit\n        // sort order, because it's guaranteed to contain the document key. That way\n        // the position becomes unambiguous and the query continues/ends exactly at\n        // the provided document. Without the key (by using the explicit sort\n        // orders), multiple documents could match the position, yielding duplicate\n        // results.\n        for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            if (orderBy.field.isKeyField()) {\n                components.push(new field_value_RefValue(this.firestore._databaseId, doc.key));\n            }\n            else {\n                var value = doc.field(orderBy.field);\n                if (value !== undefined) {\n                    components.push(value);\n                }\n                else {\n                    var field = orderBy.field.canonicalString();\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a \" +\n                        (\"document for which the field '\" + field + \"' (used as the \") +\n                        \"orderBy) does not exist.\");\n                }\n            }\n        }\n        return new query_Bound(components, before);\n    };\n    /**\n     * Converts a list of field values to a Bound for the given query.\n     */\n    Query.prototype.boundFromFields = function (methodName, values, before) {\n        // Use explicit order by's because it has to match the query the user made\n        var orderBy = this._query.explicitOrderBy;\n        if (values.length > orderBy.length) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"(). \" +\n                \"The number of arguments must be less than or equal to the \" +\n                \"number of Query.orderBy() clauses\");\n        }\n        var components = [];\n        for (var i = 0; i < values.length; i++) {\n            var rawValue = values[i];\n            var orderByComponent = orderBy[i];\n            if (orderByComponent.field.isKeyField()) {\n                if (typeof rawValue !== 'string') {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" +\n                        (methodName + \"(), but got a \" + typeof rawValue));\n                }\n                if (rawValue.indexOf('/') !== -1) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Document ID '\" + rawValue + \"' contains a slash in \" +\n                        (methodName + \"()\"));\n                }\n                var key = new document_key_DocumentKey(this._query.path.child(rawValue));\n                components.push(new field_value_RefValue(this.firestore._databaseId, key));\n            }\n            else {\n                var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);\n                components.push(wrapped);\n            }\n        }\n        return new query_Bound(components, before);\n    };\n    Query.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n        var options = {};\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('Query.onSnapshot', options, [\n                'includeQueryMetadataChanges',\n                'includeDocumentMetadataChanges'\n            ]);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeDocumentMetadataChanges', options.includeDocumentMetadataChanges);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeQueryMetadataChanges', options.includeQueryMetadataChanges);\n            currArg++;\n        }\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(options, observer);\n    };\n    Query.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (result) {\n                if (observer.next) {\n                    observer.next(new database_QuerySnapshot(_this.firestore, _this._query, result));\n                }\n            },\n            error: errHandler\n        });\n        var firestoreClient = this.firestore.ensureClientConfigured();\n        var internalListener = firestoreClient.listen(this._query, asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            firestoreClient.unlisten(internalListener);\n        };\n    };\n    Query.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('Query.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeDocumentMetadataChanges: false,\n                includeQueryMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (result) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    resolve(result);\n                },\n                error: reject\n            });\n        });\n    };\n    Query.prototype.validateNewFilter = function (filter) {\n        if (filter instanceof query_RelationFilter && filter.isInequality()) {\n            var existingField = this._query.getInequalityFilterField();\n            if (existingField !== null && !existingField.equals(filter.field)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' +\n                    ' (<, <=, >, or >=) must be on the same field. But you have' +\n                    (\" inequality filters on '\" + existingField.toString() + \"'\") +\n                    (\" and '\" + filter.field.toString() + \"'\"));\n            }\n            var firstOrderByField = this._query.getFirstOrderByField();\n            if (firstOrderByField !== null) {\n                this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);\n            }\n        }\n    };\n    Query.prototype.validateNewOrderBy = function (orderBy) {\n        if (this._query.getFirstOrderByField() === null) {\n            // This is the first order by. It must match any inequality.\n            var inequalityField = this._query.getInequalityFilterField();\n            if (inequalityField !== null) {\n                this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n            }\n        }\n    };\n    Query.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) {\n        if (!orderBy.equals(inequality)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality \" +\n                (\"(<, <=, >, or >=) on field '\" + inequality.toString() + \"' \") +\n                (\"and so you must also use '\" + inequality.toString() + \"' \") +\n                \"as your first Query.orderBy(), but your first Query.orderBy() \" +\n                (\"is on field '\" + orderBy.toString() + \"' instead.\"));\n        }\n    };\n    return Query;\n}());\n\nvar database_QuerySnapshot = /** @class */ (function () {\n    function QuerySnapshot(_firestore, _originalQuery, _snapshot) {\n        this._firestore = _firestore;\n        this._originalQuery = _originalQuery;\n        this._snapshot = _snapshot;\n        this._cachedChanges = null;\n        this.metadata = {\n            fromCache: _snapshot.fromCache,\n            hasPendingWrites: _snapshot.hasPendingWrites\n        };\n    }\n    Object.defineProperty(QuerySnapshot.prototype, \"docs\", {\n        get: function () {\n            var result = [];\n            this.forEach(function (doc) { return result.push(doc); });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"empty\", {\n        get: function () {\n            return this._snapshot.docs.isEmpty();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"size\", {\n        get: function () {\n            return this._snapshot.docs.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QuerySnapshot.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n        validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n        this._snapshot.docs.forEach(function (doc) {\n            callback.call(thisArg, _this.convertToDocumentImpl(doc));\n        });\n    };\n    Object.defineProperty(QuerySnapshot.prototype, \"query\", {\n        get: function () {\n            return new database_Query(this._originalQuery, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"docChanges\", {\n        get: function () {\n            if (!this._cachedChanges) {\n                this._cachedChanges = changesFromSnapshot(this._firestore, this._snapshot);\n            }\n            return this._cachedChanges;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QuerySnapshot.prototype.convertToDocumentImpl = function (doc) {\n        return new database_DocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);\n    };\n    return QuerySnapshot;\n}());\n\nvar database_CollectionReference = /** @class */ (function (_super) {\n    database___extends(CollectionReference, _super);\n    function CollectionReference(path, firestore) {\n        var _this = _super.call(this, query_Query.atPath(path), firestore) || this;\n        if (path.length % 2 !== 1) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' +\n                'references must have an odd number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return _this;\n    }\n    Object.defineProperty(CollectionReference.prototype, \"id\", {\n        get: function () {\n            return this._query.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"parent\", {\n        get: function () {\n            var parentPath = this._query.path.popLast();\n            if (parentPath.isEmpty()) {\n                return null;\n            }\n            else {\n                return new database_DocumentReference(new document_key_DocumentKey(parentPath), this.firestore);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"path\", {\n        get: function () {\n            return this._query.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CollectionReference.prototype.doc = function (pathString) {\n        validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);\n        // We allow omission of 'pathString' but explicitly prohibit passing in both\n        // 'undefined' and 'null'.\n        if (arguments.length === 0) {\n            pathString = misc_AutoId.newId();\n        }\n        validateArgType('CollectionReference.doc', 'string', 1, pathString);\n        if (pathString === '') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');\n        }\n        var path = path_ResourcePath.fromString(pathString);\n        return database_DocumentReference.forPath(this._query.path.child(path), this.firestore);\n    };\n    CollectionReference.prototype.add = function (value) {\n        validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n        validateArgType('CollectionReference.add', 'object', 1, value);\n        var docRef = this.doc();\n        return docRef.set(value).then(function () { return docRef; });\n    };\n    return CollectionReference;\n}(database_Query));\n\nfunction validateSetOptions(methodName, options) {\n    if (options === undefined) {\n        return {\n            merge: false\n        };\n    }\n    validateOptionNames(methodName, options, ['merge']);\n    validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n    return options;\n}\nfunction validateReference(methodName, documentRef, firestore) {\n    if (!(documentRef instanceof database_DocumentReference)) {\n        throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n    }\n    else if (documentRef.firestore !== firestore) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\nfunction changesFromSnapshot(firestore, snapshot) {\n    if (snapshot.oldDocs.isEmpty()) {\n        // Special case the first snapshot because index calculation is easy and\n        // fast\n        var lastDoc_1;\n        var index_1 = 0;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new database_DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');\n            assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');\n            lastDoc_1 = change.doc;\n            return {\n                type: 'added',\n                doc: doc,\n                oldIndex: -1,\n                newIndex: index_1++\n            };\n        });\n    }\n    else {\n        // A DocumentSet that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        var indexTracker_1 = snapshot.oldDocs;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new database_DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            var oldIndex = -1;\n            var newIndex = -1;\n            if (change.type !== ChangeType.Added) {\n                oldIndex = indexTracker_1.indexOf(change.doc.key);\n                assert(oldIndex >= 0, 'Index for document not found');\n                indexTracker_1 = indexTracker_1.delete(change.doc.key);\n            }\n            if (change.type !== ChangeType.Removed) {\n                indexTracker_1 = indexTracker_1.add(change.doc);\n                newIndex = indexTracker_1.indexOf(change.doc.key);\n            }\n            return { type: resultChangeType(change.type), doc: doc, oldIndex: oldIndex, newIndex: newIndex };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case ChangeType.Added:\n            return 'added';\n        case ChangeType.Modified:\n        case ChangeType.Metadata:\n            return 'modified';\n        case ChangeType.Removed:\n            return 'removed';\n        default:\n            return fail('Unknown change type: ' + type);\n    }\n}\n// Export the classes with a private constructor (it will fail if invoked\n// at runtime). Note that this still allows instanceof checks.\n// We're treating the variables as class names, so disable checking for lower\n// case variable names.\n// tslint:disable:variable-name\nvar PublicFirestore = makeConstructorPrivate(database_Firestore, 'Use firebase.firestore() instead.');\nvar PublicTransaction = makeConstructorPrivate(database_Transaction, 'Use firebase.firestore().runTransaction() instead.');\nvar PublicWriteBatch = makeConstructorPrivate(database_WriteBatch, 'Use firebase.firestore().batch() instead.');\nvar PublicDocumentReference = makeConstructorPrivate(database_DocumentReference, 'Use firebase.firestore().doc() instead.');\nvar PublicDocumentSnapshot = makeConstructorPrivate(database_DocumentSnapshot);\nvar PublicQuery = makeConstructorPrivate(database_Query);\nvar PublicQuerySnapshot = makeConstructorPrivate(database_QuerySnapshot);\nvar PublicCollectionReference = makeConstructorPrivate(database_CollectionReference, 'Use firebase.firestore().collection() instead.');\n// tslint:enable:variable-name\n\n//# sourceMappingURL=database.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform/config.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\nvar firestoreNamespace = {\n    Firestore: PublicFirestore,\n    GeoPoint: geo_point_GeoPoint,\n    Blob: PublicBlob,\n    Transaction: PublicTransaction,\n    WriteBatch: PublicWriteBatch,\n    DocumentReference: PublicDocumentReference,\n    DocumentSnapshot: PublicDocumentSnapshot,\n    Query: PublicQuery,\n    QuerySnapshot: PublicQuerySnapshot,\n    CollectionReference: PublicCollectionReference,\n    FieldPath: field_path_FieldPath,\n    FieldValue: PublicFieldValue,\n    setLogLevel: database_Firestore.setLogLevel\n};\n/**\n * Configures Firestore as part of the Firebase SDK by calling registerService.\n */\nfunction configureForFirebase(firebase) {\n    firebase.INTERNAL.registerService('firestore', function (app) { return new database_Firestore(app); }, shallowCopy(firestoreNamespace));\n}\n/**\n * Exports the Firestore namespace into the provided `exportObject` object under\n * the key 'firestore'. This is used for wrapped binary that exposes Firestore\n * as a goog module.\n */\nfunction configureForStandalone(exportObject) {\n    var copiedNamespace = shallowCopy(firestoreNamespace);\n    // Unlike the use with Firebase, the standalone allows the use of the\n    // constructor, so export it's internal class\n    copiedNamespace['Firestore'] = database_Firestore;\n    exportObject['firestore'] = copiedNamespace;\n}\n\n//# sourceMappingURL=config.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/index.js\n/* harmony export (immutable) */ __webpack_exports__[\"registerFirestore\"] = registerFirestore;\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nfunction registerFirestore(instance) {\n    configureForFirebase(instance);\n}\nregisterFirestore(esm[\"default\"]);\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n\n/***/ 115:\n/***/ (function(module, exports, __webpack_require__) {\n\n(function() {var g,goog=goog||{},k=this;function l(a){return\"string\"==typeof a}function aa(){}\nfunction ba(a){var b=typeof a;if(\"object\"==b)if(a){if(a instanceof Array)return\"array\";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if(\"[object Window]\"==c)return\"object\";if(\"[object Array]\"==c||\"number\"==typeof a.length&&\"undefined\"!=typeof a.splice&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"splice\"))return\"array\";if(\"[object Function]\"==c||\"undefined\"!=typeof a.call&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"call\"))return\"function\"}else return\"null\";\nelse if(\"function\"==b&&\"undefined\"==typeof a.call)return\"object\";return b}function n(a){return\"array\"==ba(a)}function ca(a){var b=ba(a);return\"array\"==b||\"object\"==b&&\"number\"==typeof a.length}function da(a){return\"function\"==ba(a)}function p(a){var b=typeof a;return\"object\"==b&&null!=a||\"function\"==b}var q=\"closure_uid_\"+(1E9*Math.random()>>>0),ea=0;function fa(a,b,c){return a.call.apply(a.bind,arguments)}\nfunction ha(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function r(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf(\"native code\")?r=fa:r=ha;return r.apply(null,arguments)}\nfunction ia(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}var t=Date.now||function(){return+new Date};function u(a,b){function c(){}c.prototype=b.prototype;a.L=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Bb=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};function ja(a){if(Error.captureStackTrace)Error.captureStackTrace(this,ja);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}u(ja,Error);ja.prototype.name=\"CustomError\";function ka(a,b){for(var c=a.split(\"%s\"),d=\"\",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join(\"%s\")}var la=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g,\"\")};function ma(a,b){return a<b?-1:a>b?1:0};function na(a,b){b.unshift(a);ja.call(this,ka.apply(null,b));b.shift()}u(na,ja);na.prototype.name=\"AssertionError\";function oa(a,b){throw new na(\"Failure\"+(a?\": \"+a:\"\"),Array.prototype.slice.call(arguments,1));};function w(){0!=qa&&(ra[this[q]||(this[q]=++ea)]=this);this.i=this.i;this.v=this.v}var qa=0,ra={};w.prototype.i=!1;w.prototype.Y=function(){if(!this.i&&(this.i=!0,this.w(),0!=qa)){var a=this[q]||(this[q]=++ea);delete ra[a]}};w.prototype.w=function(){if(this.v)for(;this.v.length;)this.v.shift()()};var sa=Array.prototype.indexOf?function(a,b,c){return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(l(a))return l(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},ta=Array.prototype.forEach?function(a,b,c){Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=l(a)?a.split(\"\"):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};\nfunction ua(a){a:{var b=va;for(var c=a.length,d=l(a)?a.split(\"\"):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:l(a)?a.charAt(b):a[b]}function wa(a){if(!n(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0}function xa(a){return Array.prototype.concat.apply([],arguments)}function ya(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};var x;a:{var za=k.navigator;if(za){var Aa=za.userAgent;if(Aa){x=Aa;break a}}x=\"\"}function y(a){return-1!=x.indexOf(a)};function Ba(a,b,c){for(var d in a)b.call(c,a[d],d,a)}function Ca(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Da(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function Ea(a){var b={},c;for(c in a)b[c]=a[c];return b}var Fa=\"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\nfunction Ga(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Fa.length;f++)c=Fa[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Ha(a){Ha[\" \"](a);return a}Ha[\" \"]=aa;function Ia(a,b){var c=Ja;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)};var Ka=y(\"Opera\"),z=y(\"Trident\")||y(\"MSIE\"),La=y(\"Edge\"),Ma=y(\"Gecko\")&&!(-1!=x.toLowerCase().indexOf(\"webkit\")&&!y(\"Edge\"))&&!(y(\"Trident\")||y(\"MSIE\"))&&!y(\"Edge\"),Na=-1!=x.toLowerCase().indexOf(\"webkit\")&&!y(\"Edge\");function Oa(){var a=k.document;return a?a.documentMode:void 0}var Pa;\na:{var Qa=\"\",Ra=function(){var a=x;if(Ma)return/rv:([^\\);]+)(\\)|;)/.exec(a);if(La)return/Edge\\/([\\d\\.]+)/.exec(a);if(z)return/\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(a);if(Na)return/WebKit\\/(\\S+)/.exec(a);if(Ka)return/(?:Version)[ \\/]?(\\S+)/.exec(a)}();Ra&&(Qa=Ra?Ra[1]:\"\");if(z){var Ta=Oa();if(null!=Ta&&Ta>parseFloat(Qa)){Pa=String(Ta);break a}}Pa=Qa}var Ja={};\nfunction Ua(a){return Ia(a,function(){for(var b=0,c=la(String(Pa)).split(\".\"),d=la(String(a)).split(\".\"),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var h=c[f]||\"\",m=d[f]||\"\";do{h=/(\\d*)(\\D*)(.*)/.exec(h)||[\"\",\"\",\"\",\"\"];m=/(\\d*)(\\D*)(.*)/.exec(m)||[\"\",\"\",\"\",\"\"];if(0==h[0].length&&0==m[0].length)break;b=ma(0==h[1].length?0:parseInt(h[1],10),0==m[1].length?0:parseInt(m[1],10))||ma(0==h[2].length,0==m[2].length)||ma(h[2],m[2]);h=h[3];m=m[3]}while(0==b)}return 0<=b})}var Va;var Wa=k.document;\nVa=Wa&&z?Oa()||(\"CSS1Compat\"==Wa.compatMode?parseInt(Pa,10):5):void 0;var Xa=Object.freeze||function(a){return a};var Ya=!z||9<=Number(Va),Za=z&&!Ua(\"9\"),$a=function(){if(!k.addEventListener||!Object.defineProperty)return!1;var a=!1,b=Object.defineProperty({},\"passive\",{get:function(){a=!0}});k.addEventListener(\"test\",aa,b);k.removeEventListener(\"test\",aa,b);return a}();function A(a,b){this.type=a;this.a=this.target=b;this.Qa=!0}A.prototype.b=function(){this.Qa=!1};function ab(a,b){A.call(this,a?a.type:\"\");this.relatedTarget=this.a=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key=\"\";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.pointerId=0;this.pointerType=\"\";this.c=null;if(a){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.a=b;if(b=a.relatedTarget){if(Ma){a:{try{Ha(b.nodeName);var e=!0;break a}catch(f){}e=!1}e||(b=null)}}else\"mouseover\"==c?b=\na.fromElement:\"mouseout\"==c&&(b=a.toElement);this.relatedTarget=b;null===d?(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.key=a.key||\"\";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=\na.metaKey;this.pointerId=a.pointerId||0;this.pointerType=l(a.pointerType)?a.pointerType:bb[a.pointerType]||\"\";this.c=a;a.defaultPrevented&&this.b()}}u(ab,A);var bb=Xa({2:\"touch\",3:\"pen\",4:\"mouse\"});ab.prototype.b=function(){ab.L.b.call(this);var a=this.c;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,Za)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var cb=\"closure_listenable_\"+(1E6*Math.random()|0);function db(a){return!(!a||!a[cb])}var eb=0;function fb(a,b,c,d,e){this.listener=a;this.a=null;this.src=b;this.type=c;this.capture=!!d;this.da=e;this.key=++eb;this.X=this.ba=!1}function gb(a){a.X=!0;a.listener=null;a.a=null;a.src=null;a.da=null};function hb(a){this.src=a;this.a={};this.b=0}hb.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.a[f];a||(a=this.a[f]=[],this.b++);var h=ib(a,b,d,e);-1<h?(b=a[h],c||(b.ba=!1)):(b=new fb(b,this.src,f,!!d,e),b.ba=c,a.push(b));return b};function jb(a,b){var c=b.type;if(c in a.a){var d=a.a[c],e=sa(d,b),f;(f=0<=e)&&Array.prototype.splice.call(d,e,1);f&&(gb(b),0==a.a[c].length&&(delete a.a[c],a.b--))}}function kb(a,b,c,d,e){a=a.a[b.toString()];b=-1;a&&(b=ib(a,c,d,e));return-1<b?a[b]:null}\nfunction ib(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.X&&f.listener==b&&f.capture==!!c&&f.da==d)return e}return-1};var lb=\"closure_lm_\"+(1E6*Math.random()|0),mb={},nb=0;function ob(a,b,c,d,e){if(d&&d.once)return pb(a,b,c,d,e);if(n(b)){for(var f=0;f<b.length;f++)ob(a,b[f],c,d,e);return null}c=qb(c);return db(a)?a.$(b,c,p(d)?!!d.capture:!!d,e):rb(a,b,c,!1,d,e)}\nfunction rb(a,b,c,d,e,f){if(!b)throw Error(\"Invalid event type\");var h=p(e)?!!e.capture:!!e,m=sb(a);m||(a[lb]=m=new hb(a));c=m.add(b,c,d,h,f);if(c.a)return c;d=tb();c.a=d;d.src=a;d.listener=c;if(a.addEventListener)$a||(e=h),void 0===e&&(e=!1),a.addEventListener(b.toString(),d,e);else if(a.attachEvent)a.attachEvent(ub(b.toString()),d);else throw Error(\"addEventListener and attachEvent are unavailable.\");nb++;return c}\nfunction tb(){var a=vb,b=Ya?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}function pb(a,b,c,d,e){if(n(b)){for(var f=0;f<b.length;f++)pb(a,b[f],c,d,e);return null}c=qb(c);return db(a)?a.Ia(b,c,p(d)?!!d.capture:!!d,e):rb(a,b,c,!0,d,e)}function wb(a,b,c,d,e){if(n(b))for(var f=0;f<b.length;f++)wb(a,b[f],c,d,e);else d=p(d)?!!d.capture:!!d,c=qb(c),db(a)?a.xa(b,c,d,e):a&&(a=sb(a))&&(b=kb(a,b,c,d,e))&&xb(b)}\nfunction xb(a){if(\"number\"!=typeof a&&a&&!a.X){var b=a.src;if(db(b))jb(b.c,a);else{var c=a.type,d=a.a;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent&&b.detachEvent(ub(c),d);nb--;(c=sb(b))?(jb(c,a),0==c.b&&(c.src=null,b[lb]=null)):gb(a)}}}function ub(a){return a in mb?mb[a]:mb[a]=\"on\"+a}function yb(a,b,c,d){var e=!0;if(a=sb(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.capture==c&&!f.X&&(f=zb(f,d),e=e&&!1!==f)}return e}\nfunction zb(a,b){var c=a.listener,d=a.da||a.src;a.ba&&xb(a);return c.call(d,b)}\nfunction vb(a,b){if(a.X)return!0;if(!Ya){if(!b)a:{b=[\"window\",\"event\"];for(var c=k,d=0;d<b.length;d++)if(c=c[b[d]],null==c){b=null;break a}b=c}d=b;b=new ab(d,this);c=!0;if(!(0>d.keyCode||void 0!=d.returnValue)){a:{var e=!1;if(0==d.keyCode)try{d.keyCode=-1;break a}catch(h){e=!0}if(e||void 0==d.returnValue)d.returnValue=!0}d=[];for(e=b.a;e;e=e.parentNode)d.push(e);a=a.type;for(e=d.length-1;0<=e;e--){b.a=d[e];var f=yb(d[e],a,!0,b);c=c&&f}for(e=0;e<d.length;e++)b.a=d[e],f=yb(d[e],a,!1,b),c=c&&f}return c}return zb(a,\nnew ab(b,this))}function sb(a){a=a[lb];return a instanceof hb?a:null}var Ab=\"__closure_events_fn_\"+(1E9*Math.random()>>>0);function qb(a){if(da(a))return a;a[Ab]||(a[Ab]=function(b){return a.handleEvent(b)});return a[Ab]};function B(){w.call(this);this.c=new hb(this);this.P=this;this.J=null}u(B,w);B.prototype[cb]=!0;g=B.prototype;g.addEventListener=function(a,b,c,d){ob(this,a,b,c,d)};g.removeEventListener=function(a,b,c,d){wb(this,a,b,c,d)};\ng.dispatchEvent=function(a){var b,c=this.J;if(c)for(b=[];c;c=c.J)b.push(c);c=this.P;var d=a.type||a;if(l(a))a=new A(a,c);else if(a instanceof A)a.target=a.target||c;else{var e=a;a=new A(d,c);Ga(a,e)}e=!0;if(b)for(var f=b.length-1;0<=f;f--){var h=a.a=b[f];e=Bb(h,d,!0,a)&&e}h=a.a=c;e=Bb(h,d,!0,a)&&e;e=Bb(h,d,!1,a)&&e;if(b)for(f=0;f<b.length;f++)h=a.a=b[f],e=Bb(h,d,!1,a)&&e;return e};\ng.w=function(){B.L.w.call(this);if(this.c){var a=this.c,b=0,c;for(c in a.a){for(var d=a.a[c],e=0;e<d.length;e++)++b,gb(d[e]);delete a.a[c];a.b--}}this.J=null};g.$=function(a,b,c,d){return this.c.add(String(a),b,!1,c,d)};g.Ia=function(a,b,c,d){return this.c.add(String(a),b,!0,c,d)};g.xa=function(a,b,c,d){var e=this.c;a=String(a).toString();if(a in e.a){var f=e.a[a];b=ib(f,b,c,d);-1<b?(gb(f[b]),Array.prototype.splice.call(f,b,1),0==f.length&&(delete e.a[a],e.b--),e=!0):e=!1}else e=!1;return e};\nfunction Bb(a,b,c,d){b=a.c.a[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var h=b[f];if(h&&!h.X&&h.capture==c){var m=h.listener,v=h.da||h.src;h.ba&&jb(a.c,h);e=!1!==m.call(v,d)&&e}}return e&&0!=d.Qa};function Cb(a){return/^\\s*$/.test(a)?!1:/^[\\],:{}\\s\\u2028\\u2029]*$/.test(a.replace(/\\\\[\"\\\\\\/bfnrtu]/g,\"@\").replace(/(?:\"[^\"\\\\\\n\\r\\u2028\\u2029\\x00-\\x08\\x0a-\\x1f]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[\\s\\u2028\\u2029]*(?=:|,|]|}|$)/g,\"]\").replace(/(?:^|:|,)(?:[\\s\\u2028\\u2029]*\\[)+/g,\"\"))}function Db(a){a=String(a);if(Cb(a))try{return eval(\"(\"+a+\")\")}catch(b){}throw Error(\"Invalid JSON string: \"+a);}function Eb(a){var b=[];Fb(new Gb,a,b);return b.join(\"\")}function Gb(){}\nfunction Fb(a,b,c){if(null==b)c.push(\"null\");else{if(\"object\"==typeof b){if(n(b)){var d=b;b=d.length;c.push(\"[\");for(var e=\"\",f=0;f<b;f++)c.push(e),Fb(a,d[f],c),e=\",\";c.push(\"]\");return}if(b instanceof String||b instanceof Number||b instanceof Boolean)b=b.valueOf();else{c.push(\"{\");e=\"\";for(d in b)Object.prototype.hasOwnProperty.call(b,d)&&(f=b[d],\"function\"!=typeof f&&(c.push(e),Hb(d,c),c.push(\":\"),Fb(a,f,c),e=\",\"));c.push(\"}\");return}}switch(typeof b){case \"string\":Hb(b,c);break;case \"number\":c.push(isFinite(b)&&\n!isNaN(b)?String(b):\"null\");break;case \"boolean\":c.push(String(b));break;case \"function\":c.push(\"null\");break;default:throw Error(\"Unknown type: \"+typeof b);}}}var Ib={'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\",\"/\":\"\\\\/\",\"\\b\":\"\\\\b\",\"\\f\":\"\\\\f\",\"\\n\":\"\\\\n\",\"\\r\":\"\\\\r\",\"\\t\":\"\\\\t\",\"\\x0B\":\"\\\\u000b\"},Kb=/\\uffff/.test(\"\\uffff\")?/[\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g:/[\\\\\"\\x00-\\x1f\\x7f-\\xff]/g;\nfunction Hb(a,b){b.push('\"',a.replace(Kb,function(a){var b=Ib[a];b||(b=\"\\\\u\"+(a.charCodeAt(0)|65536).toString(16).substr(1),Ib[a]=b);return b}),'\"')};function Lb(a,b,c){this.f=c;this.c=a;this.g=b;this.b=0;this.a=null}Lb.prototype.get=function(){if(0<this.b){this.b--;var a=this.a;this.a=a.next;a.next=null}else a=this.c();return a};function Mb(){this.b=this.a=null}var C=new Lb(function(){return new Nb},function(a){a.reset()},100);Mb.prototype.add=function(a,b){var c=C.get();c.set(a,b);this.b?this.b.next=c:this.a=c;this.b=c};function Ob(){var a=Pb,b=null;a.a&&(b=a.a,a.a=a.a.next,a.a||(a.b=null),b.next=null);return b}function Nb(){this.next=this.b=this.a=null}Nb.prototype.set=function(a,b){this.a=a;this.b=b;this.next=null};Nb.prototype.reset=function(){this.next=this.b=this.a=null};function Qb(a){k.setTimeout(function(){throw a;},0)}var Rb;\nfunction Sb(){var a=k.MessageChannel;\"undefined\"===typeof a&&\"undefined\"!==typeof window&&window.postMessage&&window.addEventListener&&!y(\"Presto\")&&(a=function(){var a=document.createElement(\"IFRAME\");a.style.display=\"none\";a.src=\"\";document.documentElement.appendChild(a);var b=a.contentWindow;a=b.document;a.open();a.write(\"\");a.close();var c=\"callImmediate\"+Math.random(),d=\"file:\"==b.location.protocol?\"*\":b.location.protocol+\"//\"+b.location.host;a=r(function(a){if((\"*\"==d||a.origin==d)&&a.data==\nc)this.port1.onmessage()},this);b.addEventListener(\"message\",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if(\"undefined\"!==typeof a&&!y(\"Trident\")&&!y(\"MSIE\")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.Ca;c.Ca=null;a()}};return function(a){d.next={Ca:a};d=d.next;b.port2.postMessage(0)}}return\"undefined\"!==typeof document&&\"onreadystatechange\"in document.createElement(\"SCRIPT\")?function(a){var b=document.createElement(\"SCRIPT\");\nb.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){k.setTimeout(a,0)}};var Tb;function Ub(){if(-1!=String(k.Promise).indexOf(\"[native code]\")){var a=k.Promise.resolve(void 0);Tb=function(){a.then(Vb)}}else Tb=function(){var a=Vb;!da(k.setImmediate)||k.Window&&k.Window.prototype&&!y(\"Edge\")&&k.Window.prototype.setImmediate==k.setImmediate?(Rb||(Rb=Sb()),Rb(a)):k.setImmediate(a)}}var Wb=!1,Pb=new Mb;function Vb(){for(var a;a=Ob();){try{a.a.call(a.b)}catch(b){Qb(b)}C.g(a);C.b<C.f&&(C.b++,a.next=C.a,C.a=a)}Wb=!1};function Xb(a,b){B.call(this);this.b=a||1;this.a=b||k;this.f=r(this.jb,this);this.g=t()}u(Xb,B);g=Xb.prototype;g.Z=!1;g.K=null;g.jb=function(){if(this.Z){var a=t()-this.g;0<a&&a<.8*this.b?this.K=this.a.setTimeout(this.f,this.b-a):(this.K&&(this.a.clearTimeout(this.K),this.K=null),this.dispatchEvent(\"tick\"),this.Z&&(this.K=this.a.setTimeout(this.f,this.b),this.g=t()))}};g.start=function(){this.Z=!0;this.K||(this.K=this.a.setTimeout(this.f,this.b),this.g=t())};\nfunction Yb(a){a.Z=!1;a.K&&(a.a.clearTimeout(a.K),a.K=null)}g.w=function(){Xb.L.w.call(this);Yb(this);delete this.a};function Zb(a,b,c){if(da(a))c&&(a=r(a,c));else if(a&&\"function\"==typeof a.handleEvent)a=r(a.handleEvent,a);else throw Error(\"Invalid listener argument\");return 2147483647<Number(b)?-1:k.setTimeout(a,b||0)};function $b(a,b,c){w.call(this);this.f=null!=c?r(a,c):a;this.c=b;this.b=r(this.cb,this);this.a=[]}u($b,w);g=$b.prototype;g.ea=!1;g.W=null;g.Ya=function(a){this.a=arguments;this.W?this.ea=!0:ac(this)};g.w=function(){$b.L.w.call(this);this.W&&(k.clearTimeout(this.W),this.W=null,this.ea=!1,this.a=[])};g.cb=function(){this.W=null;this.ea&&(this.ea=!1,ac(this))};function ac(a){a.W=Zb(a.b,a.c);a.f.apply(null,a.a)};function D(a){w.call(this);this.b=a;this.a={}}u(D,w);var bc=[];D.prototype.$=function(a,b,c,d){n(b)||(b&&(bc[0]=b.toString()),b=bc);for(var e=0;e<b.length;e++){var f=ob(a,b[e],c||this.handleEvent,d||!1,this.b||this);if(!f)break;this.a[f.key]=f}return this};\nD.prototype.xa=function(a,b,c,d,e){if(n(b))for(var f=0;f<b.length;f++)this.xa(a,b[f],c,d,e);else c=c||this.handleEvent,d=p(d)?!!d.capture:!!d,e=e||this.b||this,c=qb(c),d=!!d,b=db(a)?kb(a.c,String(b),c,d,e):a?(a=sb(a))?kb(a,b,c,d,e):null:null,b&&(xb(b),delete this.a[b.key]);return this};function cc(a){Ba(a.a,function(a,c){this.a.hasOwnProperty(c)&&xb(a)},a);a.a={}}D.prototype.w=function(){D.L.w.call(this);cc(this)};\nD.prototype.handleEvent=function(){throw Error(\"EventHandler.handleEvent not implemented\");};function dc(a,b,c,d,e){this.reset(a,b,c,d,e)}dc.prototype.a=null;var ec=0;dc.prototype.reset=function(a,b,c,d,e){\"number\"==typeof e||ec++;d||t();this.b=b;delete this.a};function fc(a){this.f=a;this.b=this.c=this.a=null}function E(a,b){this.name=a;this.value=b}E.prototype.toString=function(){return this.name};var gc=new E(\"SEVERE\",1E3),hc=new E(\"WARNING\",900),ic=new E(\"INFO\",800),jc=new E(\"CONFIG\",700),kc=new E(\"FINE\",500);function lc(a){if(a.c)return a.c;if(a.a)return lc(a.a);oa(\"Root logger has no level set.\");return null}\nfc.prototype.log=function(a,b,c){if(a.value>=lc(this).value)for(da(b)&&(b=b()),a=new dc(a,String(b),this.f),c&&(a.a=c),c=\"log:\"+a.b,(a=k.console)&&a.timeStamp&&a.timeStamp(c),(a=k.msWriteProfilerMark)&&a(c),c=this;c;)c=c.a};function F(a,b){a.log(gc,b,void 0)}function G(a,b){a.log(hc,b,void 0)}var mc={},nc=null;\nfunction oc(a){nc||(nc=new fc(\"\"),mc[\"\"]=nc,nc.c=jc);var b;if(!(b=mc[a])){b=new fc(a);var c=a.lastIndexOf(\".\"),d=a.substr(c+1);c=oc(a.substr(0,c));c.b||(c.b={});c.b[d]=b;b.a=c;mc[a]=b}return b};function pc(a,b){a&&a.log(ic,b,void 0)}function H(a,b){a&&a.log(kc,b,void 0)};function qc(){this.a=oc(\"goog.labs.net.webChannel.WebChannelDebug\")}function rc(a,b,c,d){if(c)try{var e=JSON.parse(c);if(e)for(var f=0;f<e.length;f++)if(n(e[f])){var h=e[f];if(!(2>h.length)){var m=h[1];if(n(m)&&!(1>m.length)){var v=m[0];if(\"noop\"!=v&&\"stop\"!=v&&\"close\"!=v)for(var Sa=1;Sa<m.length;Sa++)m[Sa]=\"\"}}}var Jb=Eb(e)}catch(Pe){I(a,\"Exception parsing expected JS array - probably was not JS\"),Jb=c}else Jb=null;I(a,\"XMLHTTP TEXT (\"+b+\"): \"+Jb+(d?\" \"+d:\"\"))}\nfunction sc(a,b,c){(a=a.a)&&F(a,(c||\"Exception\")+b)}function I(a,b){pc(a.a,b)};var J=new B;function tc(a){A.call(this,\"serverreachability\",a)}u(tc,A);function uc(){J.dispatchEvent(new tc(J))}function vc(a){A.call(this,\"statevent\",a)}u(vc,A);function K(){J.dispatchEvent(new vc(J))}function wc(a){A.call(this,\"timingevent\",a)}u(wc,A);function xc(a,b){if(!da(a))throw Error(\"Fn must not be null and must be a function\");return k.setTimeout(function(){a()},b)};var yc={NO_ERROR:0,kb:1,rb:2,qb:3,nb:4,pb:5,sb:6,Sa:7,TIMEOUT:8,vb:9};var zc={mb:\"complete\",zb:\"success\",Ta:\"error\",Sa:\"abort\",xb:\"ready\",yb:\"readystatechange\",TIMEOUT:\"timeout\",tb:\"incrementaldata\",wb:\"progress\",ob:\"downloadprogress\",Ab:\"uploadprogress\"};function Ac(){}Ac.prototype.a=null;function Bc(a){var b;(b=a.a)||(b={},Cc(a)&&(b[0]=!0,b[1]=!0),b=a.a=b);return b};var Dc;function Ec(){}u(Ec,Ac);function Fc(a){return(a=Cc(a))?new ActiveXObject(a):new XMLHttpRequest}function Cc(a){if(!a.b&&\"undefined\"==typeof XMLHttpRequest&&\"undefined\"!=typeof ActiveXObject){for(var b=[\"MSXML2.XMLHTTP.6.0\",\"MSXML2.XMLHTTP.3.0\",\"MSXML2.XMLHTTP\",\"Microsoft.XMLHTTP\"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.b=d}catch(e){}}throw Error(\"Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed\");}return a.b}Dc=new Ec;function L(a,b,c,d,e){this.m=a;this.b=b;this.f=d;this.S=e||1;this.M=new D(this);this.P=Gc;a=this.F=new Xb;a.b=Hc;a.K&&a.Z?(Yb(a),a.start()):a.K&&Yb(a);this.h=null;this.c=!1;this.a=this.B=this.g=this.l=this.I=this.H=this.T=this.o=null;this.C=0;this.i=this.j=null;this.v=-1;this.s=!1;this.N=0;this.G=null;this.J=!1}var Gc=45E3,Hc=250;\nfunction Ic(a,b){switch(a){case 0:return\"Non-200 return code (\"+b+\")\";case 1:return\"XMLHTTP failure (no data)\";case 2:return\"HttpConnection timeout\";default:return\"Unknown error\"}}var Jc={},Kc={};g=L.prototype;g.setTimeout=function(a){this.P=a};function Lc(a,b,c){a.I=1;a.l=Mc(M(b));a.B=c;a.J=!0;Nc(a,null)}function Oc(a,b,c,d){a.I=1;a.l=Mc(M(b));a.B=null;a.J=c;Nc(a,d)}\nfunction Nc(a,b){a.H=t();Pc(a);a.g=M(a.l);Qc(a.g,\"t\",a.S);a.C=0;a.a=a.m.ra(a.m.fa()?b:null);0<a.N&&(a.G=new $b(r(a.Ra,a,a.a),a.N));a.M.$(a.a,\"readystatechange\",a.gb);b=a.h?Ea(a.h):{};a.B?(a.j||(a.j=\"POST\"),b[\"Content-Type\"]=\"application/x-www-form-urlencoded\",a.a.ta(a.g,a.j,a.B,b)):(a.j=\"GET\",a.a.ta(a.g,a.j,null,b));uc();var c=a.B;if(c){b=\"\";c=c.split(\"&\");for(var d=0;d<c.length;d++){var e=c[d].split(\"=\");if(1<e.length){var f=e[0];e=e[1];var h=f.split(\"_\");b=2<=h.length&&\"type\"==h[1]?b+(f+\"=\"+e+\"&\"):\nb+(f+\"=redacted&\")}}}else b=null;I(a.b,\"XMLHTTP REQ (\"+a.f+\") [attempt \"+a.S+\"]: \"+a.j+\"\\n\"+a.g+\"\\n\"+b)}g.gb=function(a){a=a.target;var b=this.G;b&&3==N(a)?(I(this.b,\"Throttling readystatechange.\"),b.Ya()):this.Ra(a)};\ng.Ra=function(a){try{if(a==this.a){var b=N(this.a),c=this.a.Ga();if(!(3>b||3==b&&!Ka&&!this.a.U())){this.s||4!=b||7==c||uc();Rc(this);var d=this.a.V();this.v=d;var e=this.a.U();e||I(this.b,\"No response text for uri \"+this.g+\" status \"+d);this.c=200==d;I(this.b,\"XMLHTTP RESP (\"+this.f+\") [ attempt \"+this.S+\"]: \"+this.j+\"\\n\"+this.g+\"\\n\"+b+\" \"+d);if(this.c)this.J?(Sc(this,b,e),Ka&&this.c&&3==b&&(this.M.$(this.F,\"tick\",this.fb),this.F.start())):(rc(this.b,this.f,e,null),Tc(this,e)),4==b&&Uc(this),this.c&&\n!this.s&&(4==b?this.m.wa(this):(this.c=!1,Pc(this)));else{if(400==d&&0<e.indexOf(\"Unknown SID\")){this.i=3;K();var f=this.b.a;f&&G(f,\"XMLHTTP Unknown SID (\"+this.f+\")\")}else{this.i=0;K();var h=this.b.a;h&&G(h,\"XMLHTTP Bad status \"+d+\" (\"+this.f+\")\")}Uc(this);Vc(this)}}}else{var m=this.b.a;m&&G(m,\"Called back with an unexpected xmlhttp\")}}catch(v){I(this.b,\"Failed call to OnXmlHttpReadyStateChanged_\"),this.a&&this.a.U()?sc(this.b,v,\"ResponseText: \"+this.a.U()):sc(this.b,v,\"No response text\")}finally{}};\nfunction Sc(a,b,c){for(var d=!0;!a.s&&a.C<c.length;){var e=Wc(a,c);if(e==Kc){4==b&&(a.i=4,K(),d=!1);rc(a.b,a.f,null,\"[Incomplete Response]\");break}else if(e==Jc){a.i=4;K();rc(a.b,a.f,c,\"[Invalid Chunk]\");d=!1;break}else rc(a.b,a.f,e,null),Tc(a,e)}4==b&&0==c.length&&(a.i=1,K(),d=!1);a.c=a.c&&d;d||(rc(a.b,a.f,c,\"[Invalid Chunked Response]\"),Uc(a),Vc(a))}g.fb=function(){var a=N(this.a),b=this.a.U();this.C<b.length&&(Rc(this),Sc(this,a,b),this.c&&4!=a&&Pc(this))};\nfunction Wc(a,b){var c=a.C,d=b.indexOf(\"\\n\",c);if(-1==d)return Kc;c=Number(b.substring(c,d));if(isNaN(c))return Jc;d+=1;if(d+c>b.length)return Kc;b=b.substr(d,c);a.C=d+c;return b}g.cancel=function(){this.s=!0;Uc(this)};function Pc(a){a.T=t()+a.P;Xc(a,a.P)}function Xc(a,b){if(null!=a.o)throw Error(\"WatchDog timer not null\");a.o=xc(r(a.eb,a),b)}function Rc(a){a.o&&(k.clearTimeout(a.o),a.o=null)}\ng.eb=function(){this.o=null;var a=t();if(0<=a-this.T)this.c&&(a=this.b.a)&&F(a,\"Received watchdog timeout even though request loaded successfully\"),I(this.b,\"TIMEOUT: \"+this.g),2!=this.I&&(uc(),K()),Uc(this),this.i=2,Vc(this);else{var b=this.b.a;b&&G(b,\"WatchDog timer called too early\");Xc(this,this.T-a)}};function Vc(a){a.m.Ka()||a.s||a.m.wa(a)}function Uc(a){Rc(a);var b=a.G;b&&\"function\"==typeof b.Y&&b.Y();a.G=null;Yb(a.F);cc(a.M);a.a&&(b=a.a,a.a=null,b.abort(),b.Y())}\nfunction Tc(a,b){try{a.m.Na(a,b),uc()}catch(c){sc(a.b,c,\"Error in httprequest callback\")}};function Yc(a){if(a.A&&\"function\"==typeof a.A)return a.A();if(l(a))return a.split(\"\");if(ca(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return Ca(a)}\nfunction Zc(a,b){if(a.forEach&&\"function\"==typeof a.forEach)a.forEach(b,void 0);else if(ca(a)||l(a))ta(a,b,void 0);else{if(a.O&&\"function\"==typeof a.O)var c=a.O();else if(a.A&&\"function\"==typeof a.A)c=void 0;else if(ca(a)||l(a)){c=[];for(var d=a.length,e=0;e<d;e++)c.push(e)}else c=Da(a);d=Yc(a);e=d.length;for(var f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],a)}};function O(a,b){this.b={};this.a=[];this.c=0;var c=arguments.length;if(1<c){if(c%2)throw Error(\"Uneven number of arguments\");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else if(a){a instanceof O?(c=a.O(),d=a.A()):(c=Da(a),d=Ca(a));for(var e=0;e<c.length;e++)this.set(c[e],d[e])}}g=O.prototype;g.u=function(){return this.c};g.A=function(){$c(this);for(var a=[],b=0;b<this.a.length;b++)a.push(this.b[this.a[b]]);return a};g.O=function(){$c(this);return this.a.concat()};\nfunction ad(a){a.b={};a.a.length=0;a.c=0}function bd(a,b){return P(a.b,b)?(delete a.b[b],a.c--,a.a.length>2*a.c&&$c(a),!0):!1}function $c(a){if(a.c!=a.a.length){for(var b=0,c=0;b<a.a.length;){var d=a.a[b];P(a.b,d)&&(a.a[c++]=d);b++}a.a.length=c}if(a.c!=a.a.length){var e={};for(c=b=0;b<a.a.length;)d=a.a[b],P(e,d)||(a.a[c++]=d,e[d]=1),b++;a.a.length=c}}g.get=function(a,b){return P(this.b,a)?this.b[a]:b};g.set=function(a,b){P(this.b,a)||(this.c++,this.a.push(a));this.b[a]=b};\ng.forEach=function(a,b){for(var c=this.O(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};function P(a,b){return Object.prototype.hasOwnProperty.call(a,b)};var cd=/^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$/;function dd(a,b){if(a){a=a.split(\"&\");for(var c=0;c<a.length;c++){var d=a[c].indexOf(\"=\"),e=null;if(0<=d){var f=a[c].substring(0,d);e=a[c].substring(d+1)}else f=a[c];b(f,e?decodeURIComponent(e.replace(/\\+/g,\" \")):\"\")}}};function Q(a,b){this.b=this.j=this.f=\"\";this.i=null;this.g=this.a=\"\";this.h=!1;var c;a instanceof Q?(this.h=void 0!==b?b:a.h,ed(this,a.f),this.j=a.j,fd(this,a.b),gd(this,a.i),this.a=a.a,hd(this,id(a.c)),this.g=a.g):a&&(c=String(a).match(cd))?(this.h=!!b,ed(this,c[1]||\"\",!0),this.j=jd(c[2]||\"\"),fd(this,c[3]||\"\",!0),gd(this,c[4]),this.a=jd(c[5]||\"\",!0),hd(this,c[6]||\"\",!0),this.g=jd(c[7]||\"\")):(this.h=!!b,this.c=new kd(null,0,this.h))}\nQ.prototype.toString=function(){var a=[],b=this.f;b&&a.push(ld(b,md,!0),\":\");var c=this.b;if(c||\"file\"==b)a.push(\"//\"),(b=this.j)&&a.push(ld(b,md,!0),\"@\"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),c=this.i,null!=c&&a.push(\":\",String(c));if(c=this.a)this.b&&\"/\"!=c.charAt(0)&&a.push(\"/\"),a.push(ld(c,\"/\"==c.charAt(0)?nd:od,!0));(c=this.c.toString())&&a.push(\"?\",c);(c=this.g)&&a.push(\"#\",ld(c,pd));return a.join(\"\")};\nQ.prototype.resolve=function(a){var b=M(this),c=!!a.f;c?ed(b,a.f):c=!!a.j;c?b.j=a.j:c=!!a.b;c?fd(b,a.b):c=null!=a.i;var d=a.a;if(c)gd(b,a.i);else if(c=!!a.a){if(\"/\"!=d.charAt(0))if(this.b&&!this.a)d=\"/\"+d;else{var e=b.a.lastIndexOf(\"/\");-1!=e&&(d=b.a.substr(0,e+1)+d)}e=d;if(\"..\"==e||\".\"==e)d=\"\";else if(-1!=e.indexOf(\"./\")||-1!=e.indexOf(\"/.\")){d=0==e.lastIndexOf(\"/\",0);e=e.split(\"/\");for(var f=[],h=0;h<e.length;){var m=e[h++];\".\"==m?d&&h==e.length&&f.push(\"\"):\"..\"==m?((1<f.length||1==f.length&&\"\"!=\nf[0])&&f.pop(),d&&h==e.length&&f.push(\"\")):(f.push(m),d=!0)}d=f.join(\"/\")}else d=e}c?b.a=d:c=\"\"!==a.c.toString();c?hd(b,id(a.c)):c=!!a.g;c&&(b.g=a.g);return b};function M(a){return new Q(a)}function ed(a,b,c){a.f=c?jd(b,!0):b;a.f&&(a.f=a.f.replace(/:$/,\"\"))}function fd(a,b,c){a.b=c?jd(b,!0):b}function gd(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error(\"Bad port number \"+b);a.i=b}else a.i=null}function hd(a,b,c){b instanceof kd?(a.c=b,qd(a.c,a.h)):(c||(b=ld(b,rd)),a.c=new kd(b,0,a.h))}\nfunction R(a,b,c){a.c.set(b,c)}function Qc(a,b,c){n(c)||(c=[String(c)]);sd(a.c,b,c)}function Mc(a){R(a,\"zx\",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^t()).toString(36));return a}function td(a){return a instanceof Q?M(a):new Q(a,void 0)}function ud(a,b,c,d){var e=new Q(null,void 0);a&&ed(e,a);b&&fd(e,b);c&&gd(e,c);d&&(e.a=d);return e}function jd(a,b){return a?b?decodeURI(a.replace(/%25/g,\"%2525\")):decodeURIComponent(a):\"\"}\nfunction ld(a,b,c){return l(a)?(a=encodeURI(a).replace(b,vd),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),a):null}function vd(a){a=a.charCodeAt(0);return\"%\"+(a>>4&15).toString(16)+(a&15).toString(16)}var md=/[#\\/\\?@]/g,od=/[#\\?:]/g,nd=/[#\\?]/g,rd=/[#\\?@]/g,pd=/#/g;function kd(a,b,c){this.b=this.a=null;this.c=a||null;this.f=!!c}function S(a){a.a||(a.a=new O,a.b=0,a.c&&dd(a.c,function(b,c){a.add(decodeURIComponent(b.replace(/\\+/g,\" \")),c)}))}g=kd.prototype;g.u=function(){S(this);return this.b};\ng.add=function(a,b){S(this);this.c=null;a=wd(this,a);var c=this.a.get(a);c||this.a.set(a,c=[]);c.push(b);this.b+=1;return this};function xd(a,b){S(a);b=wd(a,b);P(a.a.b,b)&&(a.c=null,a.b-=a.a.get(b).length,bd(a.a,b))}function yd(a,b){S(a);b=wd(a,b);return P(a.a.b,b)}g.forEach=function(a,b){S(this);this.a.forEach(function(c,d){ta(c,function(c){a.call(b,c,d,this)},this)},this)};\ng.O=function(){S(this);for(var a=this.a.A(),b=this.a.O(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};g.A=function(a){S(this);var b=[];if(l(a))yd(this,a)&&(b=xa(b,this.a.get(wd(this,a))));else{a=this.a.A();for(var c=0;c<a.length;c++)b=xa(b,a[c])}return b};g.set=function(a,b){S(this);this.c=null;a=wd(this,a);yd(this,a)&&(this.b-=this.a.get(a).length);this.a.set(a,[b]);this.b+=1;return this};g.get=function(a,b){a=a?this.A(a):[];return 0<a.length?String(a[0]):b};\nfunction sd(a,b,c){xd(a,b);0<c.length&&(a.c=null,a.a.set(wd(a,b),ya(c)),a.b+=c.length)}g.toString=function(){if(this.c)return this.c;if(!this.a)return\"\";for(var a=[],b=this.a.O(),c=0;c<b.length;c++){var d=b[c],e=encodeURIComponent(String(d));d=this.A(d);for(var f=0;f<d.length;f++){var h=e;\"\"!==d[f]&&(h+=\"=\"+encodeURIComponent(String(d[f])));a.push(h)}}return this.c=a.join(\"&\")};function id(a){var b=new kd;b.c=a.c;a.a&&(b.a=new O(a.a),b.b=a.b);return b}\nfunction wd(a,b){b=String(b);a.f&&(b=b.toLowerCase());return b}function qd(a,b){b&&!a.f&&(S(a),a.c=null,a.a.forEach(function(a,b){var c=b.toLowerCase();b!=c&&(xd(this,b),sd(this,c,a))},a));a.f=b};function zd(){this.a=t()}var Ad=null;zd.prototype.set=function(a){this.a=a};zd.prototype.reset=function(){this.set(t())};zd.prototype.get=function(){return this.a};function Bd(){Ad||(Ad=new zd)}function Cd(){Ad||(Ad=new zd)}u(Cd,Bd);function Dd(){}var Ed={OPEN:\"a\",lb:\"b\",Ta:\"c\",ub:\"d\"};function Fd(){A.call(this,\"d\")}u(Fd,A);function Gd(){A.call(this,\"c\")}u(Gd,A);function Hd(a,b){this.a=a;this.b=b;this.c=this.i=null;this.h=!1;this.l=null;this.f=-1;this.m=this.g=null}g=Hd.prototype;g.R=null;function Id(a){I(a.b,\"TestConnection: starting stage 2\");var b=a.a.J.a;if(null!=b)I(a.b, true?\"Buffered\":\"Unbuffered\"),K(),b?(K(),Jd(a.a,a,!1)):(K(),Jd(a.a,a,!0));else{a.c=new L(a,a.b,0,void 0,void 0);a.c.h=a.i;b=Kd(a.a,a.g,a.l);K();Qc(b,\"TYPE\",\"xmlhttp\");var c=a.a.j,d=a.a.N;c&&d&&R(b,c,d);Oc(a.c,b,!1,a.g)}}g.ra=function(a){return this.a.ra(a)};\ng.abort=function(){this.c&&(this.c.cancel(),this.c=null);this.f=-1};g.Ka=function(){return!1};\ng.Na=function(a,b){this.f=a.v;if(0==this.R){I(this.b,\"TestConnection: Got data for stage 1\");if(!this.a.F&&(a=a.a)){var c=a.a?a.a.getResponseHeader(\"X-Client-Wire-Protocol\"):null;this.m=c?c:null;this.a.j&&((a=a.a?a.a.getResponseHeader(\"X-HTTP-Session-Id\"):null)?this.a.N=a:(a=this.b.a)&&G(a,\"Missing X_HTTP_SESSION_ID in the handshake response\"))}if(b){try{var d=this.a.la.a.parse(b)}catch(e){sc(this.b,e);Ld(this.a,this);return}this.g=d[0]}else I(this.b,\"TestConnection: Null responseText\"),Ld(this.a,\nthis)}else if(1==this.R)if(this.h)K();else if(\"11111\"==b){if(K(),this.h=!0,!z||10<=Number(Va))this.f=200,this.c.cancel(),I(this.b,\"Test connection succeeded; using streaming connection\"),K(),Jd(this.a,this,!0)}else K(),this.h=!1};\ng.wa=function(){this.f=this.c.v;this.c.c?0==this.R?(this.R=1,I(this.b,\"TestConnection: request complete for initial check\"),Id(this)):1==this.R&&(I(this.b,\"TestConnection: request complete for stage 2\"),this.h?(I(this.b,\"Test connection succeeded; using streaming connection\"),K(),Jd(this.a,this,!0)):(I(this.b,\"Test connection failed; not using streaming\"),K(),Jd(this.a,this,!1))):(I(this.b,\"TestConnection: request failed, in state \"+this.R),0==this.R?K():1==this.R&&K(),Ld(this.a,this))};g.fa=function(){return this.a.fa()};\ng.sa=function(){return this.a.sa()};function Md(){this.a=this.b=null};function T(a){this.a=new O;if(a){a=Yc(a);for(var b=a.length,c=0;c<b;c++)this.add(a[c])}}function Nd(a){var b=typeof a;return\"object\"==b&&a||\"function\"==b?\"o\"+(a[q]||(a[q]=++ea)):b.charAt(0)+a}T.prototype.u=function(){return this.a.u()};T.prototype.add=function(a){this.a.set(Nd(a),a)};T.prototype.contains=function(a){a=Nd(a);return P(this.a.b,a)};T.prototype.A=function(){return this.a.A()};function Od(a){this.f=a||Pd;this.c=k.pa&&k.pa.La&&k.pa.La()&&k.pa.La().Cb?this.f:1;this.a=null;1<this.c&&(this.a=new T);this.b=null}var Pd=10;function Qd(a,b){a.a||-1==b.indexOf(\"spdy\")&&-1==b.indexOf(\"quic\")&&-1==b.indexOf(\"h2\")||(a.c=a.f,a.a=new T,a.b&&(Rd(a,a.b),a.b=null))}function Sd(a){return a.b?!0:a.a?a.a.u()>=a.c:!1}function Td(a,b){return a.b?a.b==b:a.a?a.a.contains(b):!1}function Rd(a,b){a.a?a.a.add(b):a.b=b}\nOd.prototype.cancel=function(){this.b?(this.b.cancel(),this.b=null):this.a&&0!=this.a.a.c&&(ta(this.a.A(),function(a){a.cancel()}),ad(this.a.a))};function Ud(a,b){this.a=a;this.b=b};function Vd(a,b){this.a=a;this.b=b}Vd.prototype.stringify=function(a){return k.JSON.stringify(a,this.a)};Vd.prototype.parse=function(a){return k.JSON.parse(a,this.b)};function Wd(){this.a=new Vd}function Xd(a,b,c){var d=c||\"\";try{Zc(a,function(a,c){var e=a;p(a)&&(e=Eb(a));b.push(d+c+\"=\"+encodeURIComponent(e))})}catch(e){throw b.push(d+\"type=\"+encodeURIComponent(\"_badmap\")),e;}};function Yd(a,b){var c=new qc;I(c,\"TestLoadImage: loading \"+a);var d=new Image;d.onload=ia(Zd,c,d,\"TestLoadImage: loaded\",!0,b);d.onerror=ia(Zd,c,d,\"TestLoadImage: error\",!1,b);d.onabort=ia(Zd,c,d,\"TestLoadImage: abort\",!1,b);d.ontimeout=ia(Zd,c,d,\"TestLoadImage: timeout\",!1,b);k.setTimeout(function(){if(d.ontimeout)d.ontimeout()},1E4);d.src=a}function Zd(a,b,c,d,e){try{I(a,c),b.onload=null,b.onerror=null,b.onabort=null,b.ontimeout=null,e(d)}catch(f){sc(a,f)}};function U(a){B.call(this);this.headers=new O;this.G=a||null;this.f=!1;this.F=this.a=null;this.M=this.s=\"\";this.j=0;this.g=\"\";this.h=this.I=this.o=this.H=!1;this.l=0;this.B=null;this.N=$d;this.C=this.m=!1}u(U,B);var $d=\"\";U.prototype.b=oc(\"goog.net.XhrIo\");var ae=/^https?$/i,be=[\"POST\",\"PUT\"];g=U.prototype;\ng.ta=function(a,b,c,d){if(this.a)throw Error(\"[goog.net.XhrIo] Object is active with another request=\"+this.s+\"; newUri=\"+a);b=b?b.toUpperCase():\"GET\";this.s=a;this.g=\"\";this.j=0;this.M=b;this.H=!1;this.f=!0;this.a=this.G?Fc(this.G):Fc(Dc);this.F=this.G?Bc(this.G):Bc(Dc);this.a.onreadystatechange=r(this.Ma,this);try{H(this.b,V(this,\"Opening Xhr\")),this.I=!0,this.a.open(b,String(a),!0),this.I=!1}catch(f){H(this.b,V(this,\"Error opening Xhr: \"+f.message));ce(this,f);return}a=c||\"\";var e=new O(this.headers);\nd&&Zc(d,function(a,b){e.set(b,a)});d=ua(e.O());c=k.FormData&&a instanceof k.FormData;!(0<=sa(be,b))||d||c||e.set(\"Content-Type\",\"application/x-www-form-urlencoded;charset=utf-8\");e.forEach(function(a,b){this.a.setRequestHeader(b,a)},this);this.N&&(this.a.responseType=this.N);\"withCredentials\"in this.a&&this.a.withCredentials!==this.m&&(this.a.withCredentials=this.m);try{de(this),0<this.l&&(this.C=ee(this.a),H(this.b,V(this,\"Will abort after \"+this.l+\"ms if incomplete, xhr2 \"+this.C)),this.C?(this.a.timeout=\nthis.l,this.a.ontimeout=r(this.Ja,this)):this.B=Zb(this.Ja,this.l,this)),H(this.b,V(this,\"Sending request\")),this.o=!0,this.a.send(a),this.o=!1}catch(f){H(this.b,V(this,\"Send error: \"+f.message)),ce(this,f)}};function ee(a){return z&&Ua(9)&&\"number\"==typeof a.timeout&&void 0!==a.ontimeout}function va(a){return\"content-type\"==a.toLowerCase()}\ng.Ja=function(){\"undefined\"!=typeof goog&&this.a&&(this.g=\"Timed out after \"+this.l+\"ms, aborting\",this.j=8,H(this.b,V(this,this.g)),this.dispatchEvent(\"timeout\"),this.abort(8))};function ce(a,b){a.f=!1;a.a&&(a.h=!0,a.a.abort(),a.h=!1);a.g=b;a.j=5;fe(a);ge(a)}function fe(a){a.H||(a.H=!0,a.dispatchEvent(\"complete\"),a.dispatchEvent(\"error\"))}\ng.abort=function(a){this.a&&this.f&&(H(this.b,V(this,\"Aborting\")),this.f=!1,this.h=!0,this.a.abort(),this.h=!1,this.j=a||7,this.dispatchEvent(\"complete\"),this.dispatchEvent(\"abort\"),ge(this))};g.w=function(){this.a&&(this.f&&(this.f=!1,this.h=!0,this.a.abort(),this.h=!1),ge(this,!0));U.L.w.call(this)};g.Ma=function(){this.i||(this.I||this.o||this.h?he(this):this.bb())};g.bb=function(){he(this)};\nfunction he(a){if(a.f&&\"undefined\"!=typeof goog)if(a.F[1]&&4==N(a)&&2==a.V())H(a.b,V(a,\"Local request error detected and ignored\"));else if(a.o&&4==N(a))Zb(a.Ma,0,a);else if(a.dispatchEvent(\"readystatechange\"),4==N(a)){H(a.b,V(a,\"Request complete\"));a.f=!1;try{var b=a.V();a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.s).match(cd)[1]||null;if(!f&&k.self&&k.self.location){var h=k.self.location.protocol;\nf=h.substr(0,h.length-1)}e=!ae.test(f?f.toLowerCase():\"\")}d=e}d?(a.dispatchEvent(\"complete\"),a.dispatchEvent(\"success\")):(a.j=6,a.g=a.Ha()+\" [\"+a.V()+\"]\",fe(a))}finally{ge(a)}}}function ge(a,b){if(a.a){de(a);var c=a.a,d=a.F[0]?aa:null;a.a=null;a.F=null;b||a.dispatchEvent(\"ready\");try{c.onreadystatechange=d}catch(e){(a=a.b)&&F(a,\"Problem encountered resetting onreadystatechange: \"+e.message)}}}function de(a){a.a&&a.C&&(a.a.ontimeout=null);\"number\"==typeof a.B&&(k.clearTimeout(a.B),a.B=null)}\nfunction N(a){return a.a?a.a.readyState:0}g.V=function(){try{return 2<N(this)?this.a.status:-1}catch(a){return-1}};g.Ha=function(){try{return 2<N(this)?this.a.statusText:\"\"}catch(a){return H(this.b,\"Can not get status: \"+a.message),\"\"}};g.U=function(){try{return this.a?this.a.responseText:\"\"}catch(a){return H(this.b,\"Can not get responseText: \"+a.message),\"\"}};\ng.Za=function(a){if(this.a){var b=this.a.responseText;a&&0==b.indexOf(a)&&(b=b.substring(a.length));a:{a=b;if(k.JSON)try{var c=k.JSON.parse(a);break a}catch(d){}c=Db(a)}return c}};g.Ga=function(){return this.j};g.$a=function(){return l(this.g)?this.g:String(this.g)};function V(a,b){return b+\" [\"+a.M+\" \"+a.s+\" \"+a.V()+\"]\"};function ie(a){var b=\"\";Ba(a,function(a,d){b+=d;b+=\":\";b+=a;b+=\"\\r\\n\"});return b}function je(a,b,c){a:{for(d in c){var d=!1;break a}d=!0}if(d)return a;c=ie(c);if(l(a)){b=encodeURIComponent(String(b));c=null!=c?\"=\"+encodeURIComponent(String(c)):\"\";if(b+=c){c=a.indexOf(\"#\");0>c&&(c=a.length);d=a.indexOf(\"?\");if(0>d||d>c){d=c;var e=\"\"}else e=a.substring(d+1,c);a=[a.substr(0,d),e,a.substr(c)];c=a[1];a[1]=b?c?c+\"&\"+b:b:c;a=a[0]+(a[1]?\"?\"+a[1]:\"\")+a[2]}return a}R(a,b,c);return a};function ke(a,b,c){this.za=b||0;this.Ba=0;this.h=[];this.l=[];this.a=new qc;this.J=c||new Md;this.ia=this.ya=this.H=this.ja=this.b=this.N=this.j=this.ha=this.f=this.P=this.i=null;this.Va=this.I=0;this.ka=this.C=this.s=this.m=this.o=this.c=null;this.v=this.Aa=this.S=-1;this.ga=this.B=this.G=0;this.T=a&&a.supportsCrossDomainXhr||!1;this.M=\"\";this.g=new Od(a&&a.concurrentRequestLimit);this.la=new Wd;this.F=a&&void 0!==a.backgroundChannelTest?a.backgroundChannelTest:!0;this.Ua=a&&a.fastHandshake||!1}\ng=ke.prototype;g.oa=8;g.D=1;function le(a){I(a.a,\"disconnect()\");me(a);if(3==a.D){var b=a.I++,c=M(a.H);R(c,\"SID\",a.M);R(c,\"RID\",b);R(c,\"TYPE\",\"terminate\");ne(a,c);b=new L(a,a.a,0,b,void 0);b.I=2;b.l=Mc(M(c));c=!1;k.navigator&&k.navigator.sendBeacon&&(c=k.navigator.sendBeacon(b.l.toString(),\"\"));c||((new Image).src=b.l);b.H=t();Pc(b)}oe(a)}\nfunction me(a){a.C&&(a.C.abort(),a.C=null);a.b&&(a.b.cancel(),a.b=null);a.m&&(k.clearTimeout(a.m),a.m=null);pe(a);a.g.cancel();a.o&&(k.clearTimeout(a.o),a.o=null)}function qe(a,b){if(1E3==a.h.length){var c=\"Already have 1000 queued maps upon queueing \"+Eb(b),d=a.a.a;d&&F(d,c)}a.h.push(new Ud(a.Va++,b));3==a.D&&re(a)}g.Ka=function(){return 0==this.D};function re(a){Sd(a.g)||a.o||(a.o=xc(r(a.Pa,a),0),a.G=0)}\ng.Pa=function(a){this.o=null;I(this.a,\"startForwardChannel_\");if(1==this.D)if(a)(a=this.a.a)&&F(a,\"Not supposed to retry the open\");else{I(this.a,\"open_()\");this.I=Math.floor(1E5*Math.random());a=this.I++;var b=new L(this,this.a,0,a,void 0),c=this.i;this.P&&(c?(c=Ea(c),Ga(c,this.P)):c=this.P);null===this.f&&(b.h=c);var d=se(this),e=M(this.H);R(e,\"RID\",a);0<this.za&&R(e,\"CVER\",this.za);this.F&&this.j&&R(e,\"X-HTTP-Session-Id\",this.j);ne(this,e);this.f&&c&&je(e,this.f,c);Rd(this.g,b);this.Ua?(R(e,\"$req\",\nd),Lc(b,e,null)):Lc(b,e,d);this.D=2}else 3==this.D&&(a?te(this,a):0==this.h.length?I(this.a,\"startForwardChannel_ returned: nothing to send\"):Sd(this.g)?(a=this.a.a)&&F(a,\"startForwardChannel_ returned: connection already in progress\"):(te(this),I(this.a,\"startForwardChannel_ finished, sent request\")))};\nfunction te(a,b){if(b){a.h=a.l.concat(a.h);a.l.length=0;var c=a.I-1}else c=a.I++;b=se(a);var d=M(a.H);R(d,\"SID\",a.M);R(d,\"RID\",c);R(d,\"AID\",a.S);ne(a,d);a.f&&a.i&&je(d,a.f,a.i);c=new L(a,a.a,0,c,a.G+1);null===a.f&&(c.h=a.i);c.setTimeout(Math.round(1E4)+Math.round(1E4*Math.random()));Rd(a.g,c);Lc(c,d,b)}function ne(a,b){a.c&&Zc({},function(a,d){R(b,d,a)})}\nfunction se(a){var b=Math.min(a.h.length,1E3),c=a.c?r(a.c.Wa,a.c,a):null,d=a.h,e=[\"count=\"+b];if(0<b){var f=d[0].a;e.push(\"ofs=\"+f)}else f=0;for(var h=0;h<b;h++){var m=d[h].a,v=d[h].b;m-=f;try{Xd(v,e,\"req\"+m+\"_\")}catch(Sa){c&&c(v)}}c=e.join(\"&\");a.l=a.l.concat(a.h.splice(0,b));return c}function ue(a){if(!a.b&&!a.m){a.ga=1;var b=a.Oa;Tb||Ub();Wb||(Tb(),Wb=!0);Pb.add(b,a);a.B=0}}\nfunction ve(a){if(a.b||a.m)return(a=a.a.a)&&F(a,\"Request already in progress\"),!1;if(3<=a.B)return!1;I(a.a,\"Going to retry GET\");a.ga++;a.m=xc(r(a.Oa,a),we(a,a.B));a.B++;return!0}\ng.Oa=function(){this.m=null;I(this.a,\"Creating new HttpRequest\");this.b=new L(this,this.a,0,\"rpc\",this.ga);null===this.f&&(this.b.h=this.i);this.b.N=0;var a=M(this.ya);R(a,\"RID\",\"rpc\");R(a,\"SID\",this.M);R(a,\"CI\",this.ka?\"0\":\"1\");R(a,\"AID\",this.S);ne(this,a);R(a,\"TYPE\",\"xmlhttp\");this.f&&this.i&&je(a,this.f,this.i);Oc(this.b,a,!0,this.ia);I(this.a,\"New Request created\")};\nfunction Jd(a,b,c){I(a.a,\"Test Connection Finished\");var d=b.m;d&&Qd(a.g,d);a.ka=c;a.v=b.f;I(a.a,\"connectChannel_()\");a.H=xe(a,a.ja);re(a)}function Ld(a,b){I(a.a,\"Test Connection Failed\");a.v=b.f;W(a,2)}\ng.Na=function(a,b){if(0!=this.D&&(this.b==a||Td(this.g,a)))if(this.v=a.v,Td(this.g,a)&&3==this.D){try{var c=this.la.a.parse(b)}catch(f){c=null}if(n(c)&&3==c.length)if(b=c,0==b[0])a:if(I(this.a,\"Server claims our backchannel is missing.\"),this.m)I(this.a,\"But we are currently starting the request.\");else{if(this.b)if(this.b.H+3E3<a.H)pe(this),this.b.cancel(),this.b=null;else break a;else(a=this.a.a)&&G(a,\"We do not have a BackChannel established\");ve(this);K()}else this.Aa=b[1],a=this.Aa-this.S,0<\na&&(b=b[2],I(this.a,b+\" bytes (in \"+a+\" arrays) are outstanding on the BackChannel\"),37500>b&&this.ka&&0==this.B&&!this.s&&(this.s=xc(r(this.ab,this),6E3)));else I(this.a,\"Bad POST response data returned\"),W(this,11)}else if(this.b==a&&pe(this),!/^[\\s\\xa0]*$/.test(b))for(b=c=this.la.a.parse(b),c=0;c<b.length;c++){var d=b[c];this.S=d[0];d=d[1];if(2==this.D)if(\"c\"==d[0]){this.M=d[1];this.ia=d[2];var e=d[3];null!=e&&(this.oa=e,I(this.a,\"VER=\"+this.oa));d=d[4];null!=d&&(this.Ba=d,I(this.a,\"SVER=\"+this.Ba));\nthis.F&&(d=a.a)&&((e=d.a?d.a.getResponseHeader(\"X-Client-Wire-Protocol\"):null)&&Qd(this.g,e),this.j&&((d=d.a?d.a.getResponseHeader(\"X-HTTP-Session-Id\"):null)?(this.N=d,R(this.H,this.j,d)):(d=this.a.a)&&G(d,\"Missing X_HTTP_SESSION_ID in the handshake response\")));this.D=3;this.c&&this.c.Fa(this);this.ya=Kd(this,this.ia,this.ja);ue(this)}else\"stop\"!=d[0]&&\"close\"!=d[0]||W(this,7);else 3==this.D&&(\"stop\"==d[0]||\"close\"==d[0]?\"stop\"==d[0]?W(this,7):le(this):\"noop\"!=d[0]&&this.c&&this.c.Ea(this,d),this.B=\n0)}};g.ab=function(){null!=this.s&&(this.s=null,this.b.cancel(),this.b=null,ve(this),K())};function pe(a){null!=a.s&&(k.clearTimeout(a.s),a.s=null)}\ng.wa=function(a){I(this.a,\"Request complete\");if(this.b==a){pe(this);this.b=null;var b=2}else if(Td(this.g,a))b=this.g,b.b&&b.b==a?b.b=null:b.a&&b.a.contains(a)&&bd(b.a.a,Nd(a)),b=1;else return;this.v=a.v;if(0!=this.D)if(a.c)1==b?(t(),J.dispatchEvent(new wc(J)),re(this),this.l.length=0):ue(this);else{var c=a.i;if(3==c||0==c&&0<this.v)I(this.a,\"Not retrying due to error type\");else{I(this.a,\"Maybe retrying, last error: \"+Ic(c,this.v));var d;if(d=1==b)Sd(this.g)||this.o?((a=this.a.a)&&F(a,\"Request already in progress\"),\nd=!1):1==this.D||2==this.D||2<=this.G?d=!1:(I(this.a,\"Going to retry POST\"),this.o=xc(r(this.Pa,this,a),we(this,this.G)),this.G++,d=!0);if(d||2==b&&ve(this))return;I(this.a,\"Exceeded max number of retries\")}I(this.a,\"Error: HTTP request failed\");switch(c){case 1:W(this,5);break;case 4:W(this,10);break;case 3:W(this,6);break;default:W(this,2)}}};function we(a,b){var c=5E3+Math.floor(1E4*Math.random());a.sa()||(I(a.a,\"Inactive channel\"),c*=2);return c*b}\nfunction W(a,b){I(a.a,\"Error code \"+b);if(2==b){var c=null;a.c&&(c=null);var d=r(a.ib,a);c||(c=new Q(\"//www.google.com/images/cleardot.gif\"),k.location&&\"http\"==k.location.protocol||ed(c,\"https\"),Mc(c));Yd(c.toString(),d)}else K();I(a.a,\"HttpChannel: error - \"+b);a.D=0;a.c&&a.c.Da(a,b);oe(a);me(a)}g.ib=function(a){a?I(this.a,\"Successfully pinged google.com\"):I(this.a,\"Failed to ping google.com\");K()};\nfunction oe(a){a.D=0;a.v=-1;if(a.c)if(0==a.l.length&&0==a.h.length)a.c.na(a);else{I(a.a,\"Number of undelivered maps, pending: \"+a.l.length+\", outgoing: \"+a.h.length);var b=ya(a.l),c=ya(a.h);a.l.length=0;a.h.length=0;a.c.na(a,b,c)}}function xe(a,b){b=ye(a,null,b);I(a.a,\"GetForwardChannelUri: \"+b);return b}function Kd(a,b,c){b=ye(a,a.fa()?b:null,c);I(a.a,\"GetBackChannelUri: \"+b);return b}\nfunction ye(a,b,c){var d=td(c);if(\"\"!=d.b)b&&fd(d,b+\".\"+d.b),gd(d,d.i);else{var e=k.location,f;b?f=b+\".\"+e.hostname:f=e.hostname;d=ud(e.protocol,f,e.port,c)}a.ha&&Ba(a.ha,function(a,b){R(d,b,a)});b=a.j;c=a.N;b&&c&&R(d,b,c);R(d,\"VER\",a.oa);ne(a,d);return d}g.ra=function(a){if(a&&!this.T)throw Error(\"Can't create secondary domain capable XhrIo object.\");a=new U;a.m=this.T;return a};g.sa=function(){return!!this.c&&!0};g.fa=function(){return this.T};new Cd;function ze(){}g=ze.prototype;g.Fa=function(){};\ng.Ea=function(){};g.Da=function(){};g.na=function(){};g.Wa=function(){};function Ae(a){for(var b=arguments[0],c=1;c<arguments.length;c++){var d=arguments[c];if(0==d.lastIndexOf(\"/\",0))b=d;else{var e;(e=\"\"==b)||(e=b.length-1,e=0<=e&&b.indexOf(\"/\",e)==e);e?b+=d:b+=\"/\"+d}}return b};function Be(){if(z&&!(10<=Number(Va)))throw Error(\"Environmental error: no available transport.\");}Be.prototype.a=function(a,b){return new X(a,b)};\nfunction X(a,b){B.call(this);this.a=new ke(b,20);this.b=a;this.s=b&&b.testUrl?b.testUrl:Ae(this.b,\"test\");this.f=oc(\"goog.labs.net.webChannel.WebChannelBaseTransport\");this.g=b&&b.messageUrlParams||null;a=b&&b.messageHeaders||null;b&&b.clientProtocolHeaderRequired&&(a?a[\"X-Client-Protocol\"]=\"webchannel\":a={\"X-Client-Protocol\":\"webchannel\"});this.a.i=a;this.a.P=b&&b.initMessageHeaders||null;(a=b&&b.httpHeadersOverwriteParam)&&!/^[\\s\\xa0]*$/.test(a)&&(this.a.f=a);this.o=b&&b.supportsCrossDomainXhr||\n!1;this.m=b&&b.sendRawJson||!1;(b=b&&b.httpSessionIdParam)&&!/^[\\s\\xa0]*$/.test(b)&&(this.a.j=b,a=this.g,null!==a&&b in a&&(a=this.g,b in a&&delete a[b],(a=this.f)&&G(a,\"Ignore httpSessionIdParam also specified with messageUrlParams: \"+b)));this.h=new Ce(this)}u(X,B);\nX.prototype.j=function(){this.a.c=this.h;this.o&&(this.a.T=!0);var a=this.a,b=this.s,c=this.b,d=this.g||void 0;I(a.a,\"connect()\");K();a.ja=c;a.ha=d||{};a.F&&(I(a.a,\"connect() bypassed channel-test.\"),a.J.b=[],a.J.a=!1);I(a.a,\"connectTest_()\");a.C=new Hd(a,a.a);null===a.f&&(a.C.i=a.i);c=b;a.f&&a.i&&(c=je(b,a.f,a.i));a=a.C;a.l=c;b=xe(a.a,a.l);K();c=a.a.J.b;null!=c?(a.g=c[0],a.R=1,Id(a)):(Qc(b,\"MODE\",\"init\"),!a.a.F&&a.a.j&&Qc(b,\"X-HTTP-Session-Id\",a.a.j),a.c=new L(a,a.b,0,void 0,void 0),a.c.h=a.i,Oc(a.c,\nb,!1,null),a.R=0)};X.prototype.close=function(){le(this.a)};X.prototype.l=function(a){if(this.m){var b={};b.__data__=Eb(a);qe(this.a,b)}else qe(this.a,a)};X.prototype.w=function(){this.a.c=null;delete this.h;le(this.a);delete this.a;X.L.w.call(this)};function De(a){Fd.call(this);this.data=a}u(De,Fd);function Ee(){Gd.call(this);this.status=1}u(Ee,Gd);function Ce(a){this.a=a}u(Ce,ze);Ce.prototype.Fa=function(){pc(this.a.f,\"WebChannel opened on \"+this.a.b);this.a.dispatchEvent(\"a\")};\nCe.prototype.Ea=function(a,b){this.a.dispatchEvent(new De(b))};Ce.prototype.Da=function(a,b){pc(this.a.f,\"WebChannel aborted on \"+this.a.b+\" due to channel error: \"+b);this.a.dispatchEvent(new Ee)};Ce.prototype.na=function(){pc(this.a.f,\"WebChannel closed on \"+this.a.b);this.a.dispatchEvent(\"b\")};var Fe=ia(function(a,b){function c(){}c.prototype=a.prototype;var d=new c;a.apply(d,Array.prototype.slice.call(arguments,1));return d},Be);function Ge(){this.b=[];this.a=[]}function He(a){0==a.b.length&&(a.b=a.a,a.b.reverse(),a.a=[]);return a.b.pop()}Ge.prototype.u=function(){return this.b.length+this.a.length};Ge.prototype.contains=function(a){return 0<=sa(this.b,a)||0<=sa(this.a,a)};Ge.prototype.A=function(){for(var a=[],b=this.b.length-1;0<=b;--b)a.push(this.b[b]);var c=this.a.length;for(b=0;b<c;++b)a.push(this.a[b]);return a};function Ie(a,b){w.call(this);this.h=a||0;this.c=b||10;if(this.h>this.c)throw Error(Je);this.a=new Ge;this.b=new T;this.g=null;this.aa()}u(Ie,w);var Je=\"[goog.structs.Pool] Min can not be greater than max\";g=Ie.prototype;g.ca=function(){var a=t();if(!(null!=this.g&&0>a-this.g)){for(var b;0<this.a.u()&&(b=He(this.a),!this.va(b));)this.aa();!b&&this.u()<this.c&&(b=this.qa());b&&(this.g=a,this.b.add(b));return b}};g.hb=function(a){return bd(this.b.a,Nd(a))?(this.ma(a),!0):!1};\ng.ma=function(a){bd(this.b.a,Nd(a));this.va(a)&&this.u()<this.c?this.a.a.push(a):Ke(a)};g.aa=function(){for(var a=this.a;this.u()<this.h;){var b=this.qa();a.a.push(b)}for(;this.u()>this.c&&0<this.a.u();)Ke(He(a))};g.qa=function(){return{}};function Ke(a){if(\"function\"==typeof a.Y)a.Y();else for(var b in a)a[b]=null}g.va=function(a){return\"function\"==typeof a.Xa?a.Xa():!0};g.contains=function(a){return this.a.contains(a)||this.b.contains(a)};g.u=function(){return this.a.u()+this.b.u()};\ng.w=function(){Ie.L.w.call(this);if(0<this.b.u())throw Error(\"[goog.structs.Pool] Objects not released\");delete this.b;for(var a=this.a;0!=a.b.length||0!=a.a.length;)Ke(He(a));delete this.a};function Le(a,b){this.a=a;this.b=b};function Me(a){this.a=[];if(a)a:{if(a instanceof Me){var b=a.O();a=a.A();if(0>=this.u()){for(var c=this.a,d=0;d<b.length;d++)c.push(new Le(b[d],a[d]));break a}}else b=Da(a),a=Ca(a);for(d=0;d<b.length;d++)Ne(this,b[d],a[d])}}function Ne(a,b,c){var d=a.a;d.push(new Le(b,c));b=d.length-1;a=a.a;for(c=a[b];0<b;)if(d=b-1>>1,a[d].a>c.a)a[b]=a[d],b=d;else break;a[b]=c}Me.prototype.A=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].b);return b};\nMe.prototype.O=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].a);return b};Me.prototype.u=function(){return this.a.length};function Oe(){Me.call(this)}u(Oe,Me);function Y(a,b){this.f=new Oe;Ie.call(this,a,b)}u(Y,Ie);g=Y.prototype;g.ca=function(a,b){if(!a)return Y.L.ca.call(this);Ne(this.f,void 0!==b?b:100,a);this.ua()};g.ua=function(){for(var a=this.f;0<a.u();){var b=this.ca();if(b){var c=a,d=c.a,e=d.length;var f=d[0];if(0>=e)f=void 0;else{if(1==e)wa(d);else{d[0]=d.pop();d=0;c=c.a;e=c.length;for(var h=c[d];d<e>>1;){var m=2*d+1,v=2*d+2;m=v<e&&c[v].a<c[m].a?v:m;if(c[m].a>h.a)break;c[d]=c[m];d=m}c[d]=h}f=f.b}f.apply(this,[b])}else break}};\ng.ma=function(a){Y.L.ma.call(this,a);this.ua()};g.aa=function(){Y.L.aa.call(this);this.ua()};g.w=function(){Y.L.w.call(this);k.clearTimeout(void 0);wa(this.f.a);this.f=null};function Z(a,b,c,d){this.l=a;this.j=!!d;Y.call(this,b,c)}u(Z,Y);Z.prototype.qa=function(){var a=new U,b=this.l;b&&b.forEach(function(b,d){a.headers.set(d,b)});this.j&&(a.m=!0);return a};Z.prototype.va=function(a){return!a.i&&!a.a};Be.prototype.createWebChannel=Be.prototype.a;X.prototype.send=X.prototype.l;X.prototype.open=X.prototype.j;X.prototype.close=X.prototype.close;yc.NO_ERROR=0;yc.TIMEOUT=8;yc.HTTP_ERROR=6;zc.COMPLETE=\"complete\";Dd.EventType=Ed;Ed.OPEN=\"a\";Ed.CLOSE=\"b\";Ed.ERROR=\"c\";Ed.MESSAGE=\"d\";B.prototype.listen=B.prototype.$;Z.prototype.getObject=Z.prototype.ca;Z.prototype.releaseObject=Z.prototype.hb;U.prototype.listenOnce=U.prototype.Ia;U.prototype.getLastError=U.prototype.$a;U.prototype.getLastErrorCode=U.prototype.Ga;\nU.prototype.getStatus=U.prototype.V;U.prototype.getStatusText=U.prototype.Ha;U.prototype.getResponseJson=U.prototype.Za;U.prototype.getResponseText=U.prototype.U;U.prototype.getResponseText=U.prototype.U;U.prototype.send=U.prototype.ta;module.exports={createWebChannelTransport:Fe,ErrorCode:yc,EventType:zc,WebChannel:Dd,XhrIoPool:Z};}).call(typeof window !== 'undefined' ? window : this)\n\n\n/***/ })\n\n},[113]);\n        } catch(error) {\n          throw new Error(\n            'Cannot instantiate firebase-firestore.js - ' +\n            'be sure to load firebase-app.js first.'\n          )\n        }\n\n\n// WEBPACK FOOTER //\n// firebase-firestore.js","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nrequire('@firebase/firestore');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./firestore/index.js\n// module id = 113\n// module chunks = 1","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* tslint:disable:no-console */\nimport { SDK_VERSION } from '../core/version';\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"ERROR\"] = 1] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 2] = \"SILENT\";\n})(LogLevel = LogLevel || (LogLevel = {}));\nvar logLevel = LogLevel.ERROR;\n// Helper methods are needed because variables can't be exported as read/write\nexport function getLogLevel() {\n    return logLevel;\n}\nexport function setLogLevel(newLevel) {\n    logLevel = newLevel;\n}\nexport function debug(tag, msg) {\n    var obj = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        obj[_i - 2] = arguments[_i];\n    }\n    if (logLevel <= LogLevel.DEBUG) {\n        var time = new Date().toISOString();\n        var args = obj.map(argToString);\n        console.log.apply(console, [\"Firestore (\" + SDK_VERSION + \") \" + time + \" [\" + tag + \"]: \" + msg].concat(args));\n    }\n}\nexport function error(msg) {\n    var obj = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        obj[_i - 1] = arguments[_i];\n    }\n    if (logLevel <= LogLevel.ERROR) {\n        var time = new Date().toISOString();\n        var args = obj.map(argToString);\n        console.error.apply(console, [\"Firestore (\" + SDK_VERSION + \") \" + time + \": \" + msg].concat(args));\n    }\n}\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj) {\n    if (typeof obj === 'string') {\n        return obj;\n    }\n    else {\n        try {\n            return JSON.stringify(obj);\n        }\n        catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n\n//# sourceMappingURL=log.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/log.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SDK_VERSION } from '../core/version';\nimport { error } from './log';\n/**\n * Unconditionally fails, throwing an Error with the given message.\n *\n * Returns any so it can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nexport function fail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    var message = \"FIRESTORE (\" + SDK_VERSION + \") INTERNAL ASSERTION FAILED: \" + failure;\n    error(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n */\nexport function assert(assertion, message) {\n    if (!assertion) {\n        fail(message);\n    }\n}\n\n//# sourceMappingURL=assert.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/assert.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\n/**\n * Provides singleton helpers where setup code can inject a platform at runtime.\n * setPlatform needs to be set before Firestore is used and must be set exactly\n * once.\n */\nvar PlatformSupport = /** @class */ (function () {\n    function PlatformSupport() {\n    }\n    PlatformSupport.setPlatform = function (platform) {\n        if (PlatformSupport.platform) {\n            fail('Platform already defined');\n        }\n        PlatformSupport.platform = platform;\n    };\n    PlatformSupport.getPlatform = function () {\n        if (!PlatformSupport.platform) {\n            fail('Platform not set');\n        }\n        return PlatformSupport.platform;\n    };\n    return PlatformSupport;\n}());\nexport { PlatformSupport };\n/**\n * Returns the representation of an empty \"proto\" byte string for the\n * platform.\n */\nexport function emptyByteString() {\n    return PlatformSupport.getPlatform().emptyByteString;\n}\n\n//# sourceMappingURL=platform.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform/platform.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// We are doing some heavy reflective stuff, lots of any casting necessary\n/* tslint:disable:no-any */\nimport { Code, FirestoreError } from './error';\n/**\n * Helper function to prevent instantiation through the constructor.\n *\n * This method creates a new constructor that throws when it's invoked.\n * The prototype of that constructor is then set to the prototype of the hidden\n * \"class\" to expose all the prototype methods and allow for instanceof\n * checks.\n *\n * To also make all the static methods available, all properties of the\n * original constructor are copied to the new constructor.\n */\nexport function makeConstructorPrivate(cls, optionalMessage) {\n    function PublicConstructor() {\n        var error = 'This constructor is private.';\n        if (optionalMessage) {\n            error += ' ';\n            error += optionalMessage;\n        }\n        throw new FirestoreError(Code.INVALID_ARGUMENT, error);\n    }\n    // Make sure instanceof checks work and all methods are exposed on the public\n    // constructor\n    PublicConstructor.prototype = cls.prototype;\n    // Copy any static methods/members\n    for (var staticProperty in cls) {\n        if (cls.hasOwnProperty(staticProperty)) {\n            PublicConstructor[staticProperty] = cls[staticProperty];\n        }\n    }\n    return PublicConstructor;\n}\n\n//# sourceMappingURL=api.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/api.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from './assert';\nexport function contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexport function get(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : null;\n}\nexport function size(obj) {\n    var count = 0;\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\n/** Returns the given value if it's defined or the defaultValue otherwise. */\nexport function defaulted(value, defaultValue) {\n    return value !== undefined ? value : defaultValue;\n}\nexport function forEachNumber(obj, fn) {\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var num = parseInt(key, 10);\n            if (!isNaN(num)) {\n                fn(num, obj[key]);\n            }\n        }\n    }\n}\nexport function forEach(obj, fn) {\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nexport function lookupOrInsert(obj, key, valFn) {\n    if (!contains(obj, key)) {\n        obj[key] = valFn();\n    }\n    return obj[key];\n}\nexport function isEmpty(obj) {\n    assert(obj != null && typeof obj === 'object', 'isEmpty() expects object parameter.');\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function shallowCopy(obj) {\n    assert(obj && typeof obj === 'object', 'shallowCopy() expects object parameter.');\n    var result = {};\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=obj.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/obj.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from './assert';\nimport { Code, FirestoreError } from './error';\nimport * as obj from './obj';\n/**\n * Validates the invocation of functionName has the exact number of arguments.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateExactNumberOfArgs('myFunction', arguments, 2);\n */\nexport function validateExactNumberOfArgs(functionName, args, numberOfArgs) {\n    if (args.length !== numberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires \" +\n            formatPlural(numberOfArgs, 'argument') +\n            ', but was called with ' +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the invocation of functionName has at least the provided number of\n * arguments (but can have many more).\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateAtLeastNumberOfArgs('myFunction', arguments, 2);\n */\nexport function validateAtLeastNumberOfArgs(functionName, args, minNumberOfArgs) {\n    if (args.length < minNumberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires at least \" +\n            formatPlural(minNumberOfArgs, 'argument') +\n            ', but was called with ' +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the invocation of functionName has number of arguments between\n * the values provided.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateBetweenNumberOfArgs('myFunction', arguments, 2, 3);\n */\nexport function validateBetweenNumberOfArgs(functionName, args, minNumberOfArgs, maxNumberOfArgs) {\n    if (args.length < minNumberOfArgs || args.length > maxNumberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires between \" + minNumberOfArgs + \" and \" +\n            (maxNumberOfArgs + \" arguments, but was called with \") +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the provided argument is an array and has as least the expected\n * number of elements.\n */\nexport function validateNamedArrayAtLeastNumberOfElements(functionName, value, name, minNumberOfElements) {\n    if (!(value instanceof Array) || value.length < minNumberOfElements) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + name + \" argument to be an \" +\n            'array with at least ' +\n            (formatPlural(minNumberOfElements, 'element') + \".\"));\n    }\n}\n/**\n * Validates the provided positional argument has the native JavaScript type\n * using typeof checks.\n */\nexport function validateArgType(functionName, type, position, argument) {\n    validateType(functionName, type, ordinal(position) + \" argument\", argument);\n}\n/**\n * Validates the provided argument has the native JavaScript type using\n * typeof checks or is undefined.\n */\nexport function validateOptionalArgType(functionName, type, position, argument) {\n    if (argument !== undefined) {\n        validateArgType(functionName, type, position, argument);\n    }\n}\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks.\n */\nexport function validateNamedType(functionName, type, optionName, argument) {\n    validateType(functionName, type, optionName + \" option\", argument);\n}\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks or is undefined.\n */\nexport function validateNamedOptionalType(functionName, type, optionName, argument) {\n    if (argument !== undefined) {\n        validateNamedType(functionName, type, optionName, argument);\n    }\n}\n/** Helper to validate the type of a provided input. */\nfunction validateType(functionName, type, inputName, input) {\n    if (typeof input !== type || (type === 'object' && !isPlainObject(input))) {\n        var description = valueDescription(input);\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + inputName + \" \" +\n            (\"to be of type \" + type + \", but it was: \" + description));\n    }\n}\n/**\n * Returns true iff it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nexport function isPlainObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        Object.getPrototypeOf(input) === Object.prototype);\n}\n/** Returns a string describing the type / value of the provided input. */\nexport function valueDescription(input) {\n    if (input === undefined) {\n        return 'undefined';\n    }\n    else if (input === null) {\n        return 'null';\n    }\n    else if (typeof input === 'string') {\n        if (input.length > 20) {\n            input = input.substring(0, 20) + \"...\";\n        }\n        return JSON.stringify(input);\n    }\n    else if (typeof input === 'number' || typeof input === 'boolean') {\n        return '' + input;\n    }\n    else if (typeof input === 'object') {\n        if (input instanceof Array) {\n            return 'an array';\n        }\n        else {\n            var customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return \"a custom \" + customObjectName + \" object\";\n            }\n            else {\n                return 'an object';\n            }\n        }\n    }\n    else if (typeof input === 'function') {\n        return 'a function';\n    }\n    else {\n        return fail('Unknown wrong type: ' + typeof input);\n    }\n}\n/** Hacky method to try to get the constructor name for an object. */\nexport function tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        var funcNameRegex = /function\\s+([^\\s(]+)\\s*\\(/;\n        var results = funcNameRegex.exec(input.constructor.toString());\n        if (results && results.length > 1) {\n            return results[1];\n        }\n    }\n    return null;\n}\n/** Validates the provided argument is defined. */\nexport function validateDefined(functionName, position, argument) {\n    if (argument === undefined) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires a valid \" + ordinal(position) + \" \" +\n            \"argument, but it was undefined.\");\n    }\n}\n/**\n * Validates the provided positional argument is an object, and its keys and\n * values match the expected keys and types provided in optionTypes.\n */\nexport function validateOptionNames(functionName, options, optionNames) {\n    obj.forEach(options, function (key, _) {\n        if (optionNames.indexOf(key) < 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Unknown option '\" + key + \"' passed to function \" + functionName + \"(). \" +\n                'Available options: ' +\n                optionNames.join(', '));\n        }\n    });\n}\n/**\n * Helper method to throw an error that the provided argument did not pass\n * an instanceof check.\n */\nexport function invalidClassError(functionName, type, position, argument) {\n    var description = valueDescription(argument);\n    return new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + ordinal(position) + \" \" +\n        (\"argument to be a \" + type + \", but it was: \" + description));\n}\n/** Converts a number to its english word representation */\nfunction ordinal(num) {\n    switch (num) {\n        case 1:\n            return 'first';\n        case 2:\n            return 'second';\n        case 3:\n            return 'third';\n        default:\n            return num + 'th';\n    }\n}\n/**\n * Formats the given word as plural conditionally given the preceding number.\n */\nfunction formatPlural(num, str) {\n    return num + \" \" + str + (num === 1 ? '' : 's');\n}\n\n//# sourceMappingURL=input_validation.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/input_validation.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from './assert';\n// tslint:disable-next-line:class-as-namespace\nvar AutoId = /** @class */ (function () {\n    function AutoId() {\n    }\n    AutoId.newId = function () {\n        // Alphanumeric characters\n        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var autoId = '';\n        for (var i = 0; i < 20; i++) {\n            autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n        return autoId;\n    };\n    return AutoId;\n}());\nexport { AutoId };\nexport function primitiveComparator(left, right) {\n    if (left < right)\n        return -1;\n    if (left > right)\n        return 1;\n    return 0;\n}\n/** Helper to compare nullable (or undefined-able) objects using equals(). */\nexport function equals(left, right) {\n    if (left !== null && left !== undefined) {\n        return !!(right && left.equals(right));\n    }\n    else {\n        // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n        // smart enough.\n        return left === right;\n    }\n}\n/** Helper to compare arrays using equals(). */\nexport function arrayEquals(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (var i = 0; i < left.length; i++) {\n        if (!left[i].equals(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\nexport function immediatePredecessor(s) {\n    // We can decrement the last character in the string and be done\n    // unless that character is 0 (0x0000), in which case we have to erase the\n    // last character.\n    var lastIndex = s.length - 1;\n    if (s.length === 0) {\n        // Special case the empty string.\n        return '';\n    }\n    else if (s.charAt(lastIndex) === '\\0') {\n        return s.substring(0, lastIndex);\n    }\n    else {\n        return (s.substring(0, lastIndex) +\n            String.fromCharCode(s.charCodeAt(lastIndex) - 1));\n    }\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nexport function immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n//# sourceMappingURL=misc.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/misc.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PlatformSupport } from '../platform/platform';\nimport { makeConstructorPrivate } from '../util/api';\nimport { Code, FirestoreError } from '../util/error';\nimport { invalidClassError, validateArgType, validateExactNumberOfArgs } from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\n/** Helper function to assert Uint8Array is available at runtime. */\nfunction assertUint8ArrayAvailable() {\n    if (typeof Uint8Array === 'undefined') {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'Uint8Arrays are not available in this environment.');\n    }\n}\n/** Helper function to assert Base64 functions are available at runtime. */\nfunction assertBase64Available() {\n    if (!PlatformSupport.getPlatform().base64Available) {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'Blobs are unavailable in Firestore in this environment.');\n    }\n}\n/**\n * Immutable class holding a blob (binary data).\n * This class is directly exposed in the public API.\n *\n * Note that while you can't hide the constructor in JavaScript code, we are\n * using the hack above to make sure no-one outside this module can call it.\n */\nvar Blob = /** @class */ (function () {\n    function Blob(binaryString) {\n        assertBase64Available();\n        this._binaryString = binaryString;\n    }\n    Blob.fromBase64String = function (base64) {\n        validateExactNumberOfArgs('Blob.fromBase64String', arguments, 1);\n        validateArgType('Blob.fromBase64String', 'string', 1, base64);\n        assertBase64Available();\n        try {\n            var binaryString = PlatformSupport.getPlatform().atob(base64);\n            return new Blob(binaryString);\n        }\n        catch (e) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct Blob from Base64 string: ' + e);\n        }\n    };\n    Blob.fromUint8Array = function (array) {\n        validateExactNumberOfArgs('Blob.fromUint8Array', arguments, 1);\n        assertUint8ArrayAvailable();\n        if (!(array instanceof Uint8Array)) {\n            throw invalidClassError('Blob.fromUint8Array', 'Uint8Array', 1, array);\n        }\n        // We can't call array.map directly because it expects the return type to\n        // be a Uint8Array, whereas we can convert it to a regular array by invoking\n        // map on the Array prototype.\n        var binaryString = Array.prototype.map\n            .call(array, function (char) {\n            return String.fromCharCode(char);\n        })\n            .join('');\n        return new Blob(binaryString);\n    };\n    Blob.prototype.toBase64 = function () {\n        validateExactNumberOfArgs('Blob.toBase64', arguments, 0);\n        assertBase64Available();\n        return PlatformSupport.getPlatform().btoa(this._binaryString);\n    };\n    Blob.prototype.toUint8Array = function () {\n        validateExactNumberOfArgs('Blob.toUint8Array', arguments, 0);\n        assertUint8ArrayAvailable();\n        var buffer = new Uint8Array(this._binaryString.length);\n        for (var i = 0; i < this._binaryString.length; i++) {\n            buffer[i] = this._binaryString.charCodeAt(i);\n        }\n        return buffer;\n    };\n    Blob.prototype.toString = function () {\n        return 'Blob(base64: ' + this.toBase64() + ')';\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    Blob.prototype._equals = function (other) {\n        return this._binaryString === other._binaryString;\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    Blob.prototype._compareTo = function (other) {\n        return primitiveComparator(this._binaryString, other._binaryString);\n    };\n    return Blob;\n}());\nexport { Blob };\n// Public instance that disallows construction at runtime. This constructor is\n// used when exporting Blob on firebase.firestore.Blob and will be called Blob\n// publicly. Internally we still use Blob which has a type checked private\n// constructor. Note that Blob and PublicBlob can be used interchangeably in\n// instanceof checks.\n// For our internal TypeScript code PublicBlob doesn't exist as a type, and so\n// we need to use Blob as type and export it too.\n// tslint:disable-next-line:variable-name We're treating this as a class name.\nexport var PublicBlob = makeConstructorPrivate(Blob, 'Use Blob.fromUint8Array() or Blob.fromBase64String() instead.');\n\n//# sourceMappingURL=blob.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/blob.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedMap } from '../util/sorted_map';\nimport { DocumentKey } from './document_key';\nexport var TypeOrder;\n(function (TypeOrder) {\n    // This order is defined by the backend.\n    TypeOrder[TypeOrder[\"NullValue\"] = 0] = \"NullValue\";\n    TypeOrder[TypeOrder[\"BooleanValue\"] = 1] = \"BooleanValue\";\n    TypeOrder[TypeOrder[\"NumberValue\"] = 2] = \"NumberValue\";\n    TypeOrder[TypeOrder[\"TimestampValue\"] = 3] = \"TimestampValue\";\n    TypeOrder[TypeOrder[\"StringValue\"] = 4] = \"StringValue\";\n    TypeOrder[TypeOrder[\"BlobValue\"] = 5] = \"BlobValue\";\n    TypeOrder[TypeOrder[\"RefValue\"] = 6] = \"RefValue\";\n    TypeOrder[TypeOrder[\"GeoPointValue\"] = 7] = \"GeoPointValue\";\n    TypeOrder[TypeOrder[\"ArrayValue\"] = 8] = \"ArrayValue\";\n    TypeOrder[TypeOrder[\"ObjectValue\"] = 9] = \"ObjectValue\";\n})(TypeOrder = TypeOrder || (TypeOrder = {}));\n/**\n * A field value represents a datatype as stored by Firestore.\n */\nvar FieldValue = /** @class */ (function () {\n    function FieldValue() {\n    }\n    FieldValue.prototype.toString = function () {\n        var val = this.value();\n        return val === null ? 'null' : val.toString();\n    };\n    FieldValue.prototype.defaultCompareTo = function (other) {\n        assert(this.typeOrder !== other.typeOrder, 'Default compareTo should not be used for values of same type.');\n        var cmp = primitiveComparator(this.typeOrder, other.typeOrder);\n        return cmp;\n    };\n    return FieldValue;\n}());\nexport { FieldValue };\nvar NullValue = /** @class */ (function (_super) {\n    __extends(NullValue, _super);\n    function NullValue() {\n        var _this = _super.call(this) || this;\n        _this.typeOrder = TypeOrder.NullValue;\n        // internalValue is unused but we add it to work around\n        // https://github.com/Microsoft/TypeScript/issues/15585\n        _this.internalValue = null;\n        return _this;\n    }\n    NullValue.prototype.value = function () {\n        return null;\n    };\n    NullValue.prototype.equals = function (other) {\n        return other instanceof NullValue;\n    };\n    NullValue.prototype.compareTo = function (other) {\n        if (other instanceof NullValue) {\n            return 0;\n        }\n        return this.defaultCompareTo(other);\n    };\n    NullValue.INSTANCE = new NullValue();\n    return NullValue;\n}(FieldValue));\nexport { NullValue };\nvar BooleanValue = /** @class */ (function (_super) {\n    __extends(BooleanValue, _super);\n    function BooleanValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.BooleanValue;\n        return _this;\n    }\n    BooleanValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    BooleanValue.prototype.equals = function (other) {\n        return (other instanceof BooleanValue &&\n            this.internalValue === other.internalValue);\n    };\n    BooleanValue.prototype.compareTo = function (other) {\n        if (other instanceof BooleanValue) {\n            return primitiveComparator(this, other);\n        }\n        return this.defaultCompareTo(other);\n    };\n    BooleanValue.of = function (value) {\n        return value ? BooleanValue.TRUE : BooleanValue.FALSE;\n    };\n    BooleanValue.TRUE = new BooleanValue(true);\n    BooleanValue.FALSE = new BooleanValue(false);\n    return BooleanValue;\n}(FieldValue));\nexport { BooleanValue };\n/** Base class for IntegerValue and DoubleValue. */\nvar NumberValue = /** @class */ (function (_super) {\n    __extends(NumberValue, _super);\n    function NumberValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.NumberValue;\n        return _this;\n    }\n    NumberValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    NumberValue.prototype.compareTo = function (other) {\n        if (other instanceof NumberValue) {\n            return numericComparator(this.internalValue, other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return NumberValue;\n}(FieldValue));\nexport { NumberValue };\n/** Utility function to compare doubles (using Firestore semantics for NaN). */\nfunction numericComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    else if (left > right) {\n        return 1;\n    }\n    else if (left === right) {\n        return 0;\n    }\n    else {\n        // one or both are NaN.\n        if (isNaN(left)) {\n            return isNaN(right) ? 0 : -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\n/**\n * Utility function to check numbers for equality using Firestore semantics\n * (NaN === NaN, -0.0 !== 0.0).\n */\nfunction numericEquals(left, right) {\n    // Implemented based on Object.is() polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    if (left === right) {\n        // +0 != -0\n        return left !== 0 || 1 / left === 1 / right;\n    }\n    else {\n        // NaN == NaN\n        return left !== left && right !== right;\n    }\n}\nvar IntegerValue = /** @class */ (function (_super) {\n    __extends(IntegerValue, _super);\n    function IntegerValue(internalValue) {\n        return _super.call(this, internalValue) || this;\n    }\n    IntegerValue.prototype.equals = function (other) {\n        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,\n        // but that doesn't make them equal via equals().\n        if (other instanceof IntegerValue) {\n            return numericEquals(this.internalValue, other.internalValue);\n        }\n        else {\n            return false;\n        }\n    };\n    return IntegerValue;\n}(NumberValue));\nexport { IntegerValue };\nvar DoubleValue = /** @class */ (function (_super) {\n    __extends(DoubleValue, _super);\n    function DoubleValue(internalValue) {\n        var _this = _super.call(this, internalValue) || this;\n        _this.internalValue = internalValue;\n        return _this;\n    }\n    DoubleValue.prototype.equals = function (other) {\n        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,\n        // but that doesn't make them equal via equals().\n        if (other instanceof DoubleValue) {\n            return numericEquals(this.internalValue, other.internalValue);\n        }\n        else {\n            return false;\n        }\n    };\n    DoubleValue.NAN = new DoubleValue(NaN);\n    DoubleValue.POSITIVE_INFINITY = new DoubleValue(Infinity);\n    DoubleValue.NEGATIVE_INFINITY = new DoubleValue(-Infinity);\n    return DoubleValue;\n}(NumberValue));\nexport { DoubleValue };\n// TODO(b/37267885): Add truncation support\nvar StringValue = /** @class */ (function (_super) {\n    __extends(StringValue, _super);\n    function StringValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.StringValue;\n        return _this;\n    }\n    StringValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    StringValue.prototype.equals = function (other) {\n        return (other instanceof StringValue && this.internalValue === other.internalValue);\n    };\n    StringValue.prototype.compareTo = function (other) {\n        if (other instanceof StringValue) {\n            return primitiveComparator(this.internalValue, other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return StringValue;\n}(FieldValue));\nexport { StringValue };\nvar TimestampValue = /** @class */ (function (_super) {\n    __extends(TimestampValue, _super);\n    function TimestampValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.TimestampValue;\n        return _this;\n    }\n    TimestampValue.prototype.value = function () {\n        return this.internalValue.toDate();\n    };\n    TimestampValue.prototype.equals = function (other) {\n        return (other instanceof TimestampValue &&\n            this.internalValue.equals(other.internalValue));\n    };\n    TimestampValue.prototype.compareTo = function (other) {\n        if (other instanceof TimestampValue) {\n            return this.internalValue.compareTo(other.internalValue);\n        }\n        else if (other instanceof ServerTimestampValue) {\n            // Concrete timestamps come before server timestamps.\n            return -1;\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    return TimestampValue;\n}(FieldValue));\nexport { TimestampValue };\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   TransformMutation (see TransformMutation.applyTo()). They can only exist in\n *   the local view of a document. Therefore they do not need to be parsed or\n *   serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they evaluate to null.\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nvar ServerTimestampValue = /** @class */ (function (_super) {\n    __extends(ServerTimestampValue, _super);\n    function ServerTimestampValue(localWriteTime) {\n        var _this = _super.call(this) || this;\n        _this.localWriteTime = localWriteTime;\n        _this.typeOrder = TypeOrder.TimestampValue;\n        return _this;\n    }\n    ServerTimestampValue.prototype.value = function () {\n        return null;\n    };\n    ServerTimestampValue.prototype.equals = function (other) {\n        return (other instanceof ServerTimestampValue &&\n            this.localWriteTime.equals(other.localWriteTime));\n    };\n    ServerTimestampValue.prototype.compareTo = function (other) {\n        if (other instanceof ServerTimestampValue) {\n            return this.localWriteTime.compareTo(other.localWriteTime);\n        }\n        else if (other instanceof TimestampValue) {\n            // Server timestamps come after all concrete timestamps.\n            return 1;\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ServerTimestampValue.prototype.toString = function () {\n        return '<ServerTimestamp localTime=' + this.localWriteTime.toString() + '>';\n    };\n    return ServerTimestampValue;\n}(FieldValue));\nexport { ServerTimestampValue };\nvar BlobValue = /** @class */ (function (_super) {\n    __extends(BlobValue, _super);\n    function BlobValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.BlobValue;\n        return _this;\n    }\n    BlobValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    BlobValue.prototype.equals = function (other) {\n        return (other instanceof BlobValue &&\n            this.internalValue._equals(other.internalValue));\n    };\n    BlobValue.prototype.compareTo = function (other) {\n        if (other instanceof BlobValue) {\n            return this.internalValue._compareTo(other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return BlobValue;\n}(FieldValue));\nexport { BlobValue };\nvar RefValue = /** @class */ (function (_super) {\n    __extends(RefValue, _super);\n    function RefValue(databaseId, key) {\n        var _this = _super.call(this) || this;\n        _this.databaseId = databaseId;\n        _this.key = key;\n        _this.typeOrder = TypeOrder.RefValue;\n        return _this;\n    }\n    RefValue.prototype.value = function () {\n        return this.key;\n    };\n    RefValue.prototype.equals = function (other) {\n        if (other instanceof RefValue) {\n            return (this.key.equals(other.key) && this.databaseId.equals(other.databaseId));\n        }\n        else {\n            return false;\n        }\n    };\n    RefValue.prototype.compareTo = function (other) {\n        if (other instanceof RefValue) {\n            var cmp = this.databaseId.compareTo(other.databaseId);\n            return cmp !== 0 ? cmp : DocumentKey.comparator(this.key, other.key);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return RefValue;\n}(FieldValue));\nexport { RefValue };\nvar GeoPointValue = /** @class */ (function (_super) {\n    __extends(GeoPointValue, _super);\n    function GeoPointValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.GeoPointValue;\n        return _this;\n    }\n    GeoPointValue.prototype.value = function () {\n        return this.internalValue;\n    };\n    GeoPointValue.prototype.equals = function (other) {\n        return (other instanceof GeoPointValue &&\n            this.internalValue._equals(other.internalValue));\n    };\n    GeoPointValue.prototype.compareTo = function (other) {\n        if (other instanceof GeoPointValue) {\n            return this.internalValue._compareTo(other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return GeoPointValue;\n}(FieldValue));\nexport { GeoPointValue };\nvar ObjectValue = /** @class */ (function (_super) {\n    __extends(ObjectValue, _super);\n    function ObjectValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.ObjectValue;\n        return _this;\n    }\n    ObjectValue.prototype.value = function () {\n        var result = {};\n        this.internalValue.inorderTraversal(function (key, val) {\n            result[key] = val.value();\n        });\n        return result;\n    };\n    ObjectValue.prototype.forEach = function (action) {\n        this.internalValue.inorderTraversal(action);\n    };\n    ObjectValue.prototype.equals = function (other) {\n        if (other instanceof ObjectValue) {\n            var it1 = this.internalValue.getIterator();\n            var it2 = other.internalValue.getIterator();\n            while (it1.hasNext() && it2.hasNext()) {\n                var next1 = it1.getNext();\n                var next2 = it2.getNext();\n                if (next1.key !== next2.key || !next1.value.equals(next2.value)) {\n                    return false;\n                }\n            }\n            return !it1.hasNext() && !it2.hasNext();\n        }\n        return false;\n    };\n    ObjectValue.prototype.compareTo = function (other) {\n        if (other instanceof ObjectValue) {\n            var it1 = this.internalValue.getIterator();\n            var it2 = other.internalValue.getIterator();\n            while (it1.hasNext() && it2.hasNext()) {\n                var next1 = it1.getNext();\n                var next2 = it2.getNext();\n                var cmp = primitiveComparator(next1.key, next2.key) ||\n                    next1.value.compareTo(next2.value);\n                if (cmp) {\n                    return cmp;\n                }\n            }\n            // Only equal if both iterators are exhausted\n            return primitiveComparator(it1.hasNext(), it2.hasNext());\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ObjectValue.prototype.set = function (path, to) {\n        assert(!path.isEmpty(), 'Cannot set field for empty path on ObjectValue');\n        if (path.length === 1) {\n            return this.setChild(path.firstSegment(), to);\n        }\n        else {\n            var child = this.child(path.firstSegment());\n            if (!(child instanceof ObjectValue)) {\n                child = ObjectValue.EMPTY;\n            }\n            var newChild = child.set(path.popFirst(), to);\n            return this.setChild(path.firstSegment(), newChild);\n        }\n    };\n    ObjectValue.prototype.delete = function (path) {\n        assert(!path.isEmpty(), 'Cannot delete field for empty path on ObjectValue');\n        if (path.length === 1) {\n            return new ObjectValue(this.internalValue.remove(path.firstSegment()));\n        }\n        else {\n            // nested field\n            var child = this.child(path.firstSegment());\n            if (child instanceof ObjectValue) {\n                var newChild = child.delete(path.popFirst());\n                return new ObjectValue(this.internalValue.insert(path.firstSegment(), newChild));\n            }\n            else {\n                // Don't actually change a primitive value to an object for a delete\n                return this;\n            }\n        }\n    };\n    ObjectValue.prototype.contains = function (path) {\n        return this.field(path) !== undefined;\n    };\n    ObjectValue.prototype.field = function (path) {\n        assert(!path.isEmpty(), \"Can't get field of empty path\");\n        var field = this;\n        path.forEach(function (pathSegment) {\n            if (field instanceof ObjectValue) {\n                field = field.internalValue.get(pathSegment) || undefined;\n            }\n            else {\n                field = undefined;\n            }\n        });\n        return field;\n    };\n    ObjectValue.prototype.toString = function () {\n        return JSON.stringify(this.value());\n    };\n    ObjectValue.prototype.child = function (childName) {\n        return this.internalValue.get(childName) || undefined;\n    };\n    ObjectValue.prototype.setChild = function (childName, value) {\n        return new ObjectValue(this.internalValue.insert(childName, value));\n    };\n    ObjectValue.EMPTY = new ObjectValue(new SortedMap(primitiveComparator));\n    return ObjectValue;\n}(FieldValue));\nexport { ObjectValue };\nvar ArrayValue = /** @class */ (function (_super) {\n    __extends(ArrayValue, _super);\n    function ArrayValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.ArrayValue;\n        return _this;\n    }\n    ArrayValue.prototype.value = function () {\n        return this.internalValue.map(function (v) { return v.value(); });\n    };\n    ArrayValue.prototype.forEach = function (action) {\n        this.internalValue.forEach(action);\n    };\n    ArrayValue.prototype.equals = function (other) {\n        if (other instanceof ArrayValue) {\n            if (this.internalValue.length !== other.internalValue.length) {\n                return false;\n            }\n            for (var i = 0; i < this.internalValue.length; i++) {\n                if (!this.internalValue[i].equals(other.internalValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    ArrayValue.prototype.compareTo = function (other) {\n        if (other instanceof ArrayValue) {\n            var minLength = Math.min(this.internalValue.length, other.internalValue.length);\n            for (var i = 0; i < minLength; i++) {\n                var cmp = this.internalValue[i].compareTo(other.internalValue[i]);\n                if (cmp) {\n                    return cmp;\n                }\n            }\n            return primitiveComparator(this.internalValue.length, other.internalValue.length);\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ArrayValue.prototype.toString = function () {\n        return JSON.stringify(this.value());\n    };\n    return ArrayValue;\n}(FieldValue));\nexport { ArrayValue };\n\n//# sourceMappingURL=field_value.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/field_value.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Untyped Number alias we can use to check for ES6 methods / properties.\n// tslint:disable-next-line:no-any variable-name\nvar NumberAsAny = Number;\n/**\n * Minimum safe integer in Javascript because of floating point precision.\n * Added to not rely on ES6 features.\n */\nexport var MIN_SAFE_INTEGER = NumberAsAny.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);\n/**\n * Maximum safe integer in Javascript because of floating point precision.\n * Added to not rely on ES6 features.\n */\nexport var MAX_SAFE_INTEGER = NumberAsAny.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;\n/**\n * Returns whether an number is an integer, uses native implementation if\n * available.\n * Added to not rely on ES6 features.\n * @param value The value to test for being an integer\n */\nexport var isInteger = NumberAsAny.isInteger ||\n    (function (value) {\n        return typeof value === 'number' &&\n            isFinite(value) &&\n            Math.floor(value) === value;\n    });\n/**\n * Returns whether a variable is either undefined or null.\n */\nexport function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value The value to test for being an integer and in the safe range\n */\nexport function isSafeInteger(value) {\n    return (isInteger(value) &&\n        value <= MAX_SAFE_INTEGER &&\n        value >= MIN_SAFE_INTEGER);\n}\n/**\n * Safely checks if the number is NaN.\n */\nexport function safeIsNaN(value) {\n    if (NumberAsAny.IsNaN) {\n        return NumberAsAny.IsNaN(value);\n    }\n    else {\n        return typeof value === 'number' && isNaN(value);\n    }\n}\n\n//# sourceMappingURL=types.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/types.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DoubleValue, NullValue, RefValue } from '../model/field_value';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isNullOrUndefined } from '../util/types';\nvar Query = /** @class */ (function () {\n    function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {\n        if (explicitOrderBy === void 0) { explicitOrderBy = []; }\n        if (filters === void 0) { filters = []; }\n        if (limit === void 0) { limit = null; }\n        if (startAt === void 0) { startAt = null; }\n        if (endAt === void 0) { endAt = null; }\n        this.path = path;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n        this.memoizedOrderBy = null;\n        if (this.startAt) {\n            this.assertValidBound(this.startAt);\n        }\n        if (this.endAt) {\n            this.assertValidBound(this.endAt);\n        }\n    }\n    Query.atPath = function (path) {\n        return new Query(path);\n    };\n    Object.defineProperty(Query.prototype, \"orderBy\", {\n        get: function () {\n            if (this.memoizedOrderBy === null) {\n                var inequalityField = this.getInequalityFilterField();\n                var firstOrderByField = this.getFirstOrderByField();\n                if (inequalityField !== null && firstOrderByField === null) {\n                    // In order to implicitly add key ordering, we must also add the\n                    // inequality filter field for it to be a valid query.\n                    // Note that the default inequality field and key ordering is ascending.\n                    if (inequalityField.isKeyField()) {\n                        this.memoizedOrderBy = [KEY_ORDERING_ASC];\n                    }\n                    else {\n                        this.memoizedOrderBy = [\n                            new OrderBy(inequalityField),\n                            KEY_ORDERING_ASC\n                        ];\n                    }\n                }\n                else {\n                    assert(inequalityField === null ||\n                        (firstOrderByField !== null &&\n                            inequalityField.equals(firstOrderByField)), 'First orderBy should match inequality field.');\n                    this.memoizedOrderBy = [];\n                    var foundKeyOrdering = false;\n                    for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n                        var orderBy = _a[_i];\n                        this.memoizedOrderBy.push(orderBy);\n                        if (orderBy.field.isKeyField()) {\n                            foundKeyOrdering = true;\n                        }\n                    }\n                    if (!foundKeyOrdering) {\n                        // The order of the implicit key ordering always matches the last\n                        // explicit order by\n                        var lastDirection = this.explicitOrderBy.length > 0\n                            ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir\n                            : Direction.ASCENDING;\n                        this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING\n                            ? KEY_ORDERING_ASC\n                            : KEY_ORDERING_DESC);\n                    }\n                }\n            }\n            return this.memoizedOrderBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Query.prototype.addFilter = function (filter) {\n        assert(this.getInequalityFilterField() == null ||\n            !(filter instanceof RelationFilter) ||\n            !filter.isInequality() ||\n            filter.field.equals(this.getInequalityFilterField()), 'Query must only have one inequality field.');\n        assert(!DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');\n        var newFilters = this.filters.concat([filter]);\n        return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.addOrderBy = function (orderBy) {\n        assert(!DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');\n        assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');\n        // TODO(dimond): validate that orderBy does not list the same key twice.\n        var newOrderBy = this.explicitOrderBy.concat([orderBy]);\n        return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withLimit = function (limit) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withStartAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);\n    };\n    Query.prototype.withEndAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);\n    };\n    // TODO(b/29183165): This is used to get a unique string from a query to, for\n    // example, use as a dictionary key, but the implementation is subject to\n    // collisions. Make it collision-free.\n    Query.prototype.canonicalId = function () {\n        if (this.memoizedCanonicalId === null) {\n            var canonicalId = this.path.canonicalString();\n            canonicalId += '|f:';\n            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n                var filter = _a[_i];\n                canonicalId += filter.canonicalId();\n                canonicalId += ',';\n            }\n            canonicalId += '|ob:';\n            // TODO(dimond): make this collision resistant\n            for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {\n                var orderBy = _c[_b];\n                canonicalId += orderBy.canonicalId();\n                canonicalId += ',';\n            }\n            if (!isNullOrUndefined(this.limit)) {\n                canonicalId += '|l:';\n                canonicalId += this.limit;\n            }\n            if (this.startAt) {\n                canonicalId += '|lb:';\n                canonicalId += this.startAt.canonicalId();\n            }\n            if (this.endAt) {\n                canonicalId += '|ub:';\n                canonicalId += this.endAt.canonicalId();\n            }\n            this.memoizedCanonicalId = canonicalId;\n        }\n        return this.memoizedCanonicalId;\n    };\n    Query.prototype.toString = function () {\n        var str = 'Query(' + this.path.canonicalString();\n        if (this.filters.length > 0) {\n            str += \", filters: [\" + this.filters.join(', ') + \"]\";\n        }\n        if (!isNullOrUndefined(this.limit)) {\n            str += ', limit: ' + this.limit;\n        }\n        if (this.explicitOrderBy.length > 0) {\n            str += \", orderBy: [\" + this.explicitOrderBy.join(', ') + \"]\";\n        }\n        if (this.startAt) {\n            str += ', startAt: ' + this.startAt.canonicalId();\n        }\n        if (this.endAt) {\n            str += ', endAt: ' + this.endAt.canonicalId();\n        }\n        return str + ')';\n    };\n    Query.prototype.equals = function (other) {\n        if (this.limit !== other.limit) {\n            return false;\n        }\n        if (this.orderBy.length !== other.orderBy.length) {\n            return false;\n        }\n        for (var i = 0; i < this.orderBy.length; i++) {\n            if (!this.orderBy[i].equals(other.orderBy[i])) {\n                return false;\n            }\n        }\n        if (this.filters.length !== other.filters.length) {\n            return false;\n        }\n        for (var i = 0; i < this.filters.length; i++) {\n            if (!this.filters[i].equals(other.filters[i])) {\n                return false;\n            }\n        }\n        if (!this.path.equals(other.path)) {\n            return false;\n        }\n        if (this.startAt !== null\n            ? !this.startAt.equals(other.startAt)\n            : other.startAt !== null) {\n            return false;\n        }\n        return this.endAt !== null\n            ? this.endAt.equals(other.endAt)\n            : other.endAt === null;\n    };\n    Query.prototype.docComparator = function (d1, d2) {\n        var comparedOnKeyField = false;\n        for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            var comp = orderBy.compare(d1, d2);\n            if (comp !== 0)\n                return comp;\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        // Assert that we actually compared by key\n        assert(comparedOnKeyField, \"orderBy used that doesn't compare on key field\");\n        return 0;\n    };\n    Query.prototype.matches = function (doc) {\n        return (this.matchesAncestor(doc) &&\n            this.matchesOrderBy(doc) &&\n            this.matchesFilters(doc) &&\n            this.matchesBounds(doc));\n    };\n    Query.prototype.hasLimit = function () {\n        return !isNullOrUndefined(this.limit);\n    };\n    Query.prototype.getFirstOrderByField = function () {\n        return this.explicitOrderBy.length > 0\n            ? this.explicitOrderBy[0].field\n            : null;\n    };\n    Query.prototype.getInequalityFilterField = function () {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (filter instanceof RelationFilter && filter.isInequality()) {\n                return filter.field;\n            }\n        }\n        return null;\n    };\n    Query.prototype.isDocumentQuery = function () {\n        return DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;\n    };\n    Query.prototype.matchesAncestor = function (doc) {\n        var docPath = doc.key.path;\n        if (DocumentKey.isDocumentKey(this.path)) {\n            // exact match for document queries\n            return this.path.equals(docPath);\n        }\n        else {\n            // shallow ancestor queries by default\n            return (this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1);\n        }\n    };\n    /**\n     * A document must have a value for every ordering clause in order to show up\n     * in the results.\n     */\n    Query.prototype.matchesOrderBy = function (doc) {\n        for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            // order by key always matches\n            if (!orderBy.field.isKeyField() &&\n                doc.field(orderBy.field) === undefined) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Query.prototype.matchesFilters = function (doc) {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (!filter.matches(doc)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Makes sure a document is within the bounds, if provided.\n     */\n    Query.prototype.matchesBounds = function (doc) {\n        if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        return true;\n    };\n    Query.prototype.assertValidBound = function (bound) {\n        assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');\n    };\n    return Query;\n}());\nexport { Query };\nvar RelationOp = /** @class */ (function () {\n    function RelationOp(name) {\n        this.name = name;\n    }\n    RelationOp.fromString = function (op) {\n        switch (op) {\n            case '<':\n                return RelationOp.LESS_THAN;\n            case '<=':\n                return RelationOp.LESS_THAN_OR_EQUAL;\n            case '==':\n                return RelationOp.EQUAL;\n            case '>=':\n                return RelationOp.GREATER_THAN_OR_EQUAL;\n            case '>':\n                return RelationOp.GREATER_THAN;\n            default:\n                return fail('Unknown relation: ' + op);\n        }\n    };\n    RelationOp.prototype.toString = function () {\n        return this.name;\n    };\n    RelationOp.prototype.equals = function (other) {\n        return this.name === other.name;\n    };\n    RelationOp.LESS_THAN = new RelationOp('<');\n    RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');\n    RelationOp.EQUAL = new RelationOp('==');\n    RelationOp.GREATER_THAN = new RelationOp('>');\n    RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');\n    return RelationOp;\n}());\nexport { RelationOp };\nvar RelationFilter = /** @class */ (function () {\n    function RelationFilter(field, op, value) {\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    RelationFilter.prototype.matches = function (doc) {\n        if (this.field.isKeyField()) {\n            assert(this.value instanceof RefValue, 'Comparing on key, but filter value not a RefValue');\n            var refValue = this.value;\n            var comparison = DocumentKey.comparator(doc.key, refValue.key);\n            return this.matchesComparison(comparison);\n        }\n        else {\n            var val = doc.field(this.field);\n            return val !== undefined && this.matchesValue(val);\n        }\n    };\n    RelationFilter.prototype.matchesValue = function (value) {\n        // Only compare types with matching backend order (such as double and int).\n        if (this.value.typeOrder !== value.typeOrder) {\n            return false;\n        }\n        return this.matchesComparison(value.compareTo(this.value));\n    };\n    RelationFilter.prototype.matchesComparison = function (comparison) {\n        switch (this.op) {\n            case RelationOp.LESS_THAN:\n                return comparison < 0;\n            case RelationOp.LESS_THAN_OR_EQUAL:\n                return comparison <= 0;\n            case RelationOp.EQUAL:\n                return comparison === 0;\n            case RelationOp.GREATER_THAN:\n                return comparison > 0;\n            case RelationOp.GREATER_THAN_OR_EQUAL:\n                return comparison >= 0;\n            default:\n                return fail('Unknown relation op' + this.op);\n        }\n    };\n    RelationFilter.prototype.isInequality = function () {\n        return this.op !== RelationOp.EQUAL;\n    };\n    RelationFilter.prototype.canonicalId = function () {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (this.field.canonicalString() + this.op.toString() + this.value.toString());\n    };\n    RelationFilter.prototype.equals = function (other) {\n        if (other instanceof RelationFilter) {\n            return (this.op.equals(other.op) &&\n                this.field.equals(other.field) &&\n                this.value.equals(other.value));\n        }\n        else {\n            return false;\n        }\n    };\n    RelationFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n    };\n    return RelationFilter;\n}());\nexport { RelationFilter };\n/**\n * Filter that matches 'null' values.\n */\nvar NullFilter = /** @class */ (function () {\n    function NullFilter(field) {\n        this.field = field;\n    }\n    NullFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field);\n        return val !== undefined && val.value() === null;\n    };\n    NullFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS null';\n    };\n    NullFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS null\";\n    };\n    NullFilter.prototype.equals = function (other) {\n        if (other instanceof NullFilter) {\n            return this.field.equals(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NullFilter;\n}());\nexport { NullFilter };\n/**\n * Filter that matches 'NaN' values.\n */\nvar NanFilter = /** @class */ (function () {\n    function NanFilter(field) {\n        this.field = field;\n    }\n    NanFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field).value();\n        return typeof val === 'number' && isNaN(val);\n    };\n    NanFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS NaN';\n    };\n    NanFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS NaN\";\n    };\n    NanFilter.prototype.equals = function (other) {\n        if (other instanceof NanFilter) {\n            return this.field.equals(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NanFilter;\n}());\nexport { NanFilter };\n/**\n * Creates a filter based on the provided arguments.\n */\nexport function fieldFilter(field, op, value) {\n    if (value.equals(NullValue.INSTANCE)) {\n        if (op !== RelationOp.EQUAL) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on null.');\n        }\n        return new NullFilter(field);\n    }\n    else if (value.equals(DoubleValue.NAN)) {\n        if (op !== RelationOp.EQUAL) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on NaN.');\n        }\n        return new NanFilter(field);\n    }\n    else {\n        return new RelationFilter(field, op, value);\n    }\n}\n/**\n * The direction of sorting in an order by.\n */\nvar Direction = /** @class */ (function () {\n    function Direction(name) {\n        this.name = name;\n    }\n    Direction.prototype.toString = function () {\n        return this.name;\n    };\n    Direction.ASCENDING = new Direction('asc');\n    Direction.DESCENDING = new Direction('desc');\n    return Direction;\n}());\nexport { Direction };\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nvar Bound = /** @class */ (function () {\n    function Bound(position, before) {\n        this.position = position;\n        this.before = before;\n    }\n    Bound.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        var canonicalId = this.before ? 'b:' : 'a:';\n        for (var _i = 0, _a = this.position; _i < _a.length; _i++) {\n            var component = _a[_i];\n            canonicalId += component.toString();\n        }\n        return canonicalId;\n    };\n    /**\n     * Returns true if a document sorts before a bound using the provided sort\n     * order.\n     */\n    Bound.prototype.sortsBeforeDocument = function (orderBy, doc) {\n        assert(this.position.length <= orderBy.length, \"Bound has more components than query's orderBy\");\n        var comparison = 0;\n        for (var i = 0; i < this.position.length; i++) {\n            var orderByComponent = orderBy[i];\n            var component = this.position[i];\n            if (orderByComponent.field.isKeyField()) {\n                assert(component instanceof RefValue, 'Bound has a non-key value where the key path is being used.');\n                comparison = DocumentKey.comparator(component.key, doc.key);\n            }\n            else {\n                var docValue = doc.field(orderByComponent.field);\n                assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');\n                comparison = component.compareTo(docValue);\n            }\n            if (orderByComponent.dir === Direction.DESCENDING) {\n                comparison = comparison * -1;\n            }\n            if (comparison !== 0) {\n                break;\n            }\n        }\n        return this.before ? comparison <= 0 : comparison < 0;\n    };\n    Bound.prototype.equals = function (other) {\n        if (other === null) {\n            return false;\n        }\n        if (this.before !== other.before ||\n            this.position.length !== other.position.length) {\n            return false;\n        }\n        for (var i = 0; i < this.position.length; i++) {\n            var thisPosition = this.position[i];\n            var otherPosition = other.position[i];\n            return thisPosition.equals(otherPosition);\n        }\n        return true;\n    };\n    return Bound;\n}());\nexport { Bound };\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nvar OrderBy = /** @class */ (function () {\n    function OrderBy(field, dir) {\n        this.field = field;\n        if (dir === undefined) {\n            dir = Direction.ASCENDING;\n        }\n        this.dir = dir;\n        this.isKeyOrderBy = field.isKeyField();\n    }\n    OrderBy.prototype.compare = function (d1, d2) {\n        var comparison = this.isKeyOrderBy\n            ? Document.compareByKey(d1, d2)\n            : Document.compareByField(this.field, d1, d2);\n        switch (this.dir) {\n            case Direction.ASCENDING:\n                return comparison;\n            case Direction.DESCENDING:\n                return -1 * comparison;\n            default:\n                return fail('Unknown direction: ' + this.dir);\n        }\n    };\n    OrderBy.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        return this.field.canonicalString() + this.dir.toString();\n    };\n    OrderBy.prototype.toString = function () {\n        return this.field.canonicalString() + \" (\" + this.dir + \")\";\n    };\n    OrderBy.prototype.equals = function (other) {\n        return this.dir === other.dir && this.field.equals(other.field);\n    };\n    return OrderBy;\n}());\nexport { OrderBy };\nvar KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);\nvar KEY_ORDERING_DESC = new OrderBy(FieldPath.keyField(), Direction.DESCENDING);\n\n//# sourceMappingURL=query.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/query.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\nimport { Code } from '../util/error';\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\nexport function isPermanentError(code) {\n    switch (code) {\n        case Code.OK:\n            return fail('Treated status OK as error');\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        // TODO(b/37325376): Give up after second unauthenticated error.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependant on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.\n *\n * @returns The Code equivalent to the given status string or undefined if\n *     there is no match.\n */\nexport function mapCodeFromRpcStatus(status) {\n    // tslint:disable-next-line:no-any lookup by string\n    var code = RpcCode[status];\n    if (code === undefined) {\n        return undefined;\n    }\n    return mapCodeFromRpcCode(code);\n}\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nexport function mapCodeFromRpcCode(code) {\n    switch (code) {\n        case RpcCode.OK:\n            return Code.OK;\n        case RpcCode.CANCELLED:\n            return Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return Code.DATA_LOSS;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Maps an RPC code from a Code. This is the reverse operation from\n * mapCodeFromRpcCode and should really only be used in tests.\n */\nexport function mapRpcCodeFromCode(code) {\n    if (code === undefined) {\n        return RpcCode.OK;\n    }\n    switch (code) {\n        case Code.OK:\n            return RpcCode.OK;\n        case Code.CANCELLED:\n            return RpcCode.CANCELLED;\n        case Code.UNKNOWN:\n            return RpcCode.UNKNOWN;\n        case Code.DEADLINE_EXCEEDED:\n            return RpcCode.DEADLINE_EXCEEDED;\n        case Code.RESOURCE_EXHAUSTED:\n            return RpcCode.RESOURCE_EXHAUSTED;\n        case Code.INTERNAL:\n            return RpcCode.INTERNAL;\n        case Code.UNAVAILABLE:\n            return RpcCode.UNAVAILABLE;\n        case Code.UNAUTHENTICATED:\n            return RpcCode.UNAUTHENTICATED;\n        case Code.INVALID_ARGUMENT:\n            return RpcCode.INVALID_ARGUMENT;\n        case Code.NOT_FOUND:\n            return RpcCode.NOT_FOUND;\n        case Code.ALREADY_EXISTS:\n            return RpcCode.ALREADY_EXISTS;\n        case Code.PERMISSION_DENIED:\n            return RpcCode.PERMISSION_DENIED;\n        case Code.FAILED_PRECONDITION:\n            return RpcCode.FAILED_PRECONDITION;\n        case Code.ABORTED:\n            return RpcCode.ABORTED;\n        case Code.OUT_OF_RANGE:\n            return RpcCode.OUT_OF_RANGE;\n        case Code.UNIMPLEMENTED:\n            return RpcCode.UNIMPLEMENTED;\n        case Code.DATA_LOSS:\n            return RpcCode.DATA_LOSS;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Converts an HTTP Status Code to the equivalent error code.\n *\n * @param status An HTTP Status Code, like 200, 404, 503, etc.\n * @returns The equivalent Code. Unknown status codes are mapped to\n *     Code.UNKNOWN.\n */\nexport function mapCodeFromHttpStatus(status) {\n    // The canonical error codes for Google APIs [1] specify mapping onto HTTP\n    // status codes but the mapping is not bijective. In each case of ambiguity\n    // this function chooses a primary error.\n    //\n    // [1]\n    // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n    switch (status) {\n        case 200:// OK\n            return Code.OK;\n        case 400:// Bad Request\n            return Code.INVALID_ARGUMENT;\n        // Other possibilities based on the forward mapping\n        // return Code.FAILED_PRECONDITION;\n        // return Code.OUT_OF_RANGE;\n        case 401:// Unauthorized\n            return Code.UNAUTHENTICATED;\n        case 403:// Forbidden\n            return Code.PERMISSION_DENIED;\n        case 404:// Not Found\n            return Code.NOT_FOUND;\n        case 409:// Conflict\n            return Code.ABORTED;\n        // Other possibilities:\n        // return Code.ALREADY_EXISTS;\n        case 416:// Range Not Satisfiable\n            return Code.OUT_OF_RANGE;\n        case 429:// Too Many Requests\n            return Code.RESOURCE_EXHAUSTED;\n        case 499:// Client Closed Request\n            return Code.CANCELLED;\n        case 500:// Internal Server Error\n            return Code.UNKNOWN;\n        // Other possibilities:\n        // return Code.INTERNAL;\n        // return Code.DATA_LOSS;\n        case 501:// Unimplemented\n            return Code.UNIMPLEMENTED;\n        case 503:// Service Unavailable\n            return Code.UNAVAILABLE;\n        case 504:// Gateway Timeout\n            return Code.DEADLINE_EXCEEDED;\n        default:\n            if (status >= 200 && status < 300)\n                return Code.OK;\n            if (status >= 400 && status < 500)\n                return Code.FAILED_PRECONDITION;\n            if (status >= 500 && status < 600)\n                return Code.INTERNAL;\n            return Code.UNKNOWN;\n    }\n}\n\n//# sourceMappingURL=rpc_error.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/rpc_error.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SortedMap } from '../util/sorted_map';\nimport { SortedSet } from '../util/sorted_set';\nimport { DocumentKey } from './document_key';\nvar EMPTY_MAYBE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nexport function maybeDocumentMap() {\n    return EMPTY_MAYBE_DOCUMENT_MAP;\n}\nvar EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nexport function documentMap() {\n    return EMPTY_DOCUMENT_MAP;\n}\nvar EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\nexport function documentVersionMap() {\n    return EMPTY_DOCUMENT_VERSION_MAP;\n}\nvar EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\nexport function documentKeySet() {\n    return EMPTY_DOCUMENT_KEY_SET;\n}\n\n//# sourceMappingURL=collections.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/collections.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { emptyByteString } from '../platform/platform';\nimport { assert, fail } from '../util/assert';\nimport * as objUtils from '../util/obj';\nimport { CurrentStatusUpdate, RemoteEvent, ResetMapping, UpdateMapping } from './remote_event';\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nvar DocumentWatchChange = /** @class */ (function () {\n    function DocumentWatchChange(\n        /** The new document applies to all of these targets. */\n        updatedTargetIds, \n        /** The new document is removed from all of these targets. */\n        removedTargetIds, \n        /** The key of the document for this change. */\n        key, \n        /**\n           * The new document or NoDocument if it was deleted. Is null if the\n           * document went out of view without the server sending a new document.\n           */\n        newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n    return DocumentWatchChange;\n}());\nexport { DocumentWatchChange };\nvar ExistenceFilterChange = /** @class */ (function () {\n    function ExistenceFilterChange(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n    return ExistenceFilterChange;\n}());\nexport { ExistenceFilterChange };\nexport var WatchTargetChangeState;\n(function (WatchTargetChangeState) {\n    WatchTargetChangeState[WatchTargetChangeState[\"NoChange\"] = 0] = \"NoChange\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Added\"] = 1] = \"Added\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Removed\"] = 2] = \"Removed\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Current\"] = 3] = \"Current\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Reset\"] = 4] = \"Reset\";\n})(WatchTargetChangeState = WatchTargetChangeState || (WatchTargetChangeState = {}));\nvar WatchTargetChange = /** @class */ (function () {\n    function WatchTargetChange(\n        /** What kind of change occurred to the watch target. */\n        state, \n        /** The target IDs that were added/removed/set. */\n        targetIds, \n        /**\n           * An opaque, server-assigned token that allows watching a query to be\n           * resumed after disconnecting without retransmitting all the data that\n           * matches the query. The resume token essentially identifies a point in\n           * time from which the server should resume sending results.\n           */\n        resumeToken, \n        /** An RPC error indicating why the watch failed. */\n        cause) {\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        if (cause === void 0) { cause = null; }\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n    return WatchTargetChange;\n}());\nexport { WatchTargetChange };\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nvar WatchChangeAggregator = /** @class */ (function () {\n    function WatchChangeAggregator(snapshotVersion, listenTargets, pendingTargetResponses) {\n        this.snapshotVersion = snapshotVersion;\n        this.listenTargets = listenTargets;\n        /** The existence filter - if any - for the given target IDs. */\n        this.existenceFilters = {};\n        /** Keeps track of the current target mappings */\n        this.targetChanges = {};\n        /** Keeps track of document to update */\n        this.documentUpdates = maybeDocumentMap();\n        /** Whether this aggregator was frozen and can no longer be modified */\n        this.frozen = false;\n        this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n    }\n    /** Aggregates a watch change into the current state */\n    WatchChangeAggregator.prototype.add = function (watchChange) {\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        if (watchChange instanceof DocumentWatchChange) {\n            this.addDocumentChange(watchChange);\n        }\n        else if (watchChange instanceof WatchTargetChange) {\n            this.addTargetChange(watchChange);\n        }\n        else if (watchChange instanceof ExistenceFilterChange) {\n            this.addExistenceFilterChange(watchChange);\n        }\n        else {\n            fail('Unknown watch change: ' + watchChange);\n        }\n    };\n    /** Aggregates all provided watch changes to the current state in order */\n    WatchChangeAggregator.prototype.addChanges = function (watchChanges) {\n        var _this = this;\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        watchChanges.forEach(function (change) { return _this.add(change); });\n    };\n    /**\n     * Converts the current state into a remote event with the snapshot version\n     * provided via the constructor.\n     */\n    WatchChangeAggregator.prototype.createRemoteEvent = function () {\n        var _this = this;\n        var targetChanges = this.targetChanges;\n        // Remove all the non-active targets from the remote event.\n        objUtils.forEachNumber(this.targetChanges, function (targetId) {\n            if (!_this.isActiveTarget(targetId)) {\n                delete targetChanges[targetId];\n            }\n        });\n        // Mark this aggregator as frozen so no further modifications are made\n        this.frozen = true;\n        return new RemoteEvent(this.snapshotVersion, targetChanges, this.documentUpdates);\n    };\n    WatchChangeAggregator.prototype.ensureTargetChange = function (targetId) {\n        var change = this.targetChanges[targetId];\n        if (!change) {\n            // Create an UpdateMapping by default, since resets are always explicit.\n            change = {\n                currentStatusUpdate: CurrentStatusUpdate.None,\n                snapshotVersion: this.snapshotVersion,\n                mapping: new UpdateMapping(),\n                resumeToken: emptyByteString()\n            };\n            this.targetChanges[targetId] = change;\n        }\n        return change;\n    };\n    /**\n     * We need to wait for watch to ack targets before we process those events,\n     * so to know if a target is active, there must be no pending acks we're\n     * waiting for and it must be in the current list of targets that the client\n     * cares about.\n     *\n     * This method is visible for testing.\n     */\n    WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {\n        return (!objUtils.contains(this.pendingTargetResponses, targetId) &&\n            objUtils.contains(this.listenTargets, targetId));\n    };\n    WatchChangeAggregator.prototype.addDocumentChange = function (docChange) {\n        var relevant = false;\n        for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {\n            var targetId = _a[_i];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.add(docChange.key);\n                relevant = true;\n            }\n        }\n        for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {\n            var targetId = _c[_b];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.delete(docChange.key);\n                relevant = true;\n            }\n        }\n        // Only update the document if there is a new document to replace to an\n        // active target that is being listened to, this might be just a target\n        // update instead.\n        if (docChange.newDoc && relevant) {\n            this.documentUpdates = this.documentUpdates.insert(docChange.key, docChange.newDoc);\n        }\n    };\n    WatchChangeAggregator.prototype.addTargetChange = function (targetChange) {\n        var _this = this;\n        targetChange.targetIds.forEach(function (targetId) {\n            var change = _this.ensureTargetChange(targetId);\n            switch (targetChange.state) {\n                case WatchTargetChangeState.NoChange:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Creating the change above satisfies the semantics of no-change.\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Added:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    if (!objUtils.contains(_this.pendingTargetResponses, targetId)) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        change.mapping = new UpdateMapping();\n                        change.currentStatusUpdate = CurrentStatusUpdate.None;\n                        delete _this.existenceFilters[targetId];\n                    }\n                    applyResumeToken(change, targetChange.resumeToken);\n                    break;\n                case WatchTargetChangeState.Removed:\n                    // We need to keep track of removed targets to we can\n                    // post-filter and remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');\n                    break;\n                case WatchTargetChangeState.Current:\n                    if (_this.isActiveTarget(targetId)) {\n                        change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Reset:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Overwrite any existing target mapping with a reset\n                        // mapping. Every subsequent update will modify the reset\n                        // mapping, not an update mapping.\n                        change.mapping = new ResetMapping();\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail('Unknown target watch change state: ' + targetChange.state);\n            }\n        });\n    };\n    /**\n     * Record that we get a watch target add/remove by decrementing the number of\n     * pending target responses that we have.\n     */\n    WatchChangeAggregator.prototype.recordTargetResponse = function (targetId) {\n        var newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n        if (newCount === 0) {\n            delete this.pendingTargetResponses[targetId];\n        }\n        else {\n            this.pendingTargetResponses[targetId] = newCount;\n        }\n    };\n    WatchChangeAggregator.prototype.addExistenceFilterChange = function (change) {\n        if (this.isActiveTarget(change.targetId)) {\n            this.existenceFilters[change.targetId] = change.existenceFilter;\n        }\n    };\n    return WatchChangeAggregator;\n}());\nexport { WatchChangeAggregator };\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(change, resumeToken) {\n    if (resumeToken.length > 0) {\n        change.resumeToken = resumeToken;\n    }\n}\n\n//# sourceMappingURL=watch_change.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/watch_change.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Blob } from '../api/blob';\nimport { GeoPoint } from '../api/geo_point';\nimport { DatabaseId } from '../core/database_info';\nimport { Bound, Direction, NanFilter, NullFilter, OrderBy, Query, RelationFilter, RelationOp } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { QueryPurpose } from '../local/query_data';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport * as fieldValue from '../model/field_value';\nimport { DeleteMutation, FieldMask, FieldTransform, MutationResult, PatchMutation, Precondition, ServerTimestampTransform, SetMutation, TransformMutation } from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as obj from '../util/obj';\nimport * as typeUtils from '../util/types';\nimport { ExistenceFilter } from './existence_filter';\nimport { mapCodeFromRpcCode, mapRpcCodeFromCode } from './rpc_error';\nimport { DocumentWatchChange, ExistenceFilterChange, WatchTargetChange, WatchTargetChangeState } from './watch_change';\nvar DIRECTIONS = (function () {\n    var dirs = {};\n    dirs[Direction.ASCENDING.name] = 'ASCENDING';\n    dirs[Direction.DESCENDING.name] = 'DESCENDING';\n    return dirs;\n})();\nvar OPERATORS = (function () {\n    var ops = {};\n    ops[RelationOp.LESS_THAN.name] = 'LESS_THAN';\n    ops[RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';\n    ops[RelationOp.GREATER_THAN.name] = 'GREATER_THAN';\n    ops[RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';\n    ops[RelationOp.EQUAL.name] = 'EQUAL';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n    assert(!typeUtils.isNullOrUndefined(value), description + ' is missing');\n}\nfunction parseInt64(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return parseInt(value, 10);\n    }\n    else {\n        return fail(\"can't parse \" + value);\n    }\n}\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nvar JsonProtoSerializer = /** @class */ (function () {\n    function JsonProtoSerializer(databaseId, options) {\n        this.databaseId = databaseId;\n        this.options = options;\n    }\n    JsonProtoSerializer.prototype.emptyByteString = function () {\n        if (this.options.useProto3Json) {\n            return '';\n        }\n        else {\n            return new Uint8Array(0);\n        }\n    };\n    JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) {\n        // byteStrings can be either string or UInt8Array, but the typings say\n        // it's always a string. Cast as string to avoid type check failing\n        return byteString;\n    };\n    JsonProtoSerializer.prototype.fromRpcStatus = function (status) {\n        var code = status.code === undefined\n            ? Code.UNKNOWN\n            : mapCodeFromRpcCode(status.code);\n        return new FirestoreError(code, status.message || '');\n    };\n    /**\n     * Returns a value for a Date that's appropriate to put into a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say dates must be. But it's easier and safer\n     * to actually return a Timestamp proto.\n     */\n    JsonProtoSerializer.prototype.toTimestamp = function (timestamp) {\n        return {\n            seconds: timestamp.seconds,\n            nanos: timestamp.nanos\n            // tslint:disable-next-line:no-any\n        };\n    };\n    JsonProtoSerializer.prototype.fromTimestamp = function (date) {\n        // The json interface (for the browser) will return an iso timestamp string,\n        // while the proto js library (for node) will return a\n        // google.protobuf.Timestamp instance.\n        if (typeof date === 'string') {\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(this.options.useProto3Json,\n            //   'The timestamp string format requires Proto3.');\n            return Timestamp.fromISOString(date);\n        }\n        else {\n            assert(!!date, 'Cannot deserialize null or undefined timestamp.');\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(!this.options.useProto3Json,\n            //   'The timestamp instance format requires Proto JS.');\n            var seconds = parseInt64(date.seconds || '0');\n            var nanos = date.nanos || 0;\n            return new Timestamp(seconds, nanos);\n        }\n    };\n    /**\n     * Returns a value for bytes that's appropriate to put in a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say bytes must be. But it should return\n     * an Uint8Array in Node.\n     */\n    JsonProtoSerializer.prototype.toBytes = function (bytes) {\n        if (this.options.useProto3Json) {\n            return bytes.toBase64();\n        }\n        else {\n            // The typings say it's a string, but it needs to be a Uint8Array in Node.\n            return this.unsafeCastProtoByteString(bytes.toUint8Array());\n        }\n    };\n    /**\n     * Parse the blob from the protos into the internal Blob class. Note that the\n     * typings assume all blobs are strings, but they are actually Uint8Arrays\n     * on Node.\n     */\n    JsonProtoSerializer.prototype.fromBlob = function (blob) {\n        if (typeof blob === 'string') {\n            assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');\n            return Blob.fromBase64String(blob);\n        }\n        else {\n            assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');\n            return Blob.fromUint8Array(blob);\n        }\n    };\n    JsonProtoSerializer.prototype.toVersion = function (version) {\n        return this.toTimestamp(version.toTimestamp());\n    };\n    JsonProtoSerializer.prototype.fromVersion = function (version) {\n        assert(!!version, \"Trying to deserialize version that isn't set\");\n        return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n    };\n    JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) {\n        return this.fullyQualifiedPrefixPath(databaseId)\n            .child('documents')\n            .child(path)\n            .canonicalString();\n    };\n    JsonProtoSerializer.prototype.fromResourceName = function (name) {\n        var resource = ResourcePath.fromString(name);\n        assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());\n        return resource;\n    };\n    JsonProtoSerializer.prototype.toName = function (key) {\n        return this.toResourceName(this.databaseId, key.path);\n    };\n    JsonProtoSerializer.prototype.fromName = function (name) {\n        var resource = this.fromResourceName(name);\n        assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            this.databaseId.projectId);\n        assert((!resource.get(3) && !this.databaseId.database) ||\n            resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            this.databaseId.database);\n        return new DocumentKey(this.extractLocalPathFromResourceName(resource));\n    };\n    JsonProtoSerializer.prototype.toQueryPath = function (path) {\n        if (path.length === 0) {\n            // If the path is empty, the backend requires we leave off the /documents\n            // at the end.\n            return this.encodedDatabaseId;\n        }\n        return this.toResourceName(this.databaseId, path);\n    };\n    JsonProtoSerializer.prototype.fromQueryPath = function (name) {\n        var resourceName = this.fromResourceName(name);\n        if (resourceName.length === 4) {\n            return ResourcePath.EMPTY_PATH;\n        }\n        return this.extractLocalPathFromResourceName(resourceName);\n    };\n    Object.defineProperty(JsonProtoSerializer.prototype, \"encodedDatabaseId\", {\n        get: function () {\n            var path = new ResourcePath([\n                'projects',\n                this.databaseId.projectId,\n                'databases',\n                this.databaseId.database\n            ]);\n            return path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) {\n        return new ResourcePath([\n            'projects',\n            databaseId.projectId,\n            'databases',\n            databaseId.database\n        ]);\n    };\n    JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) {\n        assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());\n        return resourceName.popFirst(5);\n    };\n    JsonProtoSerializer.prototype.isValidResourceName = function (path) {\n        // Resource names have at least 4 components (project ID, database ID)\n        return (path.length >= 4 &&\n            path.get(0) === 'projects' &&\n            path.get(2) === 'databases');\n    };\n    JsonProtoSerializer.prototype.toValue = function (val) {\n        if (val instanceof fieldValue.NullValue) {\n            return { nullValue: 'NULL_VALUE' };\n        }\n        else if (val instanceof fieldValue.BooleanValue) {\n            return { booleanValue: val.value() };\n        }\n        else if (val instanceof fieldValue.IntegerValue) {\n            return { integerValue: '' + val.value() };\n        }\n        else if (val instanceof fieldValue.DoubleValue) {\n            var doubleValue = val.value();\n            if (this.options.useProto3Json) {\n                // Proto 3 let's us encode NaN and Infinity as string values as\n                // expected by the backend. This is currently not checked by our unit\n                // tests because they rely on protobuf.js.\n                if (isNaN(doubleValue)) {\n                    return { doubleValue: 'NaN' };\n                }\n                else if (doubleValue === Infinity) {\n                    return { doubleValue: 'Infinity' };\n                }\n                else if (doubleValue === -Infinity) {\n                    return { doubleValue: '-Infinity' };\n                }\n            }\n            return { doubleValue: val.value() };\n        }\n        else if (val instanceof fieldValue.StringValue) {\n            return { stringValue: val.value() };\n        }\n        else if (val instanceof fieldValue.ObjectValue) {\n            return { mapValue: this.toMapValue(val) };\n        }\n        else if (val instanceof fieldValue.ArrayValue) {\n            return { arrayValue: this.toArrayValue(val) };\n        }\n        else if (val instanceof fieldValue.TimestampValue) {\n            return {\n                timestampValue: this.toTimestamp(val.internalValue)\n            };\n        }\n        else if (val instanceof fieldValue.GeoPointValue) {\n            return {\n                geoPointValue: {\n                    latitude: val.value().latitude,\n                    longitude: val.value().longitude\n                }\n            };\n        }\n        else if (val instanceof fieldValue.BlobValue) {\n            return {\n                bytesValue: this.toBytes(val.value())\n            };\n        }\n        else if (val instanceof fieldValue.RefValue) {\n            return {\n                referenceValue: this.toResourceName(val.databaseId, val.key.path)\n            };\n        }\n        else {\n            return fail('Unknown FieldValue ' + JSON.stringify(val));\n        }\n    };\n    JsonProtoSerializer.prototype.fromValue = function (obj) {\n        var _this = this;\n        // tslint:disable-next-line:no-any\n        var type = obj['value_type'];\n        if (hasTag(obj, type, 'nullValue')) {\n            return fieldValue.NullValue.INSTANCE;\n        }\n        else if (hasTag(obj, type, 'booleanValue')) {\n            return fieldValue.BooleanValue.of(obj.booleanValue);\n        }\n        else if (hasTag(obj, type, 'integerValue')) {\n            return new fieldValue.IntegerValue(parseInt64(obj.integerValue));\n        }\n        else if (hasTag(obj, type, 'doubleValue')) {\n            if (this.options.useProto3Json) {\n                // Proto 3 uses the string values 'NaN' and 'Infinity'.\n                if (obj.doubleValue === 'NaN') {\n                    return fieldValue.DoubleValue.NAN;\n                }\n                else if (obj.doubleValue === 'Infinity') {\n                    return fieldValue.DoubleValue.POSITIVE_INFINITY;\n                }\n                else if (obj.doubleValue === '-Infinity') {\n                    return fieldValue.DoubleValue.NEGATIVE_INFINITY;\n                }\n            }\n            return new fieldValue.DoubleValue(obj.doubleValue);\n        }\n        else if (hasTag(obj, type, 'stringValue')) {\n            return new fieldValue.StringValue(obj.stringValue);\n        }\n        else if (hasTag(obj, type, 'mapValue')) {\n            return this.fromFields(obj.mapValue.fields || {});\n        }\n        else if (hasTag(obj, type, 'arrayValue')) {\n            // \"values\" is not present if the array is empty\n            assertPresent(obj.arrayValue, 'arrayValue');\n            var values = obj.arrayValue.values || [];\n            return new fieldValue.ArrayValue(values.map(function (v) { return _this.fromValue(v); }));\n        }\n        else if (hasTag(obj, type, 'timestampValue')) {\n            assertPresent(obj.timestampValue, 'timestampValue');\n            return new fieldValue.TimestampValue(this.fromTimestamp(obj.timestampValue));\n        }\n        else if (hasTag(obj, type, 'geoPointValue')) {\n            assertPresent(obj.geoPointValue, 'geoPointValue');\n            var latitude = obj.geoPointValue.latitude || 0;\n            var longitude = obj.geoPointValue.longitude || 0;\n            return new fieldValue.GeoPointValue(new GeoPoint(latitude, longitude));\n        }\n        else if (hasTag(obj, type, 'bytesValue')) {\n            assertPresent(obj.bytesValue, 'bytesValue');\n            var blob = this.fromBlob(obj.bytesValue);\n            return new fieldValue.BlobValue(blob);\n        }\n        else if (hasTag(obj, type, 'referenceValue')) {\n            assertPresent(obj.referenceValue, 'referenceValue');\n            var resourceName = this.fromResourceName(obj.referenceValue);\n            var dbId = new DatabaseId(resourceName.get(1), resourceName.get(3));\n            var key = new DocumentKey(this.extractLocalPathFromResourceName(resourceName));\n            return new fieldValue.RefValue(dbId, key);\n        }\n        else {\n            return fail('Unknown Value proto ' + JSON.stringify(obj));\n        }\n    };\n    /** Creates an api.Document from key and fields (but no create/update time) */\n    JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) {\n        return {\n            name: this.toName(key),\n            fields: this.toFields(fields)\n        };\n    };\n    JsonProtoSerializer.prototype.toDocument = function (document) {\n        assert(!document.hasLocalMutations, \"Can't serialize documents with mutations.\");\n        return {\n            name: this.toName(document.key),\n            fields: this.toFields(document.data),\n            updateTime: this.toTimestamp(document.version.toTimestamp())\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocument = function (document) {\n        return new Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.toFields = function (fields) {\n        var _this = this;\n        var result = {};\n        fields.forEach(function (key, value) {\n            result[key] = _this.toValue(value);\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromFields = function (object) {\n        var _this = this;\n        // Proto map<string, Value> gets mapped to Object, so cast it.\n        var map = object;\n        var result = fieldValue.ObjectValue.EMPTY;\n        obj.forEach(map, function (key, value) {\n            result = result.set(new FieldPath([key]), _this.fromValue(value));\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.toMapValue = function (map) {\n        return {\n            fields: this.toFields(map)\n        };\n    };\n    JsonProtoSerializer.prototype.toArrayValue = function (array) {\n        var _this = this;\n        var result = [];\n        array.forEach(function (value) {\n            result.push(_this.toValue(value));\n        });\n        return { values: result };\n    };\n    JsonProtoSerializer.prototype.fromFound = function (doc) {\n        assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');\n        assertPresent(doc.found.name, 'doc.found.name');\n        assertPresent(doc.found.updateTime, 'doc.found.updateTime');\n        var key = this.fromName(doc.found.name);\n        var version = this.fromVersion(doc.found.updateTime);\n        var fields = this.fromFields(doc.found.fields || {});\n        return new Document(key, version, fields, { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.fromMissing = function (result) {\n        assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');\n        assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');\n        var key = this.fromName(result.missing);\n        var version = this.fromVersion(result.readTime);\n        return new NoDocument(key, version);\n    };\n    JsonProtoSerializer.prototype.fromMaybeDocument = function (result) {\n        // tslint:disable-next-line:no-any\n        var type = result['result_type'];\n        if (hasTag(result, type, 'found')) {\n            return this.fromFound(result);\n        }\n        else if (hasTag(result, type, 'missing')) {\n            return this.fromMissing(result);\n        }\n        return fail('invalid batch get response: ' + JSON.stringify(result));\n    };\n    JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) {\n        switch (state) {\n            case WatchTargetChangeState.Added:\n                return 'ADD';\n            case WatchTargetChangeState.Current:\n                return 'CURRENT';\n            case WatchTargetChangeState.NoChange:\n                return 'NO_CHANGE';\n            case WatchTargetChangeState.Removed:\n                return 'REMOVE';\n            case WatchTargetChangeState.Reset:\n                return 'RESET';\n            default:\n                return fail('Unknown WatchTargetChangeState: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) {\n        if (watchChange instanceof ExistenceFilterChange) {\n            return {\n                filter: {\n                    count: watchChange.existenceFilter.count,\n                    targetId: watchChange.targetId\n                }\n            };\n        }\n        if (watchChange instanceof DocumentWatchChange) {\n            if (watchChange.newDoc instanceof Document) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentChange: {\n                        document: {\n                            name: this.toName(doc.key),\n                            fields: this.toFields(doc.data),\n                            updateTime: this.toVersion(doc.version)\n                        },\n                        targetIds: watchChange.updatedTargetIds,\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc instanceof NoDocument) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentDelete: {\n                        document: this.toName(doc.key),\n                        readTime: this.toVersion(doc.version),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc === null) {\n                return {\n                    documentRemove: {\n                        document: this.toName(watchChange.key),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n        }\n        if (watchChange instanceof WatchTargetChange) {\n            var cause = undefined;\n            if (watchChange.cause) {\n                cause = {\n                    code: mapRpcCodeFromCode(watchChange.cause.code),\n                    message: watchChange.cause.message\n                };\n            }\n            return {\n                targetChange: {\n                    targetChangeType: this.toWatchTargetChangeState(watchChange.state),\n                    targetIds: watchChange.targetIds,\n                    resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),\n                    cause: cause\n                }\n            };\n        }\n        return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));\n    };\n    JsonProtoSerializer.prototype.fromWatchChange = function (change) {\n        // tslint:disable-next-line:no-any\n        var type = change['change_type'];\n        var watchChange;\n        if (hasTag(change, type, 'targetChange')) {\n            assertPresent(change.targetChange, 'targetChange');\n            // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n            // if unset\n            var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n            var targetIds = change.targetChange.targetIds || [];\n            var resumeToken = change.targetChange.resumeToken || this.emptyByteString();\n            var causeProto = change.targetChange.cause;\n            var cause = causeProto && this.fromRpcStatus(causeProto);\n            watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\n        }\n        else if (hasTag(change, type, 'documentChange')) {\n            assertPresent(change.documentChange, 'documentChange');\n            assertPresent(change.documentChange.document, 'documentChange.name');\n            assertPresent(change.documentChange.document.name, 'documentChange.document.name');\n            assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');\n            var entityChange = change.documentChange;\n            var key = this.fromName(entityChange.document.name);\n            var version = this.fromVersion(entityChange.document.updateTime);\n            var fields = this.fromFields(entityChange.document.fields || {});\n            var doc = new Document(key, version, fields, {\n                hasLocalMutations: false\n            });\n            var updatedTargetIds = entityChange.targetIds || [];\n            var removedTargetIds = entityChange.removedTargetIds || [];\n            watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentDelete')) {\n            assertPresent(change.documentDelete, 'documentDelete');\n            assertPresent(change.documentDelete.document, 'documentDelete.document');\n            var docDelete = change.documentDelete;\n            var key = this.fromName(docDelete.document);\n            var version = docDelete.readTime\n                ? this.fromVersion(docDelete.readTime)\n                : SnapshotVersion.forDeletedDoc();\n            var doc = new NoDocument(key, version);\n            var removedTargetIds = docDelete.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentRemove')) {\n            assertPresent(change.documentRemove, 'documentRemove');\n            assertPresent(change.documentRemove.document, 'documentRemove');\n            var docRemove = change.documentRemove;\n            var key = this.fromName(docRemove.document);\n            var removedTargetIds = docRemove.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n        }\n        else if (hasTag(change, type, 'filter')) {\n            // TODO(dimond): implement existence filter parsing with strategy.\n            assertPresent(change.filter, 'filter');\n            assertPresent(change.filter.targetId, 'filter.targetId');\n            var filter = change.filter;\n            var count = filter.count || 0;\n            var existenceFilter = new ExistenceFilter(count);\n            var targetId = filter.targetId;\n            watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n        }\n        else {\n            return fail('Unknown change type ' + JSON.stringify(change));\n        }\n        return watchChange;\n    };\n    JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) {\n        if (state === 'NO_CHANGE') {\n            return WatchTargetChangeState.NoChange;\n        }\n        else if (state === 'ADD') {\n            return WatchTargetChangeState.Added;\n        }\n        else if (state === 'REMOVE') {\n            return WatchTargetChangeState.Removed;\n        }\n        else if (state === 'CURRENT') {\n            return WatchTargetChangeState.Current;\n        }\n        else if (state === 'RESET') {\n            return WatchTargetChangeState.Reset;\n        }\n        else {\n            return fail('Got unexpected TargetChange.state: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.versionFromListenResponse = function (change) {\n        // We have only reached a consistent snapshot for the entire stream if there\n        // is a read_time set and it applies to all targets (i.e. the list of\n        // targets is empty). The backend is guaranteed to send such responses.\n        // tslint:disable-next-line:no-any\n        var type = change['response_type'];\n        if (!hasTag(change, type, 'targetChange')) {\n            return SnapshotVersion.MIN;\n        }\n        var targetChange = change.targetChange;\n        if (targetChange.targetIds && targetChange.targetIds.length) {\n            return SnapshotVersion.MIN;\n        }\n        if (!targetChange.readTime) {\n            return SnapshotVersion.MIN;\n        }\n        return this.fromVersion(targetChange.readTime);\n    };\n    JsonProtoSerializer.prototype.toMutation = function (mutation) {\n        var _this = this;\n        var result;\n        if (mutation instanceof SetMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.value)\n            };\n        }\n        else if (mutation instanceof DeleteMutation) {\n            result = { delete: this.toName(mutation.key) };\n        }\n        else if (mutation instanceof PatchMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.data),\n                updateMask: this.toDocumentMask(mutation.fieldMask)\n            };\n        }\n        else if (mutation instanceof TransformMutation) {\n            result = {\n                transform: {\n                    document: this.toName(mutation.key),\n                    fieldTransforms: mutation.fieldTransforms.map(function (transform) {\n                        return _this.toFieldTransform(transform);\n                    })\n                }\n            };\n        }\n        else {\n            return fail('Unknown mutation type ' + mutation.type);\n        }\n        if (!mutation.precondition.isNone) {\n            result.currentDocument = this.toPrecondition(mutation.precondition);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromMutation = function (proto) {\n        var _this = this;\n        var precondition = proto.currentDocument\n            ? this.fromPrecondition(proto.currentDocument)\n            : Precondition.NONE;\n        if (proto.update) {\n            assertPresent(proto.update.name, 'name');\n            var key = this.fromName(proto.update.name);\n            var value = this.fromFields(proto.update.fields || {});\n            if (proto.updateMask) {\n                var fieldMask = this.fromDocumentMask(proto.updateMask);\n                return new PatchMutation(key, value, fieldMask, precondition);\n            }\n            else {\n                return new SetMutation(key, value, precondition);\n            }\n        }\n        else if (proto.delete) {\n            var key = this.fromName(proto.delete);\n            return new DeleteMutation(key, precondition);\n        }\n        else if (proto.transform) {\n            var key = this.fromName(proto.transform.document);\n            var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) {\n                return _this.fromFieldTransform(transform);\n            });\n            assert(precondition.exists === true, 'Transforms only support precondition \"exists == true\"');\n            return new TransformMutation(key, fieldTransforms);\n        }\n        else {\n            return fail('unknown mutation proto: ' + JSON.stringify(proto));\n        }\n    };\n    JsonProtoSerializer.prototype.toPrecondition = function (precondition) {\n        assert(!precondition.isNone, \"Can't serialize an empty precondition\");\n        if (precondition.updateTime !== undefined) {\n            return {\n                updateTime: this.toVersion(precondition.updateTime)\n            };\n        }\n        else if (precondition.exists !== undefined) {\n            return { exists: precondition.exists };\n        }\n        else {\n            return fail('Unknown precondition');\n        }\n    };\n    JsonProtoSerializer.prototype.fromPrecondition = function (precondition) {\n        if (precondition.updateTime !== undefined) {\n            return Precondition.updateTime(this.fromVersion(precondition.updateTime));\n        }\n        else if (precondition.exists !== undefined) {\n            return Precondition.exists(precondition.exists);\n        }\n        else {\n            return Precondition.NONE;\n        }\n    };\n    JsonProtoSerializer.prototype.fromWriteResult = function (proto) {\n        var _this = this;\n        // NOTE: Deletes don't have an updateTime.\n        var version = proto.updateTime\n            ? this.fromVersion(proto.updateTime)\n            : null;\n        var transformResults = null;\n        if (proto.transformResults) {\n            transformResults = proto.transformResults.map(function (result) {\n                return _this.fromValue(result);\n            });\n        }\n        return new MutationResult(version, transformResults);\n    };\n    JsonProtoSerializer.prototype.fromWriteResults = function (protos) {\n        var _this = this;\n        return (protos || []).map(function (proto) { return _this.fromWriteResult(proto); });\n    };\n    JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) {\n        assert(fieldTransform.transform instanceof ServerTimestampTransform, 'Unknown transform: ' + fieldTransform.transform);\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    };\n    JsonProtoSerializer.prototype.fromFieldTransform = function (proto) {\n        assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown transform proto: ' + JSON.stringify(proto));\n        var fieldPath = FieldPath.fromServerFormat(proto.fieldPath);\n        return new FieldTransform(fieldPath, ServerTimestampTransform.instance);\n    };\n    JsonProtoSerializer.prototype.toDocumentsTarget = function (query) {\n        return { documents: [this.toQueryPath(query.path)] };\n    };\n    JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) {\n        var count = documentsTarget.documents.length;\n        assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);\n        var name = documentsTarget.documents[0];\n        return Query.atPath(this.fromQueryPath(name));\n    };\n    JsonProtoSerializer.prototype.toQueryTarget = function (query) {\n        // Dissect the path into parent, collectionId, and optional key filter.\n        var result = { structuredQuery: {} };\n        if (query.path.isEmpty()) {\n            result.parent = this.toQueryPath(ResourcePath.EMPTY_PATH);\n        }\n        else {\n            var path = query.path;\n            assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');\n            result.parent = this.toQueryPath(path.popLast());\n            result.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n        }\n        var where = this.toFilter(query.filters);\n        if (where) {\n            result.structuredQuery.where = where;\n        }\n        var orderBy = this.toOrder(query.orderBy);\n        if (orderBy) {\n            result.structuredQuery.orderBy = orderBy;\n        }\n        var limit = this.toLimit(query.limit);\n        if (limit !== undefined) {\n            result.structuredQuery.limit = limit;\n        }\n        if (query.startAt) {\n            result.structuredQuery.startAt = this.toCursor(query.startAt);\n        }\n        if (query.endAt) {\n            result.structuredQuery.endAt = this.toCursor(query.endAt);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromQueryTarget = function (target) {\n        var path = this.fromQueryPath(target.parent);\n        var query = target.structuredQuery;\n        var fromCount = query.from ? query.from.length : 0;\n        if (fromCount > 0) {\n            assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');\n            var from = query.from[0];\n            path = path.child(from.collectionId);\n        }\n        var filterBy = [];\n        if (query.where) {\n            filterBy = this.fromFilter(query.where);\n        }\n        var orderBy = [];\n        if (query.orderBy) {\n            orderBy = this.fromOrder(query.orderBy);\n        }\n        var limit = null;\n        if (query.limit) {\n            limit = query.limit;\n        }\n        var startAt = null;\n        if (query.startAt) {\n            startAt = this.fromCursor(query.startAt);\n        }\n        var endAt = null;\n        if (query.endAt) {\n            endAt = this.fromCursor(query.endAt);\n        }\n        return new Query(path, orderBy, filterBy, limit, startAt, endAt);\n    };\n    JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) {\n        var value = this.toLabel(queryData.purpose);\n        if (value == null) {\n            return null;\n        }\n        else {\n            return {\n                'goog-listen-tags': value\n            };\n        }\n    };\n    JsonProtoSerializer.prototype.toLabel = function (purpose) {\n        switch (purpose) {\n            case QueryPurpose.Listen:\n                return null;\n            case QueryPurpose.ExistenceFilterMismatch:\n                return 'existence-filter-mismatch';\n            case QueryPurpose.LimboResolution:\n                return 'limbo-document';\n            default:\n                return fail('Unrecognized query purpose: ' + purpose);\n        }\n    };\n    JsonProtoSerializer.prototype.toTarget = function (queryData) {\n        var result;\n        var query = queryData.query;\n        if (query.isDocumentQuery()) {\n            result = { documents: this.toDocumentsTarget(query) };\n        }\n        else {\n            result = { query: this.toQueryTarget(query) };\n        }\n        result.targetId = queryData.targetId;\n        if (queryData.resumeToken.length > 0) {\n            result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.toFilter = function (filters) {\n        var _this = this;\n        if (filters.length === 0)\n            return;\n        var protos = filters.map(function (filter) {\n            return filter instanceof RelationFilter\n                ? _this.toRelationFilter(filter)\n                : _this.toUnaryFilter(filter);\n        });\n        if (protos.length === 1) {\n            return protos[0];\n        }\n        return { compositeFilter: { op: 'AND', filters: protos } };\n    };\n    JsonProtoSerializer.prototype.fromFilter = function (filter) {\n        var _this = this;\n        if (!filter) {\n            return [];\n        }\n        else if (filter.unaryFilter !== undefined) {\n            return [this.fromUnaryFilter(filter)];\n        }\n        else if (filter.fieldFilter !== undefined) {\n            return [this.fromRelationFilter(filter)];\n        }\n        else if (filter.compositeFilter !== undefined) {\n            return filter.compositeFilter.filters\n                .map(function (f) { return _this.fromFilter(f); })\n                .reduce(function (accum, current) { return accum.concat(current); });\n        }\n        else {\n            return fail('Unknown filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.toOrder = function (orderBys) {\n        var _this = this;\n        if (orderBys.length === 0)\n            return;\n        return orderBys.map(function (order) { return _this.toPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.fromOrder = function (orderBys) {\n        var _this = this;\n        return orderBys.map(function (order) { return _this.fromPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.toLimit = function (limit) {\n        if (!typeUtils.isNullOrUndefined(limit)) {\n            return limit;\n        }\n        return;\n    };\n    JsonProtoSerializer.prototype.toCursor = function (cursor) {\n        var _this = this;\n        return {\n            before: cursor.before,\n            values: cursor.position.map(function (component) { return _this.toValue(component); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromCursor = function (cursor) {\n        var _this = this;\n        var before = !!cursor.before;\n        var position = cursor.values.map(function (component) { return _this.fromValue(component); });\n        return new Bound(position, before);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toDirection = function (dir) {\n        return DIRECTIONS[dir.name];\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.fromDirection = function (dir) {\n        switch (dir) {\n            case 'ASCENDING':\n                return Direction.ASCENDING;\n            case 'DESCENDING':\n                return Direction.DESCENDING;\n            default:\n                return undefined;\n        }\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toOperatorName = function (op) {\n        return OPERATORS[op.name];\n    };\n    JsonProtoSerializer.prototype.fromOperatorName = function (op) {\n        switch (op) {\n            case 'EQUAL':\n                return RelationOp.EQUAL;\n            case 'GREATER_THAN':\n                return RelationOp.GREATER_THAN;\n            case 'GREATER_THAN_OR_EQUAL':\n                return RelationOp.GREATER_THAN_OR_EQUAL;\n            case 'LESS_THAN':\n                return RelationOp.LESS_THAN;\n            case 'LESS_THAN_OR_EQUAL':\n                return RelationOp.LESS_THAN_OR_EQUAL;\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified relation');\n            default:\n                return fail('Unknown relation');\n        }\n    };\n    JsonProtoSerializer.prototype.toFieldPathReference = function (path) {\n        return { fieldPath: path.canonicalString() };\n    };\n    JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) {\n        return FieldPath.fromServerFormat(fieldReference.fieldPath);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) {\n        return {\n            field: this.toFieldPathReference(orderBy.field),\n            direction: this.toDirection(orderBy.dir)\n        };\n    };\n    JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) {\n        return new OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toRelationFilter = function (filter) {\n        if (filter instanceof RelationFilter) {\n            return {\n                fieldFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: this.toOperatorName(filter.op),\n                    value: this.toValue(filter.value)\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromRelationFilter = function (filter) {\n        return new RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toUnaryFilter = function (filter) {\n        if (filter instanceof NanFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (filter instanceof NullFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) {\n        switch (filter.unaryFilter.op) {\n            case 'IS_NAN':\n                var nanField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NanFilter(nanField);\n            case 'IS_NULL':\n                var nullField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NullFilter(nullField);\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified filter');\n            default:\n                return fail('Unknown filter');\n        }\n    };\n    JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) {\n        return {\n            fieldPaths: fieldMask.fields.map(function (field) { return field.canonicalString(); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocumentMask = function (proto) {\n        var paths = proto.fieldPaths || [];\n        var fields = paths.map(function (path) { return FieldPath.fromServerFormat(path); });\n        return new FieldMask(fields);\n    };\n    return JsonProtoSerializer;\n}());\nexport { JsonProtoSerializer };\n/**\n * Checks for a specific oneof tag in a protocol buffer message.\n *\n * This intentionally accommodates two distinct cases:\n *\n * 1) Messages containing a type tag: these are the format produced by GRPC in\n * return values. These may contain default-value mappings for all tags in the\n * oneof but the type tag specifies which one was actually set.\n *\n * 2) Messages that don't contain a type tag: these are the format required by\n * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would\n * choke claiming that the tags aren't fields in the Message.\n *\n * Allowing both formats here makes the serializer able to consume the outputs\n * it produces: for all messages it supports, fromX(toX(value)) == value.\n *\n * Note that case 2 suffers from ambiguity: if multiple tags are present\n * without a type tag then the callers are structured in such a way that the\n * first invocation will win. Since we only parse in this mode when parsing\n * the output of a serialize method this works, but it's not a general\n * solution.\n *\n * Unfortunately there is no general solution here because proto3 makes it\n * impossible to distinguish unset from explicitly set fields: both have the\n * default value for the type. Without the type tag but multiple value tags\n * it's possible to have default values for each tag in the oneof and not be\n * able to know which was actually in effect.\n */\nfunction hasTag(obj, type, tag) {\n    return type === tag || (!type && tag in obj);\n}\n\n//# sourceMappingURL=serializer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/serializer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { FieldPath as InternalFieldPath } from '../model/path';\nimport { Code, FirestoreError } from '../util/error';\nimport { validateArgType, validateNamedArrayAtLeastNumberOfElements } from '../util/input_validation';\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\n/**\n * A FieldPath refers to a field in a document. The path may consist of a single\n * field name (referring to a top-level field in the document), or a list of\n * field names (referring to a nested field in the document).\n */\nvar FieldPath = /** @class */ (function () {\n    /**\n     * Creates a FieldPath from the provided field names. If more than one field\n     * name is provided, the path will point to a nested field in a document.\n     *\n     * @param fieldNames A list of field names.\n     */\n    function FieldPath() {\n        var fieldNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fieldNames[_i] = arguments[_i];\n        }\n        validateNamedArrayAtLeastNumberOfElements('FieldPath', fieldNames, 'fieldNames', 1);\n        for (var i = 0; i < fieldNames.length; ++i) {\n            validateArgType('FieldPath', 'string', i, fieldNames[i]);\n            if (fieldNames[i].length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field name at argument $(i + 1). \" +\n                    'Field names must not be empty.');\n            }\n        }\n        this._internalPath = new InternalFieldPath(fieldNames);\n    }\n    FieldPath.documentId = function () {\n        return FieldPath._DOCUMENT_ID;\n    };\n    /**\n     * Internal Note: The backend doesn't technically support querying by\n     * document ID. Instead it queries by the entire document name (full path\n     * included), but in the cases we currently support documentId(), the net\n     * effect is the same.\n     */\n    FieldPath._DOCUMENT_ID = new FieldPath(InternalFieldPath.keyField().canonicalString());\n    return FieldPath;\n}());\nexport { FieldPath };\n/**\n * Matches any characters in a field path string that are reserved.\n */\nvar RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n/**\n * Parses a field path string into a FieldPath, treating dots as separators.\n */\nexport function fromDotSeparatedString(path) {\n    var found = path.search(RESERVED);\n    if (found >= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not contain \" +\n            \"'~', '*', '/', '[', or ']'\");\n    }\n    try {\n        return new (FieldPath.bind.apply(FieldPath, [void 0].concat(path.split('.'))))();\n    }\n    catch (e) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, \" +\n            \"begin with '.', end with '.', or contain '..'\");\n    }\n}\n\n//# sourceMappingURL=field_path.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/field_path.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentSet } from '../model/document_set';\nimport { CurrentStatusUpdate, ResetMapping, UpdateMapping } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport { ChangeType, DocumentChangeSet, SyncState } from './view_snapshot';\nvar AddedLimboDocument = /** @class */ (function () {\n    function AddedLimboDocument(key) {\n        this.key = key;\n    }\n    return AddedLimboDocument;\n}());\nexport { AddedLimboDocument };\nvar RemovedLimboDocument = /** @class */ (function () {\n    function RemovedLimboDocument(key) {\n        this.key = key;\n    }\n    return RemovedLimboDocument;\n}());\nexport { RemovedLimboDocument };\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nvar View = /** @class */ (function () {\n    function View(query, \n        /** Documents included in the remote target */\n        syncedDocuments) {\n        this.query = query;\n        this.syncedDocuments = syncedDocuments;\n        this.syncState = null;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.documentSet = new DocumentSet(query.docComparator.bind(query));\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges The doc changes to apply to this view.\n     * @param previousChanges If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @return a new set of docs, changes, and refill flag.\n     */\n    View.prototype.computeDocChanges = function (docChanges, previousChanges) {\n        var _this = this;\n        var changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new DocumentChangeSet();\n        var oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        var newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        var newDocumentSet = oldDocumentSet;\n        var needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        docChanges.inorderTraversal(function (key, newMaybeDoc) {\n            var oldDoc = oldDocumentSet.get(key);\n            var newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\n            if (newDoc) {\n                assert(key.equals(newDoc.key), 'Mismatching keys found in document changes: ' +\n                    key +\n                    ' != ' +\n                    newDoc.key);\n                newDoc = _this.query.matches(newDoc) ? newDoc : null;\n            }\n            if (newDoc) {\n                newDocumentSet = newDocumentSet.add(newDoc);\n                if (newDoc.hasLocalMutations) {\n                    newMutatedKeys = newMutatedKeys.add(key);\n                }\n                else {\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n            else {\n                newDocumentSet = newDocumentSet.delete(key);\n                newMutatedKeys = newMutatedKeys.delete(key);\n            }\n            // Calculate change\n            if (oldDoc && newDoc) {\n                var docsEqual = oldDoc.data.equals(newDoc.data);\n                if (!docsEqual ||\n                    oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {\n                    // only report a change if document actually changed\n                    if (docsEqual) {\n                        changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n                    }\n                    else {\n                        changeSet.track({ type: ChangeType.Modified, doc: newDoc });\n                    }\n                    if (lastDocInLimit &&\n                        _this.query.docComparator(newDoc, lastDocInLimit) > 0) {\n                        // This doc moved from inside the limit to after the limit.\n                        // That means there may be some doc in the local cache that's\n                        // actually less than this one.\n                        needsRefill = true;\n                    }\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: ChangeType.Added, doc: newDoc });\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n                if (lastDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n        });\n        if (this.query.hasLimit()) {\n            // TODO(klimt): Make DocumentSet size be constant time.\n            while (newDocumentSet.size > this.query.limit) {\n                var oldDoc = newDocumentSet.last();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n            }\n        }\n        assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');\n        return {\n            documentSet: newDocumentSet,\n            changeSet: changeSet,\n            needsRefill: needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    };\n    /**\n     * Updates the view with the given ViewDocumentChanges and updates limbo docs\n     * and sync state from the given (optional) target change.\n     * @param docChanges The set of changes to make to the view's docs.\n     * @param targetChange A target change to apply for computing limbo docs and\n     *        sync state.\n     * @return A new ViewChange with the given docs, changes, and sync state.\n     */\n    View.prototype.applyChanges = function (docChanges, targetChange) {\n        var _this = this;\n        assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n        var oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        var changes = docChanges.changeSet.getChanges();\n        changes.sort(function (c1, c2) {\n            return (compareChangeType(c1.type, c2.type) ||\n                _this.query.docComparator(c1.doc, c2.doc));\n        });\n        var limboChanges = this.applyTargetChange(targetChange);\n        var synced = this.limboDocuments.size === 0 && this.current;\n        var newSyncState = synced ? SyncState.Synced : SyncState.Local;\n        var syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges: limboChanges };\n        }\n        else {\n            return {\n                snapshot: {\n                    query: this.query,\n                    docs: docChanges.documentSet,\n                    oldDocs: oldDocs,\n                    docChanges: changes,\n                    fromCache: newSyncState === SyncState.Local,\n                    syncStateChanged: syncStateChanged,\n                    hasPendingWrites: !docChanges.mutatedKeys.isEmpty()\n                },\n                limboChanges: limboChanges\n            };\n        }\n    };\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    View.prototype.shouldBeInLimbo = function (key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this.syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    };\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    View.prototype.applyTargetChange = function (targetChange) {\n        var _this = this;\n        if (targetChange) {\n            var targetMapping = targetChange.mapping;\n            if (targetMapping instanceof ResetMapping) {\n                this.syncedDocuments = targetMapping.documents;\n            }\n            else if (targetMapping instanceof UpdateMapping) {\n                this.syncedDocuments = targetMapping.applyToKeySet(this.syncedDocuments);\n            }\n            switch (targetChange.currentStatusUpdate) {\n                case CurrentStatusUpdate.MarkCurrent:\n                    this.current = true;\n                    break;\n                case CurrentStatusUpdate.MarkNotCurrent:\n                    this.current = false;\n                    break;\n                case CurrentStatusUpdate.None:\n                    break;\n                default:\n                    fail('Unknown current status update: ' + targetChange.currentStatusUpdate);\n            }\n        }\n        // Recompute the set of limbo docs.\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        var oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        if (this.current) {\n            this.documentSet.forEach(function (doc) {\n                if (_this.shouldBeInLimbo(doc.key)) {\n                    _this.limboDocuments = _this.limboDocuments.add(doc.key);\n                }\n            });\n        }\n        // Diff the new limbo docs with the old limbo docs.\n        var changes = [];\n        oldLimboDocuments.forEach(function (key) {\n            if (!_this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(function (key) {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    };\n    return View;\n}());\nexport { View };\nfunction compareChangeType(c1, c2) {\n    var order = function (change) {\n        switch (change) {\n            case ChangeType.Added:\n                return 1;\n            case ChangeType.Modified:\n                return 2;\n            case ChangeType.Metadata:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case ChangeType.Removed:\n                return 0;\n            default:\n                return fail('Unknown ChangeType: ' + change);\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n//# sourceMappingURL=view.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/view.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nvar escapeChar = '\\u0001';\nvar encodedSeparatorChar = '\\u0001';\nvar encodedNul = '\\u0010';\nvar encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nexport function encode(path) {\n    var result = '';\n    for (var i = 0; i < path.length; i++) {\n        if (result.length > 0) {\n            result = encodeSeparator(result);\n        }\n        result = encodeSegment(path.get(i), result);\n    }\n    return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment, resultBuf) {\n    var result = resultBuf;\n    var length = segment.length;\n    for (var i = 0; i < length; i++) {\n        var c = segment.charAt(i);\n        switch (c) {\n            case '\\0':\n                result += escapeChar + encodedNul;\n                break;\n            case escapeChar:\n                result += escapeChar + encodedEscape;\n                break;\n            default:\n                result += c;\n        }\n    }\n    return result;\n}\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result) {\n    return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nexport function decode(path) {\n    // Event the empty path must encode as a path of at least length 2. A path\n    // with exactly 2 must be the empty path.\n    var length = path.length;\n    assert(length >= 2, 'Invalid path ' + path);\n    if (length === 2) {\n        assert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, 'Non-empty path ' + path + ' had length 2');\n        return ResourcePath.EMPTY_PATH;\n    }\n    // Escape characters cannot exist past the second-to-last position in the\n    // source value.\n    var lastReasonableEscapeIndex = length - 2;\n    var segments = [];\n    var segmentBuilder = '';\n    for (var start = 0; start < length;) {\n        // The last two characters of a valid encoded path must be a separator, so\n        // there must be an end to this segment.\n        var end = path.indexOf(escapeChar, start);\n        if (end < 0 || end > lastReasonableEscapeIndex) {\n            fail('Invalid encoded resource path: \"' + path + '\"');\n        }\n        var next = path.charAt(end + 1);\n        switch (next) {\n            case encodedSeparatorChar:\n                var currentPiece = path.substring(start, end);\n                var segment = void 0;\n                if (segmentBuilder.length === 0) {\n                    // Avoid copying for the common case of a segment that excludes \\0\n                    // and \\001\n                    segment = currentPiece;\n                }\n                else {\n                    segmentBuilder += currentPiece;\n                    segment = segmentBuilder;\n                    segmentBuilder = '';\n                }\n                segments.push(segment);\n                break;\n            case encodedNul:\n                segmentBuilder += path.substring(start, end);\n                segmentBuilder += '\\0';\n                break;\n            case encodedEscape:\n                // The escape character can be used in the output to encode itself.\n                segmentBuilder += path.substring(start, end + 1);\n                break;\n            default:\n                fail('Invalid encoded resource path: \"' + path + '\"');\n        }\n        start = end + 2;\n    }\n    return new ResourcePath(segments);\n}\n/**\n * Computes the prefix successor of the given path, computed by encode above.\n * A prefix successor is the first key that cannot be prefixed by the given\n * path. It's useful for defining the end of a prefix scan such that all keys\n * in the scan have the same prefix.\n *\n * Note that this is not a general prefix successor implementation, which is\n * tricky to get right with Strings, given that they encode down to UTF-8.\n * Instead this relies on the fact that all paths encoded by this class are\n * always terminated with a separator, and so a successor can always be\n * cheaply computed by incrementing the last character of the path.\n */\nexport function prefixSuccessor(path) {\n    var c = path.charCodeAt(path.length - 1);\n    // TODO(mcg): this really should be a general thing, but not worth it right\n    // now\n    assert(c === 1, 'successor may only operate on paths generated by encode');\n    return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);\n}\n\n//# sourceMappingURL=encoded_resource_path.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/encoded_resource_path.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { encode } from './encoded_resource_path';\nexport var SCHEMA_VERSION = 1;\n/** Performs database creation and (in the future) upgrades between versions. */\nexport function createOrUpgradeDb(db, oldVersion) {\n    assert(oldVersion === 0, 'Unexpected upgrade from version ' + oldVersion);\n    db.createObjectStore(DbMutationQueue.store, {\n        keyPath: DbMutationQueue.keyPath\n    });\n    // TODO(mikelehen): Get rid of \"as any\" if/when TypeScript fixes their\n    // types. https://github.com/Microsoft/TypeScript/issues/14322\n    db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbMutationBatch.store, { keyPath: DbMutationBatch.keyPath });\n    var targetDocumentsStore = db.createObjectStore(\n    // tslint:disable-next-line:no-any\n    DbTargetDocument.store, { keyPath: DbTargetDocument.keyPath });\n    targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });\n    var targetStore = db.createObjectStore(DbTarget.store, {\n        keyPath: DbTarget.keyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });\n    // NOTE: keys for these stores are specified explicitly rather than using a\n    // keyPath.\n    db.createObjectStore(DbDocumentMutation.store);\n    db.createObjectStore(DbRemoteDocument.store);\n    db.createObjectStore(DbOwner.store);\n    db.createObjectStore(DbTargetGlobal.store);\n}\n/**\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\n */\nvar DbTimestamp = /** @class */ (function () {\n    function DbTimestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n    }\n    return DbTimestamp;\n}());\nexport { DbTimestamp };\n/**\n * A singleton object to be stored in the 'owner' store in IndexedDb.\n *\n * A given database can be owned by a single tab at a given time. That tab\n * must validate that it is still the owner before every write operation and\n * should regularly write an updated timestamp to prevent other tabs from\n * \"stealing\" ownership of the db.\n */\nvar DbOwner = /** @class */ (function () {\n    function DbOwner(ownerId, leaseTimestampMs) {\n        this.ownerId = ownerId;\n        this.leaseTimestampMs = leaseTimestampMs;\n    }\n    /** Name of the IndexedDb object store. */\n    DbOwner.store = 'owner';\n    return DbOwner;\n}());\nexport { DbOwner };\n/**\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\n *\n * Each user gets a single queue of MutationBatches to apply to the server.\n * DbMutationQueue tracks the metadata about the queue.\n */\nvar DbMutationQueue = /** @class */ (function () {\n    function DbMutationQueue(\n        /**\n           * The normalized user ID to which this queue belongs.\n           */\n        userId, \n        /**\n           * An identifier for the highest numbered batch that has been acknowledged\n           * by the server. All MutationBatches in this queue with batchIds less\n           * than or equal to this value are considered to have been acknowledged by\n           * the server.\n           */\n        lastAcknowledgedBatchId, \n        /**\n           * A stream token that was previously sent by the server.\n           *\n           * See StreamingWriteRequest in datastore.proto for more details about\n           * usage.\n           *\n           * After sending this token, earlier tokens may not be used anymore so\n           * only a single stream token is retained.\n           */\n        lastStreamToken) {\n        this.userId = userId;\n        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;\n        this.lastStreamToken = lastStreamToken;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationQueue.store = 'mutationQueues';\n    /** Keys are automatically assigned via the userId property. */\n    DbMutationQueue.keyPath = 'userId';\n    return DbMutationQueue;\n}());\nexport { DbMutationQueue };\n/**\n * An object to be stored in the 'mutations' store in IndexedDb.\n *\n * Represents a batch of user-level mutations intended to be sent to the server\n * in a single write. Each user-level batch gets a separate DbMutationBatch\n * with a new batchId.\n */\nvar DbMutationBatch = /** @class */ (function () {\n    function DbMutationBatch(\n        /**\n           * The normalized user ID to which this batch belongs.\n           */\n        userId, \n        /**\n           * An identifier for this batch, allocated by the mutation queue in a\n           * monotonically increasing manner.\n           */\n        batchId, \n        /**\n           * The local write time of the batch, stored as milliseconds since the\n           * epoch.\n           */\n        localWriteTimeMs, \n        /**\n           * A list of mutations to apply. All mutations will be applied atomically.\n           *\n           * Mutations are serialized via JsonProtoSerializer.toMutation().\n           */\n        mutations) {\n        this.userId = userId;\n        this.batchId = batchId;\n        this.localWriteTimeMs = localWriteTimeMs;\n        this.mutations = mutations;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationBatch.store = 'mutations';\n    /** Keys are automatically assigned via the userId, batchId properties. */\n    DbMutationBatch.keyPath = ['userId', 'batchId'];\n    return DbMutationBatch;\n}());\nexport { DbMutationBatch };\n/**\n * An object to be stored in the 'documentMutations' store in IndexedDb.\n *\n * A manually maintained index of all the mutation batches that affect a given\n * document key. The rows in this table are references based on the contents of\n * DbMutationBatch.mutations.\n */\nvar DbDocumentMutation = /** @class */ (function () {\n    function DbDocumentMutation() {\n    }\n    /**\n     * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n     * over all of a user's document mutations.\n     */\n    DbDocumentMutation.prefixForUser = function (userId) {\n        return [userId];\n    };\n    /**\n     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n     * index to iterate over all at document mutations for a given path or lower.\n     */\n    DbDocumentMutation.prefixForPath = function (userId, path) {\n        return [userId, encode(path)];\n    };\n    /**\n     * Creates a full index key of [userId, encodedPath, batchId] for inserting\n     * and deleting into the DbDocumentMutations index.\n     */\n    DbDocumentMutation.key = function (userId, path, batchId) {\n        return [userId, encode(path), batchId];\n    };\n    DbDocumentMutation.store = 'documentMutations';\n    /**\n     * Because we store all the useful information for this store in the key,\n     * there is no useful information to store as the value. The raw (unencoded)\n     * path cannot be stored because IndexedDb doesn't store prototype\n     * information.\n     */\n    DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();\n    return DbDocumentMutation;\n}());\nexport { DbDocumentMutation };\n/**\n * Represents the known absence of a document at a particular version.\n * Stored in IndexedDb as part of a DbRemoteDocument object.\n */\nvar DbNoDocument = /** @class */ (function () {\n    function DbNoDocument(path, readTime) {\n        this.path = path;\n        this.readTime = readTime;\n    }\n    return DbNoDocument;\n}());\nexport { DbNoDocument };\n/**\n * An object to be stored in the 'remoteDocuments' store in IndexedDb. It\n * represents either a cached document (if it exists) or a cached \"no-document\"\n * (if it is known to not exist).\n *\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\n * be made more general if necessary.\n */\nvar DbRemoteDocument = /** @class */ (function () {\n    function DbRemoteDocument(\n        /**\n           * Set to an instance of a DbNoDocument if it is known that no document\n           * exists.\n           */\n        noDocument, \n        /**\n           * Set to an instance of a Document if there's a cached version of the\n           * document.\n           */\n        document) {\n        this.noDocument = noDocument;\n        this.document = document;\n    }\n    DbRemoteDocument.store = 'remoteDocuments';\n    return DbRemoteDocument;\n}());\nexport { DbRemoteDocument };\n/**\n * An object to be stored in the 'targets' store in IndexedDb.\n *\n * This is based on and should be kept in sync with the proto used in the iOS\n * client.\n *\n * Each query the client listens to against the server is tracked on disk so\n * that the query can be efficiently resumed on restart.\n */\nvar DbTarget = /** @class */ (function () {\n    function DbTarget(\n        /**\n           * An auto-generated sequential numeric identifier for the query.\n           *\n           * Queries are stored using their canonicalId as the key, but these\n           * canonicalIds can be quite long so we additionally assign a unique\n           * queryId which can be used by referenced data structures (e.g.\n           * indexes) to minimize the on-disk cost.\n           */\n        targetId, \n        /**\n           * The canonical string representing this query. This is not unique.\n           */\n        canonicalId, \n        /**\n           * The last readTime received from the Watch Service for this query.\n           *\n           * This is the same value as TargetChange.read_time in the protos.\n           */\n        readTime, \n        /**\n           * An opaque, server-assigned token that allows watching a query to be\n           * resumed after disconnecting without retransmitting all the data\n           * that matches the query. The resume token essentially identifies a\n           * point in time from which the server should resume sending results.\n           *\n           * This is related to the snapshotVersion in that the resumeToken\n           * effectively also encodes that value, but the resumeToken is opaque\n           * and sometimes encodes additional information.\n           *\n           * A consequence of this is that the resumeToken should be used when\n           * asking the server to reason about where this client is in the watch\n           * stream, but the client should use the snapshotVersion for its own\n           * purposes.\n           *\n           * This is the same value as TargetChange.resume_token in the protos.\n           */\n        resumeToken, \n        /**\n           * A sequence number representing the last time this query was\n           * listened to, used for garbage collection purposes.\n           *\n           * Conventionally this would be a timestamp value, but device-local\n           * clocks are unreliable and they must be able to create new listens\n           * even while disconnected. Instead this should be a monotonically\n           * increasing number that's incremented on each listen call.\n           *\n           * This is different from the queryId since the queryId is an\n           * immutable identifier assigned to the Query on first use while\n           * lastListenSequenceNumber is updated every time the query is\n           * listened to.\n           */\n        lastListenSequenceNumber, \n        /**\n           * The query for this target.\n           *\n           * Because canonical ids are not unique we must store the actual query. We\n           * use the proto to have an object we can persist without having to\n           * duplicate translation logic to and from a `Query` object.\n           */\n        query) {\n        this.targetId = targetId;\n        this.canonicalId = canonicalId;\n        this.readTime = readTime;\n        this.resumeToken = resumeToken;\n        this.lastListenSequenceNumber = lastListenSequenceNumber;\n        this.query = query;\n    }\n    DbTarget.store = 'targets';\n    /** Keys are automatically assigned via the targetId property. */\n    DbTarget.keyPath = 'targetId';\n    /** The name of the queryTargets index. */\n    DbTarget.queryTargetsIndexName = 'queryTargetsIndex';\n    /**\n     * The index of all canonicalIds to the targets that they match. This is not\n     * a unique mapping because canonicalId does not promise a unique name for all\n     * possible queries, so we append the targetId to make the mapping unique.\n     */\n    DbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];\n    return DbTarget;\n}());\nexport { DbTarget };\n/**\n * An object representing an association between a target and a document.\n * Stored in the targetDocument object store to store the documents tracked by a\n * particular target.\n */\nvar DbTargetDocument = /** @class */ (function () {\n    function DbTargetDocument(\n        /**\n           * The targetId identifying a target.\n           */\n        targetId, \n        /**\n           * The path to the document, as encoded in the key.\n           */\n        path) {\n        this.targetId = targetId;\n        this.path = path;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbTargetDocument.store = 'targetDocuments';\n    /** Keys are automatically assigned via the targetId, path properties. */\n    DbTargetDocument.keyPath = ['targetId', 'path'];\n    /** The index name for the reverse index. */\n    DbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';\n    /** We also need to create the reverse index for these properties. */\n    DbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];\n    return DbTargetDocument;\n}());\nexport { DbTargetDocument };\n/**\n * A record of global state tracked across all Targets, tracked separately\n * to avoid the need for extra indexes.\n *\n * This should be kept in-sync with the proto used in the iOS client.\n */\nvar DbTargetGlobal = /** @class */ (function () {\n    function DbTargetGlobal(\n        /**\n           * The highest numbered target id across all targets.\n           *\n           * See DbTarget.targetId.\n           */\n        highestTargetId, \n        /**\n           * The highest numbered lastListenSequenceNumber across all targets.\n           *\n           * See DbTarget.lastListenSequenceNumber.\n           */\n        highestListenSequenceNumber, \n        /**\n           * A global snapshot version representing the last consistent snapshot we\n           * received from the backend. This is monotonically increasing and any\n           * snapshots received from the backend prior to this version (e.g. for\n           * targets resumed with a resumeToken) should be suppressed (buffered)\n           * until the backend has caught up to this snapshot version again. This\n           * prevents our cache from ever going backwards in time.\n           */\n        lastRemoteSnapshotVersion) {\n        this.highestTargetId = highestTargetId;\n        this.highestListenSequenceNumber = highestListenSequenceNumber;\n        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n    }\n    /**\n     * The key string used for the single object that exists in the\n     * DbTargetGlobal store.\n     */\n    DbTargetGlobal.key = 'targetGlobalKey';\n    DbTargetGlobal.store = 'targetGlobal';\n    return DbTargetGlobal;\n}());\nexport { DbTargetGlobal };\n/**\n * The list of all IndexedDB stored used by the SDK. This is used when creating\n * transactions so that access across all stores is done atomically.\n */\nexport var ALL_STORES = [\n    DbMutationQueue.store,\n    DbMutationBatch.store,\n    DbDocumentMutation.store,\n    DbRemoteDocument.store,\n    DbTarget.store,\n    DbOwner.store,\n    DbTargetGlobal.store,\n    DbTargetDocument.store\n];\n\n//# sourceMappingURL=indexeddb_schema.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_schema.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { PersistencePromise } from './persistence_promise';\nvar LOG_TAG = 'SimpleDb';\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nvar SimpleDb = /** @class */ (function () {\n    function SimpleDb(db) {\n        this.db = db;\n    }\n    /** Opens the specified database, creating or upgrading it if necessary. */\n    SimpleDb.openOrCreate = function (name, version, runUpgrade) {\n        assert(SimpleDb.isAvailable(), 'IndexedDB not supported in current environment.');\n        debug(LOG_TAG, 'Opening database:', name);\n        return new PersistencePromise(function (resolve, reject) {\n            // TODO(mikelehen): Investigate browser compatibility.\n            // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n            // suggests IE9 and older WebKit browsers handle upgrade\n            // differently.\n            var request = window.indexedDB.open(name, version);\n            request.onsuccess = function (event) {\n                var db = event.target.result;\n                resolve(new SimpleDb(db));\n            };\n            request.onerror = function (event) {\n                reject(event.target.error);\n            };\n            request.onupgradeneeded = function (event) {\n                debug(LOG_TAG, 'Database \"' + name + '\" requires upgrade from version:', event.oldVersion);\n                // TODO(mikelehen): If/when we need to do an actual data\n                // migration, we'll want to wrap db in a SimpleDb and have the\n                // runUpgrade function return a PersistencePromise, since we'll\n                // likely need to do async reads and writes. For now we're\n                // cheating and just passing the raw IndexedDB in, since\n                // createObjectStore(), etc. are synchronous.\n                var db = event.target.result;\n                runUpgrade(db, event.oldVersion);\n            };\n        }).toPromise();\n    };\n    /** Deletes the specified database. */\n    SimpleDb.delete = function (name) {\n        debug(LOG_TAG, 'Removing database:', name);\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n    };\n    /** Returns true if IndexedDB is available in the current environment. */\n    SimpleDb.isAvailable = function () {\n        if (typeof window === 'undefined' || window.indexedDB == null) {\n            return false;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        var ua = window.navigator.userAgent;\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    SimpleDb.prototype.runTransaction = function (mode, objectStores, transactionFn) {\n        var transaction = new SimpleDbTransaction(this.db, mode, objectStores);\n        var transactionFnResult = transactionFn(transaction)\n            .catch(function (error) {\n            // Abort the transaction if there was an\n            // error.\n            transaction.abort();\n            return PersistencePromise.reject(error);\n        })\n            .toPromise();\n        // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n        // fire), but still return the original transactionFnResult back to the\n        // caller.\n        return transaction.completionPromise.then(function () { return transactionFnResult; });\n    };\n    SimpleDb.prototype.close = function () {\n        this.db.close();\n    };\n    return SimpleDb;\n}());\nexport { SimpleDb };\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nvar IterationController = /** @class */ (function () {\n    function IterationController(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    Object.defineProperty(IterationController.prototype, \"isDone\", {\n        get: function () {\n            return this.shouldStop;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"skipToKey\", {\n        get: function () {\n            return this.nextKey;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"cursor\", {\n        set: function (value) {\n            this.dbCursor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    IterationController.prototype.done = function () {\n        this.shouldStop = true;\n    };\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    IterationController.prototype.skip = function (key) {\n        this.nextKey = key;\n    };\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    IterationController.prototype.delete = function () {\n        return wrapRequest(this.dbCursor.delete());\n    };\n    return IterationController;\n}());\nexport { IterationController };\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nvar SimpleDbTransaction = /** @class */ (function () {\n    function SimpleDbTransaction(db, mode, objectStoresNames) {\n        var _this = this;\n        this.aborted = false;\n        this.transaction = db.transaction(objectStoresNames, mode);\n        this.completionPromise = new Promise(function (resolve, reject) {\n            // We consider aborting to be \"normal\" and just resolve the promise.\n            // May need to revisit if/when we actually need to abort transactions.\n            _this.transaction.onabort = _this.transaction.oncomplete = function (event) {\n                resolve();\n            };\n            _this.transaction.onerror = function (event) {\n                reject(event.target.error);\n            };\n        });\n    }\n    SimpleDbTransaction.prototype.abort = function () {\n        if (!this.aborted) {\n            debug(LOG_TAG, 'Aborting transaction.');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    };\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    SimpleDbTransaction.prototype.store = function (storeName) {\n        var store = this.transaction.objectStore(storeName);\n        assert(!!store, 'Object store not part of transaction: ' + storeName);\n        return new SimpleDbStore(store);\n    };\n    return SimpleDbTransaction;\n}());\nexport { SimpleDbTransaction };\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nvar SimpleDbStore = /** @class */ (function () {\n    function SimpleDbStore(store) {\n        this.store = store;\n    }\n    SimpleDbStore.prototype.put = function (keyOrValue, value) {\n        var request;\n        if (value !== undefined) {\n            debug(LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            debug(LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    };\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @return The object with the specified key or null if no object exists.\n     */\n    SimpleDbStore.prototype.get = function (key) {\n        var _this = this;\n        var request = this.store.get(key);\n        // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.\n        return wrapRequest(request).next(function (result) {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            debug(LOG_TAG, 'GET', _this.store.name, key, result);\n            return result;\n        });\n    };\n    SimpleDbStore.prototype.delete = function (key) {\n        debug(LOG_TAG, 'DELETE', this.store.name, key);\n        var request = this.store.delete(key);\n        return wrapRequest(request);\n    };\n    SimpleDbStore.prototype.loadAll = function (indexOrRange, range) {\n        var cursor = this.cursor(this.options(indexOrRange, range));\n        var results = [];\n        return this.iterateCursor(cursor, function (key, value) {\n            results.push(value);\n        }).next(function () {\n            return results;\n        });\n    };\n    SimpleDbStore.prototype.deleteAll = function (indexOrRange, range) {\n        debug(LOG_TAG, 'DELETE ALL', this.store.name);\n        var options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, function (key, value, control) {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    };\n    SimpleDbStore.prototype.iterate = function (optionsOrCallback, callback) {\n        var options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    };\n    SimpleDbStore.prototype.iterateCursor = function (cursorRequest, fn) {\n        var results = [];\n        return new PersistencePromise(function (resolve, reject) {\n            cursorRequest.onerror = function (event) {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                var controller = new IterationController(cursor);\n                var userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof PersistencePromise) {\n                    results.push(userResult);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(function () {\n            return PersistencePromise.waitFor(results);\n        });\n    };\n    SimpleDbStore.prototype.options = function (indexOrRange, range) {\n        var indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                assert(range === undefined, '3rd argument must not be defined if 2nd is a range.');\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range: range };\n    };\n    SimpleDbStore.prototype.cursor = function (options) {\n        var direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            var index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    };\n    return SimpleDbStore;\n}());\nexport { SimpleDbStore };\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new PersistencePromise(function (resolve, reject) {\n        request.onsuccess = function (event) {\n            var result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = function (event) {\n            reject(event.target.error);\n        };\n    });\n}\n\n//# sourceMappingURL=simple_db.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/simple_db.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { immediatePredecessor, primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbDocumentMutation, DbMutationBatch, DbMutationQueue } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\n/** A mutation queue for a specific user, backed by IndexedDB. */\nvar IndexedDbMutationQueue = /** @class */ (function () {\n    function IndexedDbMutationQueue(\n        /**\n           * The normalized userId (e.g. null UID => \"\" userId) used to store /\n           * retrieve mutations.\n           */\n        userId, serializer) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.garbageCollector = null;\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user The user for which to create a mutation queue.\n     * @param serializer The serializer to use when persisting to IndexedDb.\n     */\n    IndexedDbMutationQueue.forUser = function (user, serializer) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        assert(user.uid !== '', 'UserID must not be an empty string.');\n        var userId = user.isUnauthenticated() ? '' : user.uid;\n        return new IndexedDbMutationQueue(userId, serializer);\n    };\n    IndexedDbMutationQueue.prototype.start = function (transaction) {\n        var _this = this;\n        return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction)\n            .next(function (nextBatchId) {\n            _this.nextBatchId = nextBatchId;\n            return mutationQueuesStore(transaction).get(_this.userId);\n        })\n            .next(function (metadata) {\n            if (!metadata) {\n                metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, \n                /*lastStreamToken=*/ '');\n            }\n            _this.metadata = metadata;\n            // On restart, nextBatchId may end up lower than\n            // lastAcknowledgedBatchId since it's computed from the queue\n            // contents, and there may be no mutations in the queue. In this\n            // case, we need to reset lastAcknowledgedBatchId (which is safe\n            // since the queue must be empty).\n            if (_this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId) {\n                return _this.checkEmpty(transaction).next(function (empty) {\n                    assert(empty, 'Reset nextBatchID is only possible when the queue is empty');\n                    _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n                    return mutationQueuesStore(transaction).put(_this.metadata);\n                });\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns one larger than the largest batch ID that has been stored. If there\n     * are no mutations returns 0. Note that batch IDs are global.\n     */\n    IndexedDbMutationQueue.loadNextBatchIdFromDb = function (txn) {\n        var maxBatchId = BATCHID_UNKNOWN;\n        return mutationsStore(txn)\n            .iterate({ reverse: true }, function (key, batch, control) {\n            var userId = key[0], batchId = key[1];\n            if (batchId > maxBatchId) {\n                maxBatchId = batch.batchId;\n            }\n            if (userId === '') {\n                // We can't compute a predecessor for the empty string, since it\n                // is lexographically first. That also means that no other\n                // userIds can come before this one, so we can just exit early.\n                control.done();\n            }\n            else {\n                var nextUser = immediatePredecessor(userId);\n                control.skip([nextUser]);\n            }\n        })\n            .next(function () { return maxBatchId + 1; });\n    };\n    IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {\n        var empty = true;\n        var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, value, control) {\n            empty = false;\n            control.done();\n        })\n            .next(function () { return empty; });\n    };\n    IndexedDbMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.nextBatchId);\n    };\n    IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n    };\n    IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        this.metadata.lastAcknowledgedBatchId = batchId;\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return PersistencePromise.resolve(this.metadata.lastStreamToken);\n    };\n    IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        var _this = this;\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        var batch = new MutationBatch(batchId, localWriteTime, mutations);\n        var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n        return mutationsStore(transaction)\n            .put(dbBatch)\n            .next(function () {\n            var promises = [];\n            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n                var mutation = mutations_1[_i];\n                var encodedPath = EncodedResourcePath.encode(mutation.key.path);\n                var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);\n                documentMutationsStore(transaction).put(indexKey, DbDocumentMutation.PLACEHOLDER);\n            }\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            return batch;\n        });\n    };\n    IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        var _this = this;\n        return mutationsStore(transaction)\n            .get(this.keyForBatchId(batchId))\n            .next(function (dbBatch) {\n            return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;\n        });\n    };\n    IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var _this = this;\n        var range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));\n        var foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, dbBatch, control) {\n            if (dbBatch.userId === _this.userId) {\n                assert(dbBatch.batchId > batchId, 'Should have found mutation after ' + batchId);\n                foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);\n            }\n            control.done();\n        })\n            .next(function () { return foundBatch; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        var results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            var path = EncodedResourcePath.decode(encodedPath);\n            if (userID !== _this.userId || !documentKey.path.equals(path)) {\n                control.done();\n                return;\n            }\n            var mutationKey = _this.keyForBatchId(batchID);\n            // Look up the mutation batch in the store.\n            // PORTING NOTE: because iteration is callback driven in the web,\n            // we just look up the key instead of keeping an open iterator\n            // like iOS.\n            return mutationsStore(transaction)\n                .get(mutationKey)\n                .next(function (dbBatch) {\n                if (dbBatch === null) {\n                    fail('Dangling document-mutation reference found: ' +\n                        indexKey +\n                        ' which points to ' +\n                        mutationKey);\n                }\n                results.push(_this.serializer.fromDbMutationBatch(dbBatch));\n            });\n        })\n            .next(function () { return results; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        assert(!query.isDocumentQuery(), \"Document queries shouldn't go down this path\");\n        var queryPath = query.path;\n        var immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);\n        var encodedQueryPath = indexPrefix[1];\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        var uniqueBatchIDs = new SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            var path = EncodedResourcePath.decode(encodedPath);\n            if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(function () {\n            var results = [];\n            var promises = [];\n            // TODO(rockwood): Implement this using iterate.\n            uniqueBatchIDs.forEach(function (batchID) {\n                var mutationKey = _this.keyForBatchId(batchID);\n                promises.push(mutationsStore(transaction)\n                    .get(mutationKey)\n                    .next(function (mutation) {\n                    if (mutation === null) {\n                        fail('Dangling document-mutation reference found, ' +\n                            'which points to ' +\n                            mutationKey);\n                    }\n                    results.push(_this.serializer.fromDbMutationBatch(mutation));\n                }));\n            });\n            return PersistencePromise.waitFor(promises).next(function () { return results; });\n        });\n    };\n    IndexedDbMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var txn = mutationsStore(transaction);\n        var indexTxn = documentMutationsStore(transaction);\n        var promises = [];\n        var _loop_1 = function (batch) {\n            var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));\n            var numDeleted = 0;\n            var removePromise = txn.iterate({ range: range }, function (key, value, control) {\n                numDeleted++;\n                return control.delete();\n            });\n            promises.push(removePromise.next(function () {\n                assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' +\n                    batch.batchId);\n            }));\n            for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {\n                var mutation = _a[_i];\n                var indexKey = DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);\n                promises.push(indexTxn.delete(indexKey));\n                if (this_1.garbageCollector !== null) {\n                    this_1.garbageCollector.addPotentialGarbageKey(mutation.key);\n                }\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            _loop_1(batch);\n        }\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        var _this = this;\n        return this.checkEmpty(txn).next(function (empty) {\n            if (!empty) {\n                return PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));\n            var danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, function (key, _, control) {\n                var userID = key[0];\n                if (userID !== _this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    var path = EncodedResourcePath.decode(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(function () {\n                assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' +\n                    danglingMutationReferences.map(function (p) { return p.canonicalString(); }));\n            });\n        });\n    };\n    IndexedDbMutationQueue.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {\n        var _this = this;\n        var indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);\n        var encodedPath = indexKey[1];\n        var startRange = IDBKeyRange.lowerBound(indexKey);\n        var containsKey = false;\n        return documentMutationsStore(txn)\n            .iterate({ range: startRange, keysOnly: true }, function (key, _, control) {\n            var userID = key[0], keyPath = key[1], batchID = key[2];\n            if (userID === _this.userId && keyPath === encodedPath) {\n                containsKey = true;\n            }\n            control.done();\n        })\n            .next(function () { return containsKey; });\n    };\n    /**\n     * Creates a [userId, batchId] key for use with the DbMutationQueue object\n     * store.\n     */\n    IndexedDbMutationQueue.prototype.keyForBatchId = function (batchId) {\n        return [this.userId, batchId];\n    };\n    return IndexedDbMutationQueue;\n}());\nexport { IndexedDbMutationQueue };\nfunction validateStreamToken(token) {\n    assert(typeof token === 'string', 'Persisting non-string stream token not supported.');\n    return token;\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatch.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, DbDocumentMutation.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueue.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore(txn, store) {\n    if (txn instanceof SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n//# sourceMappingURL=indexeddb_mutation_queue.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_mutation_queue.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert, fail } from '../util/assert';\nimport { immediateSuccessor } from '../util/misc';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbTarget, DbTargetDocument, DbTargetGlobal } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\nvar IndexedDbQueryCache = /** @class */ (function () {\n    function IndexedDbQueryCache(serializer) {\n        this.serializer = serializer;\n        /**\n         * The last received snapshot version. We store this seperately from the\n         * metadata to avoid the extra conversion to/from DbTimestamp.\n         */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n        /**\n         * A cached copy of the metadata for the query cache.\n         */\n        this.metadata = new DbTargetGlobal(\n        /*highestTargetId=*/ 0, \n        /*lastListenSequenceNumber=*/ 0, SnapshotVersion.MIN.toTimestamp());\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n    }\n    IndexedDbQueryCache.prototype.start = function (transaction) {\n        var _this = this;\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobal.key)\n            .next(function (metadata) {\n            if (metadata !== null) {\n                _this.metadata = metadata;\n                var lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n                _this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));\n            }\n            return PersistencePromise.resolve();\n        });\n    };\n    IndexedDbQueryCache.prototype.getHighestTargetId = function () {\n        return this.metadata.highestTargetId;\n    };\n    IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n    };\n    IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        var _this = this;\n        var targetId = queryData.targetId;\n        var addedQueryPromise = targetsStore(transaction).put(this.serializer.toDbTarget(queryData));\n        if (targetId > this.metadata.highestTargetId) {\n            this.metadata.highestTargetId = targetId;\n            return addedQueryPromise.next(function () {\n                return globalTargetStore(transaction).put(DbTargetGlobal.key, _this.metadata);\n            });\n        }\n        else {\n            return addedQueryPromise;\n        }\n    };\n    IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function () {\n            targetsStore(transaction).delete(queryData.targetId);\n        });\n    };\n    IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {\n        var _this = this;\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficent.\n        var canonicalId = query.canonicalId();\n        var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        var result = null;\n        return targetsStore(transaction)\n            .iterate({ range: range, index: DbTarget.queryTargetsIndexName }, function (key, value, control) {\n            var found = _this.serializer.fromDbTarget(value);\n            // After finding a potential match, check that the query is\n            // actually equal to the requested query.\n            if (query.equals(found.query)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // Indexeddb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = EncodedResourcePath.encode(key.path);\n            promises.push(store.put(new DbTargetDocument(targetId, path)));\n        });\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        var _this = this;\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = EncodedResourcePath.encode(key.path);\n            promises.push(store.delete([targetId, path]));\n            if (_this.garbageCollector !== null) {\n                _this.garbageCollector.addPotentialGarbageKey(key);\n            }\n        });\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        var store = documentTargetStore(txn);\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return this.notifyGCForRemovedKeys(txn, range).next(function () {\n            return store.delete(range);\n        });\n    };\n    IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) {\n        var _this = this;\n        var store = documentTargetStore(txn);\n        if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n            // In order to generate garbage events properly, we need to read these\n            // keys before deleting.\n            return store.iterate({ range: range, keysOnly: true }, function (key, _, control) {\n                var path = EncodedResourcePath.decode(key[1]);\n                var docKey = new DocumentKey(path);\n                // Paranoid assertion in case the the collector is set to null\n                // during the iteration.\n                assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');\n                _this.garbageCollector.addPotentialGarbageKey(docKey);\n            });\n        }\n        else {\n            return PersistencePromise.resolve();\n        }\n    };\n    IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var promises = [];\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var store = documentTargetStore(txn);\n        var result = documentKeySet();\n        return store\n            .iterate({ range: range, keysOnly: true }, function (key, _, control) {\n            var path = EncodedResourcePath.decode(key[1]);\n            var docKey = new DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbQueryCache.prototype.containsKey = function (txn, key) {\n        assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');\n        var path = EncodedResourcePath.encode(key.path);\n        var range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocument.documentTargetsIndex,\n            keysOnly: true,\n            range: range\n        }, function (key, _, control) {\n            count++;\n            control.done();\n        })\n            .next(function () { return count > 0; });\n    };\n    return IndexedDbQueryCache;\n}());\nexport { IndexedDbQueryCache };\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return getStore(txn, DbTarget.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return getStore(txn, DbTargetGlobal.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return getStore(txn, DbTargetDocument.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore(txn, store) {\n    if (txn instanceof SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n//# sourceMappingURL=indexeddb_query_cache.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_query_cache.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentMap } from '../model/collections';\nimport { Document } from '../model/document';\nimport { fail } from '../util/assert';\nimport { DbRemoteDocument } from './indexeddb_schema';\nimport { SimpleDbTransaction } from './simple_db';\nvar IndexedDbRemoteDocumentCache = /** @class */ (function () {\n    function IndexedDbRemoteDocumentCache(serializer) {\n        this.serializer = serializer;\n    }\n    IndexedDbRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        return remoteDocumentsStore(transaction).put(dbKey(maybeDocument.key), this.serializer.toDbRemoteDocument(maybeDocument));\n    };\n    IndexedDbRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        return remoteDocumentsStore(transaction).delete(dbKey(documentKey));\n    };\n    IndexedDbRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        var _this = this;\n        return remoteDocumentsStore(transaction)\n            .get(dbKey(documentKey))\n            .next(function (dbRemoteDoc) {\n            return dbRemoteDoc\n                ? _this.serializer.fromDbRemoteDocument(dbRemoteDoc)\n                : null;\n        });\n    };\n    IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var _this = this;\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var startKey = query.path.toArray();\n        var range = IDBKeyRange.lowerBound(startKey);\n        return remoteDocumentsStore(transaction)\n            .iterate({ range: range }, function (key, dbRemoteDoc, control) {\n            var maybeDoc = _this.serializer.fromDbRemoteDocument(dbRemoteDoc);\n            if (!query.path.isPrefixOf(maybeDoc.key.path)) {\n                control.done();\n            }\n            else if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        })\n            .next(function () { return results; });\n    };\n    return IndexedDbRemoteDocumentCache;\n}());\nexport { IndexedDbRemoteDocumentCache };\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(txn) {\n    if (txn instanceof SimpleDbTransaction) {\n        return txn.store(DbRemoteDocument.store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\nfunction dbKey(docKey) {\n    return docKey.path.toArray();\n}\n\n//# sourceMappingURL=indexeddb_remote_document_cache.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_remote_document_cache.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { DbMutationBatch, DbNoDocument, DbRemoteDocument, DbTarget, DbTimestamp } from './indexeddb_schema';\nimport { QueryData, QueryPurpose } from './query_data';\n/** Serializer for values stored in the LocalStore. */\nvar LocalSerializer = /** @class */ (function () {\n    function LocalSerializer(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n    /** Decodes a remote document from storage locally to a Document. */\n    LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {\n        if (remoteDoc.document) {\n            return this.remoteSerializer.fromDocument(remoteDoc.document);\n        }\n        else if (remoteDoc.noDocument) {\n            var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n            var readTime = remoteDoc.noDocument.readTime;\n            var timestamp = new Timestamp(readTime.seconds, readTime.nanos);\n            return new NoDocument(key, SnapshotVersion.fromTimestamp(timestamp));\n        }\n        else {\n            return fail('Unexpected DbRemoteDocument');\n        }\n    };\n    /** Encodes a document for storage locally. */\n    LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {\n        if (maybeDoc instanceof Document) {\n            var doc = this.remoteSerializer.toDocument(maybeDoc);\n            return new DbRemoteDocument(null, doc);\n        }\n        else {\n            var path = maybeDoc.key.path.toArray();\n            var timestamp = maybeDoc.version.toTimestamp();\n            var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n            return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n        }\n    };\n    /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n    LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {\n        var _this = this;\n        var serializedMutations = batch.mutations.map(function (m) {\n            return _this.remoteSerializer.toMutation(m);\n        });\n        return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);\n    };\n    /** Decodes a DbMutationBatch into a MutationBatch */\n    LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {\n        var _this = this;\n        var mutations = dbBatch.mutations.map(function (m) {\n            return _this.remoteSerializer.fromMutation(m);\n        });\n        var timestamp = Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n        return new MutationBatch(dbBatch.batchId, timestamp, mutations);\n    };\n    /** Decodes a DbTarget into QueryData */\n    LocalSerializer.prototype.fromDbTarget = function (dbTarget) {\n        var readTime = new Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);\n        var version = SnapshotVersion.fromTimestamp(readTime);\n        var query;\n        if (isDocumentQuery(dbTarget.query)) {\n            query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n        }\n        else {\n            query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n        }\n        return new QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);\n    };\n    /** Encodes QueryData into a DbTarget for storage locally. */\n    LocalSerializer.prototype.toDbTarget = function (queryData) {\n        assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' +\n            QueryPurpose.Listen +\n            ' may be stored, got ' +\n            queryData.purpose);\n        var timestamp = queryData.snapshotVersion.toTimestamp();\n        var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n        var queryProto;\n        if (queryData.query.isDocumentQuery()) {\n            queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n        }\n        else {\n            queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n        }\n        assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');\n        var resumeToken = queryData.resumeToken;\n        // lastListenSequenceNumber is always 0 until we do real GC.\n        return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);\n    };\n    return LocalSerializer;\n}());\nexport { LocalSerializer };\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n\n//# sourceMappingURL=local_serializer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/local_serializer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { User } from '../auth/user';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nvar OAuthToken = /** @class */ (function () {\n    function OAuthToken(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.authHeaders = { Authorization: \"Bearer \" + value };\n    }\n    return OAuthToken;\n}());\nexport { OAuthToken };\n/** A CredentialsProvider that always yields an empty token. */\nvar EmptyCredentialsProvider = /** @class */ (function () {\n    function EmptyCredentialsProvider() {\n        /**\n         * Stores the User listener registered with setUserChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.userListener = null;\n    }\n    EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(null);\n    };\n    EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire with initial user.\n        listener(User.UNAUTHENTICATED);\n    };\n    EmptyCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');\n        this.userListener = null;\n    };\n    return EmptyCredentialsProvider;\n}());\nexport { EmptyCredentialsProvider };\nvar FirebaseCredentialsProvider = /** @class */ (function () {\n    function FirebaseCredentialsProvider(app) {\n        var _this = this;\n        this.app = app;\n        /**\n         * The auth token listener registered with FirebaseApp, retained here so we\n         * can unregister it.\n         */\n        this.tokenListener = null;\n        /**\n         * Counter used to detect if the user changed while a getToken request was\n         * outstanding.\n         */\n        this.userCounter = 0;\n        /** The User listener registered with setUserChangeListener(). */\n        this.userListener = null;\n        // We listen for token changes but all we really care about is knowing when\n        // the uid may have changed.\n        this.tokenListener = function () {\n            var newUser = _this.getUser();\n            if (!_this.currentUser || !newUser.equals(_this.currentUser)) {\n                _this.currentUser = newUser;\n                _this.userCounter++;\n                if (_this.userListener) {\n                    _this.userListener(_this.currentUser);\n                }\n            }\n        };\n        this.userCounter = 0;\n        // Will fire at least once where we set this.currentUser\n        this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n    }\n    FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');\n        // Take note of the current value of the userCounter so that this method can\n        // fail (with an ABORTED error) if there is a user change while the request\n        // is outstanding.\n        var initialUserCounter = this.userCounter;\n        return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {\n            // Cancel the request since the user changed while the request was\n            // outstanding so the response is likely for a previous user (which\n            // user, we can't be sure).\n            if (_this.userCounter !== initialUserCounter) {\n                throw new FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');\n            }\n            else {\n                if (tokenData) {\n                    assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);\n                    return new OAuthToken(tokenData.accessToken, _this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    };\n    FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire the initial event, but only if we received the initial user\n        if (this.currentUser) {\n            listener(this.currentUser);\n        }\n    };\n    FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.tokenListener != null, 'removeUserChangeListener() called twice');\n        assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');\n        this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);\n        this.tokenListener = null;\n        this.userListener = null;\n    };\n    FirebaseCredentialsProvider.prototype.getUser = function () {\n        // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n        if (typeof this.app.INTERNAL.getUid !== 'function') {\n            fail('This version of the Firestore SDK requires at least version' +\n                ' 3.7.0 of firebase.js.');\n        }\n        var currentUid = this.app.INTERNAL.getUid();\n        assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);\n        return new User(currentUid);\n    };\n    return FirebaseCredentialsProvider;\n}());\nexport { FirebaseCredentialsProvider };\n// Wrap a google-auth-library client as a CredentialsProvider.\n// NOTE: grpc-connection can natively accept a google-auth-library\n// client via createFromGoogleCredential(), but we opt to plumb the tokens\n// through our CredentialsProvider interface, at least for now.\nvar GoogleCredentialsProvider = /** @class */ (function () {\n    function GoogleCredentialsProvider(authClient) {\n        this.authClient = authClient;\n    }\n    GoogleCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // TODO(b/32935141): ideally this would be declared as an extern\n            _this.authClient['getAccessToken'](function (error, tokenLiteral) {\n                if (error) {\n                    reject(error);\n                }\n                else {\n                    resolve(new OAuthToken(tokenLiteral, User.GOOGLE_CREDENTIALS));\n                }\n            });\n        });\n    };\n    // NOTE: A google-auth-library client represents an immutable \"user\", so\n    // once we fire the initial event, it'll never change.\n    GoogleCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        // Fire with initial uid.\n        listener(User.GOOGLE_CREDENTIALS);\n    };\n    GoogleCredentialsProvider.prototype.removeUserChangeListener = function () { };\n    return GoogleCredentialsProvider;\n}());\nexport { GoogleCredentialsProvider };\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\nvar FirstPartyToken = /** @class */ (function () {\n    function FirstPartyToken(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    Object.defineProperty(FirstPartyToken.prototype, \"authHeaders\", {\n        get: function () {\n            return {\n                Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n                'X-Goog-AuthUser': this.sessionIndex\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FirstPartyToken;\n}());\nexport { FirstPartyToken };\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nvar FirstPartyCredentialsProvider = /** @class */ (function () {\n    function FirstPartyCredentialsProvider(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\n    };\n    // TODO(33108925): can someone switch users w/o a page refresh?\n    // TODO(33110621): need to understand token/session lifecycle\n    FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        // Fire with initial uid.\n        listener(User.FIRST_PARTY);\n    };\n    FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () { };\n    return FirstPartyCredentialsProvider;\n}());\nexport { FirstPartyCredentialsProvider };\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nexport function makeCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new EmptyCredentialsProvider();\n    }\n    switch (credentials.type) {\n        case 'google-auth':\n            return new GoogleCredentialsProvider(credentials.client);\n        case 'gapi':\n            return new FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');\n        case 'provider':\n            return credentials.client;\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n//# sourceMappingURL=credentials.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/credentials.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport function isPartialObserver(obj) {\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    var object = obj;\n    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n        var method = methods_1[_i];\n        if (method in object && typeof object[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n\n//# sourceMappingURL=observer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/observer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Timestamp } from '../core/timestamp';\nimport { ObjectValue } from '../model/field_value';\nimport { ArrayValue, BlobValue, BooleanValue, DoubleValue, GeoPointValue, IntegerValue, NullValue, RefValue, StringValue, TimestampValue } from '../model/field_value';\nimport { FieldMask, FieldTransform, PatchMutation, ServerTimestampTransform, SetMutation, TransformMutation } from '../model/mutation';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isPlainObject, valueDescription } from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { SortedMap } from '../util/sorted_map';\nimport * as typeUtils from '../util/types';\nimport { Blob } from './blob';\nimport { FieldPath as ExternalFieldPath, fromDotSeparatedString } from './field_path';\nimport { DeleteFieldValueImpl, FieldValueImpl, ServerTimestampFieldValueImpl } from './field_value';\nimport { GeoPoint } from './geo_point';\nvar RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nvar ParsedSetData = /** @class */ (function () {\n    function ParsedSetData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedSetData.prototype.toMutations = function (key, precondition) {\n        var mutations = [];\n        if (this.fieldMask !== null) {\n            mutations.push(new PatchMutation(key, this.data, this.fieldMask, precondition));\n        }\n        else {\n            mutations.push(new SetMutation(key, this.data, precondition));\n        }\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedSetData;\n}());\nexport { ParsedSetData };\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nvar ParsedUpdateData = /** @class */ (function () {\n    function ParsedUpdateData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedUpdateData.prototype.toMutations = function (key, precondition) {\n        var mutations = [\n            new PatchMutation(key, this.data, this.fieldMask, precondition)\n        ];\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedUpdateData;\n}());\nexport { ParsedUpdateData };\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nvar UserDataSource;\n(function (UserDataSource) {\n    UserDataSource[UserDataSource[\"Set\"] = 0] = \"Set\";\n    UserDataSource[UserDataSource[\"Update\"] = 1] = \"Update\";\n    UserDataSource[UserDataSource[\"MergeSet\"] = 2] = \"MergeSet\";\n    UserDataSource[UserDataSource[\"QueryValue\"] = 3] = \"QueryValue\"; // from a where clause or cursor bound\n})(UserDataSource || (UserDataSource = {}));\nfunction isWrite(dataSource) {\n    switch (dataSource) {\n        case UserDataSource.Set: // fall through\n        case UserDataSource.MergeSet: // fall through\n        case UserDataSource.Update:\n            return true;\n        case UserDataSource.QueryValue:\n            return false;\n        default:\n            throw fail(\"Unexpected case for UserDataSource: \" + dataSource);\n    }\n}\n/** A \"context\" object passed around while parsing user data. */\nvar ParseContext = /** @class */ (function () {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param dataSource Indicates what kind of API method this data came from.\n     * @param methodName The name of the method the user called to create this\n     *     ParseContext.\n     * @param path A path within the object being parsed. This could be an empty\n     *     path (in which case the context represents the root of the data being\n     *     parsed), or a nonempty path (indicating the context represents a nested\n     *     location within the data).\n     * @param arrayElement Whether or not this context corresponds to an element\n     *     of an array.\n     * @param fieldTransforms A mutable list of field transforms encountered while\n     *     parsing the data.\n     * @param fieldMask A mutable list of field paths encountered while parsing\n     *     the data.\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     */\n    function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) {\n        this.dataSource = dataSource;\n        this.methodName = methodName;\n        this.path = path;\n        this.arrayElement = arrayElement;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.arrayElement = arrayElement !== undefined ? arrayElement : false;\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    ParseContext.prototype.childContextForField = function (field) {\n        var childPath = this.path == null ? null : this.path.child(field);\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, \n        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);\n        context.validatePathSegment(field);\n        return context;\n    };\n    ParseContext.prototype.childContextForFieldPath = function (field) {\n        var childPath = this.path == null ? null : this.path.child(field);\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, \n        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);\n        context.validatePath();\n        return context;\n    };\n    ParseContext.prototype.childContextForArray = function (index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // null.\n        return new ParseContext(this.dataSource, this.methodName, \n        /*path=*/ null, \n        /*arrayElement=*/ true, this.fieldTransforms, this.fieldMask);\n    };\n    ParseContext.prototype.createError = function (reason) {\n        var fieldDescription = this.path === null || this.path.isEmpty()\n            ? ''\n            : \" (found in field \" + this.path.toString() + \")\";\n        return new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" +\n            reason +\n            fieldDescription);\n    };\n    ParseContext.prototype.validatePath = function () {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (this.path === null) {\n            return;\n        }\n        for (var i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    };\n    ParseContext.prototype.validatePathSegment = function (segment) {\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with __');\n        }\n    };\n    ParseContext.prototype.isWrite = function () {\n        return (this.dataSource === UserDataSource.Set ||\n            this.dataSource === UserDataSource.Update);\n    };\n    return ParseContext;\n}());\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\nvar DocumentKeyReference = /** @class */ (function () {\n    function DocumentKeyReference(databaseId, key) {\n        this.databaseId = databaseId;\n        this.key = key;\n    }\n    return DocumentKeyReference;\n}());\nexport { DocumentKeyReference };\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nvar UserDataConverter = /** @class */ (function () {\n    function UserDataConverter(preConverter) {\n        this.preConverter = preConverter;\n    }\n    /** Parse document data from a non-merge set() call.*/\n    UserDataConverter.prototype.parseSetData = function (methodName, input) {\n        var context = new ParseContext(UserDataSource.Set, methodName, FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var updateData = this.parseData(input, context);\n        return new ParsedSetData(updateData, \n        /* fieldMask= */ null, context.fieldTransforms);\n    };\n    /** Parse document data from a set() call with '{merge:true}'. */\n    UserDataConverter.prototype.parseMergeData = function (methodName, input) {\n        var context = new ParseContext(UserDataSource.MergeSet, methodName, FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var updateData = this.parseData(input, context);\n        var fieldMask = new FieldMask(context.fieldMask);\n        return new ParsedSetData(updateData, fieldMask, context.fieldTransforms);\n    };\n    /** Parse update data from an update() call. */\n    UserDataConverter.prototype.parseUpdateData = function (methodName, input) {\n        var _this = this;\n        var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var fieldMaskPaths = [];\n        var updateData = ObjectValue.EMPTY;\n        objUtils.forEach(input, function (key, value) {\n            var path = fieldPathFromDotSeparatedString(methodName, key);\n            var childContext = context.childContextForFieldPath(path);\n            value = _this.runPreConverter(value, childContext);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = _this.parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        });\n        var mask = new FieldMask(fieldMaskPaths);\n        return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /** Parse update data from a list of field/value arguments. */\n    UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) {\n        var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);\n        var keys = [fieldPathFromArgument(methodName, field)];\n        var values = [value];\n        if (moreFieldsAndValues.length % 2 !== 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() needs to be called with an even number \" +\n                'of arguments that alternate between field names and values.');\n        }\n        for (var i = 0; i < moreFieldsAndValues.length; i += 2) {\n            keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));\n            values.push(moreFieldsAndValues[i + 1]);\n        }\n        var fieldMaskPaths = [];\n        var updateData = ObjectValue.EMPTY;\n        for (var i = 0; i < keys.length; ++i) {\n            var path = keys[i];\n            var childContext = context.childContextForFieldPath(path);\n            var value_1 = this.runPreConverter(values[i], childContext);\n            if (value_1 instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = this.parseData(value_1, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        }\n        var mask = new FieldMask(fieldMaskPaths);\n        return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /**\n     * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n     * bound).\n     */\n    UserDataConverter.prototype.parseQueryValue = function (methodName, input) {\n        var context = new ParseContext(UserDataSource.QueryValue, methodName, FieldPath.EMPTY_PATH);\n        var parsed = this.parseData(input, context);\n        assert(parsed != null, 'Parsed data should not be null.');\n        assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');\n        return parsed;\n    };\n    /** Sends data through this.preConverter, handling any thrown errors. */\n    UserDataConverter.prototype.runPreConverter = function (input, context) {\n        try {\n            return this.preConverter(input);\n        }\n        catch (e) {\n            var message = errorMessage(e);\n            throw context.createError(message);\n        }\n    };\n    /**\n     * Internal helper for parsing user data.\n     *\n     * @param input Data to be parsed.\n     * @param context A context object representing the current path being parsed,\n     * the source of the data being parsed, etc.\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseData = function (input, context) {\n        input = this.runPreConverter(input, context);\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            if (context.arrayElement) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            // If context.path is null we are already inside an array and we don't\n            // support field mask paths more granular than the top-level array.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseArray(input, context);\n        }\n        else if (looksLikeJsonObject(input)) {\n            validatePlainObject('Unsupported field value:', context, input);\n            return this.parseObject(input, context);\n        }\n        else {\n            // If context.path is null, we are inside an array and we should have\n            // already added the root of the array to the field mask.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseScalarValue(input, context);\n        }\n    };\n    UserDataConverter.prototype.parseArray = function (array, context) {\n        var result = [];\n        var entryIndex = 0;\n        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n            var entry = array_1[_i];\n            var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));\n            if (parsedEntry == null) {\n                // Just include nulls in the array for fields being replaced with a\n                // sentinel.\n                parsedEntry = NullValue.INSTANCE;\n            }\n            result.push(parsedEntry);\n            entryIndex++;\n        }\n        return new ArrayValue(result);\n    };\n    UserDataConverter.prototype.parseObject = function (obj, context) {\n        var _this = this;\n        var result = new SortedMap(primitiveComparator);\n        objUtils.forEach(obj, function (key, val) {\n            var parsedValue = _this.parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                result = result.insert(key, parsedValue);\n            }\n        });\n        return new ObjectValue(result);\n    };\n    /**\n     * Helper to parse a scalar value (i.e. not an Object or Array)\n     *\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseScalarValue = function (value, context) {\n        if (value === null) {\n            return NullValue.INSTANCE;\n        }\n        else if (typeof value === 'number') {\n            if (typeUtils.isSafeInteger(value)) {\n                return new IntegerValue(value);\n            }\n            else {\n                return new DoubleValue(value);\n            }\n        }\n        else if (typeof value === 'boolean') {\n            return BooleanValue.of(value);\n        }\n        else if (typeof value === 'string') {\n            return new StringValue(value);\n        }\n        else if (value instanceof Date) {\n            return new TimestampValue(Timestamp.fromDate(value));\n        }\n        else if (value instanceof GeoPoint) {\n            return new GeoPointValue(value);\n        }\n        else if (value instanceof Blob) {\n            return new BlobValue(value);\n        }\n        else if (value instanceof DocumentKeyReference) {\n            return new RefValue(value.databaseId, value.key);\n        }\n        else if (value instanceof FieldValueImpl) {\n            if (value instanceof DeleteFieldValueImpl) {\n                if (context.dataSource == UserDataSource.MergeSet) {\n                    return null;\n                }\n                else if (context.dataSource === UserDataSource.Update) {\n                    assert(context.path == null || context.path.length > 0, 'FieldValue.delete() at the top level should have already' +\n                        ' been handled.');\n                    throw context.createError('FieldValue.delete() can only appear at the top level ' +\n                        'of your update data');\n                }\n                else {\n                    // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n                    throw context.createError('FieldValue.delete() can only be used with update() and set() with {merge:true}');\n                }\n            }\n            else if (value instanceof ServerTimestampFieldValueImpl) {\n                if (!isWrite(context.dataSource)) {\n                    throw context.createError('FieldValue.serverTimestamp() can only be used with set()' +\n                        ' and update()');\n                }\n                if (context.path === null) {\n                    throw context.createError('FieldValue.serverTimestamp() is not currently' +\n                        ' supported inside arrays');\n                }\n                context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance));\n                // Return null so this value is omitted from the parsed result.\n                return null;\n            }\n            else {\n                return fail('Unknown FieldValue type: ' + value);\n            }\n        }\n        else {\n            throw context.createError(\"Unsupported field value: \" + valueDescription(value));\n        }\n    };\n    return UserDataConverter;\n}());\nexport { UserDataConverter };\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof GeoPoint) &&\n        !(input instanceof Blob) &&\n        !(input instanceof DocumentKeyReference) &&\n        !(input instanceof FieldValueImpl));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        var description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nexport function fieldPathFromArgument(methodName, path) {\n    if (path instanceof ExternalFieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        var message = 'Field path arguments must be of type string or FieldPath.';\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path) {\n    try {\n        return fromDotSeparatedString(path)._internalPath;\n    }\n    catch (e) {\n        var message = errorMessage(e);\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error) {\n    return error instanceof Error ? error.message : error.toString();\n}\n\n//# sourceMappingURL=user_data_converter.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/user_data_converter.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { FieldPath as ExternalFieldPath } from './field_path';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { FirestoreClient } from '../core/firestore_client';\nimport { Bound, Direction, fieldFilter, OrderBy, Query as InternalQuery, RelationFilter, RelationOp } from '../core/query';\nimport { ChangeType } from '../core/view_snapshot';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { ArrayValue, ObjectValue, RefValue } from '../model/field_value';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { ResourcePath } from '../model/path';\nimport { PlatformSupport } from '../platform/platform';\nimport { makeConstructorPrivate } from '../util/api';\nimport { assert, fail } from '../util/assert';\nimport { AsyncObserver } from '../util/async_observer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { invalidClassError, validateArgType, validateAtLeastNumberOfArgs, validateBetweenNumberOfArgs, validateDefined, validateExactNumberOfArgs, validateNamedOptionalType, validateNamedType, validateOptionalArgType, validateOptionNames, valueDescription } from '../util/input_validation';\nimport * as log from '../util/log';\nimport { LogLevel } from '../util/log';\nimport { AutoId } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { EmptyCredentialsProvider, FirebaseCredentialsProvider, makeCredentialsProvider } from './credentials';\nimport { isPartialObserver } from './observer';\nimport { DocumentKeyReference, fieldPathFromArgument, UserDataConverter } from './user_data_converter';\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\nvar DEFAULT_HOST = 'firestore.googleapis.com';\nvar DEFAULT_SSL = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nvar FirestoreSettings = /** @class */ (function () {\n    function FirestoreSettings(settings) {\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            validateNamedType('settings', 'string', 'host', settings.host);\n            this.host = settings.host;\n            validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n            this.ssl = objUtils.defaulted(settings.ssl, DEFAULT_SSL);\n        }\n        validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);\n        validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);\n        this.credentials = settings.credentials;\n    }\n    FirestoreSettings.prototype.equals = function (other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials);\n    };\n    return FirestoreSettings;\n}());\nvar FirestoreConfig = /** @class */ (function () {\n    function FirestoreConfig() {\n    }\n    return FirestoreConfig;\n}());\n/**\n * The root reference to the database.\n */\nvar Firestore = /** @class */ (function () {\n    function Firestore(databaseIdOrApp) {\n        var _this = this;\n        this.INTERNAL = {\n            delete: function () {\n                if (_this._firestoreClient) {\n                    return _this._firestoreClient.shutdown();\n                }\n                else {\n                    return Promise.resolve();\n                }\n            },\n            // Exposed via INTERNAL for use in tests.\n            disableNetwork: function () { return _this._firestoreClient.disableNetwork(); },\n            enableNetwork: function () { return _this._firestoreClient.enableNetwork(); }\n        };\n        var config = new FirestoreConfig();\n        if (typeof databaseIdOrApp.options === 'object') {\n            // This is very likely a Firebase app object\n            // TODO(b/34177605): Can we somehow use instanceof?\n            var app = databaseIdOrApp;\n            config.firebaseApp = app;\n            config.databaseId = Firestore.databaseIdFromApp(app);\n            config.persistenceKey = config.firebaseApp.name;\n            config.credentials = new FirebaseCredentialsProvider(app);\n        }\n        else {\n            var external_1 = databaseIdOrApp;\n            if (!external_1.projectId) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');\n            }\n            config.databaseId = new DatabaseId(external_1.projectId, external_1.database);\n            // Use a default persistenceKey that lines up with FirebaseApp.\n            config.persistenceKey = '[DEFAULT]';\n            config.credentials = new EmptyCredentialsProvider();\n        }\n        config.settings = new FirestoreSettings({});\n        this._config = config;\n        this._databaseId = config.databaseId;\n    }\n    Firestore.prototype.settings = function (settingsLiteral) {\n        validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n        validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n        if (objUtils.contains(settingsLiteral, 'persistence')) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to ' +\n                'firestore.enablePersistence().');\n        }\n        var newSettings = new FirestoreSettings(settingsLiteral);\n        if (this._firestoreClient && !this._config.settings.equals(newSettings)) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only call settings() before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._config.settings = newSettings;\n        if (newSettings.credentials !== undefined) {\n            this._config.credentials = makeCredentialsProvider(newSettings.credentials);\n        }\n    };\n    Firestore.prototype.enablePersistence = function () {\n        if (this._firestoreClient) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' +\n                'be enabled. You can only call enablePersistence() before calling ' +\n                'any other methods on a Firestore object.');\n        }\n        return this.configureClient(/* persistence= */ true);\n    };\n    Firestore.prototype.ensureClientConfigured = function () {\n        if (!this._firestoreClient) {\n            this.configureClient(/* persistence= */ false);\n        }\n        return this._firestoreClient;\n    };\n    Firestore.prototype.configureClient = function (persistence) {\n        var _this = this;\n        assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');\n        assert(!this._firestoreClient, 'configureClient() called multiple times');\n        var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);\n        var preConverter = function (value) {\n            if (value instanceof DocumentReference) {\n                var thisDb = _this._config.databaseId;\n                var otherDb = value.firestore._config.databaseId;\n                if (!otherDb.equals(thisDb)) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' +\n                        (otherDb.projectId + \"/\" + otherDb.database + \" but should be \") +\n                        (\"for database \" + thisDb.projectId + \"/\" + thisDb.database));\n                }\n                return new DocumentKeyReference(_this._config.databaseId, value._key);\n            }\n            else {\n                return value;\n            }\n        };\n        this._dataConverter = new UserDataConverter(preConverter);\n        this._firestoreClient = new FirestoreClient(PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, new AsyncQueue());\n        return this._firestoreClient.start(persistence);\n    };\n    Firestore.databaseIdFromApp = function (app) {\n        var options = app.options;\n        if (!objUtils.contains(options, 'projectId')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreId' once alpha testers have upgraded.\n            if (objUtils.contains(options, 'firestoreId')) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreId\" is now specified as \"projectId\" in ' +\n                    'firebase.initializeApp.');\n            }\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n        }\n        if (objUtils.contains(options, 'firestoreOptions')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreOptions' once alpha testers have upgraded.\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreOptions\" values are now specified with ' +\n                'Firestore.settings()');\n        }\n        var projectId = options['projectId'];\n        if (!projectId || typeof projectId !== 'string') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in FirebaseApp.options');\n        }\n        return new DatabaseId(projectId);\n    };\n    Object.defineProperty(Firestore.prototype, \"app\", {\n        get: function () {\n            if (!this._config.firebaseApp) {\n                throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                    'not available');\n            }\n            return this._config.firebaseApp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n        validateArgType('Firestore.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');\n        }\n        this.ensureClientConfigured();\n        return new CollectionReference(ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.doc = function (pathString) {\n        validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n        validateArgType('Firestore.doc', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');\n        }\n        this.ensureClientConfigured();\n        return DocumentReference.forPath(ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.runTransaction = function (updateFunction) {\n        var _this = this;\n        validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n        validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n        return this.ensureClientConfigured().transaction(function (transaction) {\n            return updateFunction(new Transaction(_this, transaction));\n        });\n    };\n    Firestore.prototype.batch = function () {\n        this.ensureClientConfigured();\n        return new WriteBatch(this);\n    };\n    Object.defineProperty(Firestore, \"logLevel\", {\n        get: function () {\n            switch (log.getLogLevel()) {\n                case LogLevel.DEBUG:\n                    return 'debug';\n                case LogLevel.ERROR:\n                    return 'error';\n                case LogLevel.SILENT:\n                    return 'silent';\n                default:\n                    return fail('Unknown log level: ' + log.getLogLevel());\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.setLogLevel = function (level) {\n        validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n        validateArgType('Firestore.setLogLevel', 'string', 1, level);\n        switch (level) {\n            case 'debug':\n                log.setLogLevel(log.LogLevel.DEBUG);\n                break;\n            case 'error':\n                log.setLogLevel(log.LogLevel.ERROR);\n                break;\n            case 'silent':\n                log.setLogLevel(log.LogLevel.SILENT);\n                break;\n            default:\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);\n        }\n    };\n    return Firestore;\n}());\nexport { Firestore };\n/**\n * A reference to a transaction.\n */\nvar Transaction = /** @class */ (function () {\n    function Transaction(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n    }\n    Transaction.prototype.get = function (documentRef) {\n        var _this = this;\n        validateExactNumberOfArgs('Transaction.get', arguments, 1);\n        var ref = validateReference('Transaction.get', documentRef, this._firestore);\n        return this._transaction\n            .lookup([ref._key])\n            .then(function (docs) {\n            if (!docs || docs.length !== 1) {\n                return fail('Mismatch in docs returned from document lookup.');\n            }\n            var doc = docs[0];\n            if (doc instanceof NoDocument) {\n                return new DocumentSnapshot(_this._firestore, ref._key, null, false);\n            }\n            return new DocumentSnapshot(_this._firestore, ref._key, doc, false);\n        });\n    };\n    Transaction.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n        var ref = validateReference('Transaction.set', documentRef, this._firestore);\n        options = validateSetOptions('Transaction.set', options);\n        var parsed = options.merge\n            ? this._firestore._dataConverter.parseMergeData('Transaction.set', value)\n            : this._firestore._dataConverter.parseSetData('Transaction.set', value);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('Transaction.update', arguments, 2);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n        var ref = validateReference('Transaction.delete', documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    };\n    return Transaction;\n}());\nexport { Transaction };\nvar WriteBatch = /** @class */ (function () {\n    function WriteBatch(_firestore) {\n        this._firestore = _firestore;\n        this._mutations = [];\n        this._committed = false;\n    }\n    WriteBatch.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.set', documentRef, this._firestore);\n        options = validateSetOptions('WriteBatch.set', options);\n        var parsed = options.merge\n            ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value)\n            : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        this.verifyNotCommitted();\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);\n        }\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.exists(true)));\n        return this;\n    };\n    WriteBatch.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.commit = function () {\n        this.verifyNotCommitted();\n        this._committed = true;\n        if (this._mutations.length > 0) {\n            return this._firestore.ensureClientConfigured().write(this._mutations);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    WriteBatch.prototype.verifyNotCommitted = function () {\n        if (this._committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    };\n    return WriteBatch;\n}());\nexport { WriteBatch };\n/**\n * A reference to a particular document in a collection in the database.\n */\nvar DocumentReference = /** @class */ (function () {\n    function DocumentReference(_key, firestore) {\n        this._key = _key;\n        this.firestore = firestore;\n        this._firestoreClient = this.firestore.ensureClientConfigured();\n    }\n    DocumentReference.forPath = function (path, firestore) {\n        if (path.length % 2 !== 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' +\n                'references must have an even number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return new DocumentReference(new DocumentKey(path), firestore);\n    };\n    Object.defineProperty(DocumentReference.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"parent\", {\n        get: function () {\n            return new CollectionReference(this._key.path.popLast(), this.firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"path\", {\n        get: function () {\n            return this._key.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentReference.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n        validateArgType('DocumentReference.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');\n        }\n        var path = ResourcePath.fromString(pathString);\n        return new CollectionReference(this._key.path.child(path), this.firestore);\n    };\n    DocumentReference.prototype.isEqual = function (other) {\n        if (!(other instanceof DocumentReference)) {\n            throw invalidClassError('isEqual', 'DocumentReference', 1, other);\n        }\n        return this.firestore === other.firestore && this._key.equals(other._key);\n    };\n    DocumentReference.prototype.set = function (value, options) {\n        validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n        options = validateSetOptions('DocumentReference.set', options);\n        var parsed = options.merge\n            ? this.firestore._dataConverter.parseMergeData('DocumentReference.set', value)\n            : this.firestore._dataConverter.parseSetData('DocumentReference.set', value);\n        return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.NONE));\n    };\n    DocumentReference.prototype.update = function (fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 2] = arguments[_i];\n        }\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n            parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n            parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);\n        }\n        return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.exists(true)));\n    };\n    DocumentReference.prototype.delete = function () {\n        validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n        return this._firestoreClient.write([\n            new DeleteMutation(this._key, Precondition.NONE)\n        ]);\n    };\n    DocumentReference.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);\n        var options = {\n            includeMetadataChanges: false\n        };\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('DocumentReference.onSnapshot', options, [\n                'includeMetadataChanges'\n            ]);\n            validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);\n            currArg++;\n        }\n        var internalOptions = {\n            includeDocumentMetadataChanges: options.includeMetadataChanges,\n            includeQueryMetadataChanges: options.includeMetadataChanges\n        };\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(internalOptions, observer);\n    };\n    DocumentReference.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (snapshot) {\n                if (observer.next) {\n                    assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');\n                    var doc = snapshot.docs.get(_this._key);\n                    observer.next(new DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));\n                }\n            },\n            error: errHandler\n        });\n        var internalListener = this._firestoreClient.listen(InternalQuery.atPath(this._key.path), asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            _this._firestoreClient.unlisten(internalListener);\n        };\n    };\n    DocumentReference.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('DocumentReference.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeQueryMetadataChanges: true,\n                includeDocumentMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (snap) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    if (!snap.exists && snap.metadata.fromCache) {\n                        // TODO(dimond): If we're online and the document doesn't\n                        // exist then we resolve with a doc.exists set to false. If\n                        // we're offline however, we reject the Promise in this\n                        // case. Two options: 1) Cache the negative response from\n                        // the server so we can deliver that even when you're\n                        // offline 2) Actually reject the Promise in the online case\n                        // if the document doesn't exist.\n                        reject(new FirestoreError(Code.ABORTED, 'Failed to get document because the client is ' + 'offline.'));\n                    }\n                    else {\n                        resolve(snap);\n                    }\n                },\n                error: reject\n            });\n        });\n    };\n    return DocumentReference;\n}());\nexport { DocumentReference };\nvar DocumentSnapshot = /** @class */ (function () {\n    function DocumentSnapshot(_firestore, _key, _document, _fromCache) {\n        this._firestore = _firestore;\n        this._key = _key;\n        this._document = _document;\n        this._fromCache = _fromCache;\n    }\n    DocumentSnapshot.prototype.data = function () {\n        validateExactNumberOfArgs('DocumentSnapshot.data', arguments, 0);\n        if (!this._document) {\n            throw new FirestoreError(Code.NOT_FOUND, \"This document doesn't exist. Check doc.exists to make sure \" +\n                'the document exists before calling doc.data().');\n        }\n        return this.convertObject(this._document.data);\n    };\n    DocumentSnapshot.prototype.get = function (fieldPath) {\n        validateExactNumberOfArgs('DocumentSnapshot.get', arguments, 1);\n        if (!this._document) {\n            throw new FirestoreError(Code.NOT_FOUND, \"This document doesn't exist. Check doc.exists to make sure \" +\n                'the document exists before calling doc.get().');\n        }\n        var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n        return value === undefined ? undefined : this.convertValue(value);\n    };\n    Object.defineProperty(DocumentSnapshot.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"ref\", {\n        get: function () {\n            return new DocumentReference(this._key, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"exists\", {\n        get: function () {\n            return this._document !== null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"metadata\", {\n        get: function () {\n            return {\n                hasPendingWrites: this._document !== null && this._document.hasLocalMutations,\n                fromCache: this._fromCache\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentSnapshot.prototype.convertObject = function (data) {\n        var _this = this;\n        var result = {};\n        data.forEach(function (key, value) {\n            result[key] = _this.convertValue(value);\n        });\n        return result;\n    };\n    DocumentSnapshot.prototype.convertValue = function (value) {\n        if (value instanceof ObjectValue) {\n            return this.convertObject(value);\n        }\n        else if (value instanceof ArrayValue) {\n            return this.convertArray(value);\n        }\n        else if (value instanceof RefValue) {\n            var key = value.value();\n            var database = this._firestore.ensureClientConfigured().databaseId();\n            if (!value.databaseId.equals(database)) {\n                // TODO(b/64130202): Somehow support foreign references.\n                log.error(\"Document \" + this._key.path + \" contains a document \" +\n                    \"reference within a different database (\" +\n                    (value.databaseId.projectId + \"/\" + value.databaseId\n                        .database + \") which is not \") +\n                    \"supported. It will be treated as a reference in the current \" +\n                    (\"database (\" + database.projectId + \"/\" + database.database + \") \") +\n                    \"instead.\");\n            }\n            return new DocumentReference(key, this._firestore);\n        }\n        else {\n            return value.value();\n        }\n    };\n    DocumentSnapshot.prototype.convertArray = function (data) {\n        var _this = this;\n        return data.internalValue.map(function (value) {\n            return _this.convertValue(value);\n        });\n    };\n    return DocumentSnapshot;\n}());\nexport { DocumentSnapshot };\nvar Query = /** @class */ (function () {\n    function Query(_query, firestore) {\n        this._query = _query;\n        this.firestore = firestore;\n    }\n    Query.prototype.where = function (field, opStr, value) {\n        validateExactNumberOfArgs('Query.where', arguments, 3);\n        validateArgType('Query.where', 'string', 2, opStr);\n        validateDefined('Query.where', 3, value);\n        var fieldValue;\n        var fieldPath = fieldPathFromArgument('Query.where', field);\n        if (fieldPath.isKeyField()) {\n            if (typeof value === 'string') {\n                if (value.indexOf('/') !== -1) {\n                    // TODO(dimond): Allow slashes once ancestor queries are supported\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it contains a slash.');\n                }\n                if (value === '') {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it was an empty string.');\n                }\n                var path = this._query.path.child(new ResourcePath([value]));\n                assert(path.length % 2 === 0, 'Path should be a document key');\n                fieldValue = new RefValue(this.firestore._databaseId, new DocumentKey(path));\n            }\n            else if (value instanceof DocumentReference) {\n                var ref = value;\n                fieldValue = new RefValue(this.firestore._databaseId, ref._key);\n            }\n            else {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a \" +\n                    \"string or a DocumentReference if the first parameter is \" +\n                    \"FieldPath.documentId(), but it was: \" +\n                    (valueDescription(value) + \".\"));\n            }\n        }\n        else {\n            fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);\n        }\n        var filter = fieldFilter(fieldPath, RelationOp.fromString(opStr), fieldValue);\n        this.validateNewFilter(filter);\n        return new Query(this._query.addFilter(filter), this.firestore);\n    };\n    Query.prototype.orderBy = function (field, directionStr) {\n        validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n        validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);\n        var direction;\n        if (directionStr === undefined || directionStr === 'asc') {\n            direction = Direction.ASCENDING;\n        }\n        else if (directionStr === 'desc') {\n            direction = Direction.DESCENDING;\n        }\n        else {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + directionStr + \"', \" +\n                \"expected 'asc' or 'desc'.\");\n        }\n        if (this._query.startAt !== null) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' +\n                'Query.startAfter() before calling Query.orderBy().');\n        }\n        if (this._query.endAt !== null) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' +\n                'Query.endBefore() before calling Query.orderBy().');\n        }\n        var fieldPath = fieldPathFromArgument('Query.orderBy', field);\n        var orderBy = new OrderBy(fieldPath, direction);\n        this.validateNewOrderBy(orderBy);\n        return new Query(this._query.addOrderBy(orderBy), this.firestore);\n    };\n    Query.prototype.limit = function (n) {\n        validateExactNumberOfArgs('Query.limit', arguments, 1);\n        validateArgType('Query.limit', 'number', 1, n);\n        if (n <= 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + n + \") is invalid. Limit must be \" +\n                'positive.');\n        }\n        return new Query(this._query.withLimit(n), this.firestore);\n    };\n    Query.prototype.startAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.startAfter = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.endBefore = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.endAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.isEqual = function (other) {\n        if (!(other instanceof Query)) {\n            throw invalidClassError('isEqual', 'Query', 1, other);\n        }\n        return (this.firestore === other.firestore && this._query.equals(other._query));\n    };\n    /** Helper function to create a bound from a document or fields */\n    Query.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) {\n        validateDefined(methodName, 1, docOrField);\n        if (docOrField instanceof DocumentSnapshot) {\n            if (fields.length > 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"().\");\n            }\n            var snap = docOrField;\n            if (!snap.exists) {\n                throw new FirestoreError(Code.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" +\n                    (methodName + \"().\"));\n            }\n            return this.boundFromDocument(methodName, snap._document, before);\n        }\n        else {\n            var allFields = [docOrField].concat(fields);\n            return this.boundFromFields(methodName, allFields, before);\n        }\n    };\n    /**\n     * Create a Bound from a query and a document.\n     *\n     * Note that the Bound will always include the key of the document\n     * and so only the provided document will compare equal to the returned\n     * position.\n     *\n     * Will throw if the document does not contain all fields of the order by\n     * of the query.\n     */\n    Query.prototype.boundFromDocument = function (methodName, doc, before) {\n        var components = [];\n        // Because people expect to continue/end a query at the exact document\n        // provided, we need to use the implicit sort order rather than the explicit\n        // sort order, because it's guaranteed to contain the document key. That way\n        // the position becomes unambiguous and the query continues/ends exactly at\n        // the provided document. Without the key (by using the explicit sort\n        // orders), multiple documents could match the position, yielding duplicate\n        // results.\n        for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            if (orderBy.field.isKeyField()) {\n                components.push(new RefValue(this.firestore._databaseId, doc.key));\n            }\n            else {\n                var value = doc.field(orderBy.field);\n                if (value !== undefined) {\n                    components.push(value);\n                }\n                else {\n                    var field = orderBy.field.canonicalString();\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a \" +\n                        (\"document for which the field '\" + field + \"' (used as the \") +\n                        \"orderBy) does not exist.\");\n                }\n            }\n        }\n        return new Bound(components, before);\n    };\n    /**\n     * Converts a list of field values to a Bound for the given query.\n     */\n    Query.prototype.boundFromFields = function (methodName, values, before) {\n        // Use explicit order by's because it has to match the query the user made\n        var orderBy = this._query.explicitOrderBy;\n        if (values.length > orderBy.length) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"(). \" +\n                \"The number of arguments must be less than or equal to the \" +\n                \"number of Query.orderBy() clauses\");\n        }\n        var components = [];\n        for (var i = 0; i < values.length; i++) {\n            var rawValue = values[i];\n            var orderByComponent = orderBy[i];\n            if (orderByComponent.field.isKeyField()) {\n                if (typeof rawValue !== 'string') {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" +\n                        (methodName + \"(), but got a \" + typeof rawValue));\n                }\n                if (rawValue.indexOf('/') !== -1) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Document ID '\" + rawValue + \"' contains a slash in \" +\n                        (methodName + \"()\"));\n                }\n                var key = new DocumentKey(this._query.path.child(rawValue));\n                components.push(new RefValue(this.firestore._databaseId, key));\n            }\n            else {\n                var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);\n                components.push(wrapped);\n            }\n        }\n        return new Bound(components, before);\n    };\n    Query.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n        var options = {};\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('Query.onSnapshot', options, [\n                'includeQueryMetadataChanges',\n                'includeDocumentMetadataChanges'\n            ]);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeDocumentMetadataChanges', options.includeDocumentMetadataChanges);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeQueryMetadataChanges', options.includeQueryMetadataChanges);\n            currArg++;\n        }\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(options, observer);\n    };\n    Query.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (result) {\n                if (observer.next) {\n                    observer.next(new QuerySnapshot(_this.firestore, _this._query, result));\n                }\n            },\n            error: errHandler\n        });\n        var firestoreClient = this.firestore.ensureClientConfigured();\n        var internalListener = firestoreClient.listen(this._query, asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            firestoreClient.unlisten(internalListener);\n        };\n    };\n    Query.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('Query.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeDocumentMetadataChanges: false,\n                includeQueryMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (result) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    resolve(result);\n                },\n                error: reject\n            });\n        });\n    };\n    Query.prototype.validateNewFilter = function (filter) {\n        if (filter instanceof RelationFilter && filter.isInequality()) {\n            var existingField = this._query.getInequalityFilterField();\n            if (existingField !== null && !existingField.equals(filter.field)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' +\n                    ' (<, <=, >, or >=) must be on the same field. But you have' +\n                    (\" inequality filters on '\" + existingField.toString() + \"'\") +\n                    (\" and '\" + filter.field.toString() + \"'\"));\n            }\n            var firstOrderByField = this._query.getFirstOrderByField();\n            if (firstOrderByField !== null) {\n                this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);\n            }\n        }\n    };\n    Query.prototype.validateNewOrderBy = function (orderBy) {\n        if (this._query.getFirstOrderByField() === null) {\n            // This is the first order by. It must match any inequality.\n            var inequalityField = this._query.getInequalityFilterField();\n            if (inequalityField !== null) {\n                this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n            }\n        }\n    };\n    Query.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) {\n        if (!orderBy.equals(inequality)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality \" +\n                (\"(<, <=, >, or >=) on field '\" + inequality.toString() + \"' \") +\n                (\"and so you must also use '\" + inequality.toString() + \"' \") +\n                \"as your first Query.orderBy(), but your first Query.orderBy() \" +\n                (\"is on field '\" + orderBy.toString() + \"' instead.\"));\n        }\n    };\n    return Query;\n}());\nexport { Query };\nvar QuerySnapshot = /** @class */ (function () {\n    function QuerySnapshot(_firestore, _originalQuery, _snapshot) {\n        this._firestore = _firestore;\n        this._originalQuery = _originalQuery;\n        this._snapshot = _snapshot;\n        this._cachedChanges = null;\n        this.metadata = {\n            fromCache: _snapshot.fromCache,\n            hasPendingWrites: _snapshot.hasPendingWrites\n        };\n    }\n    Object.defineProperty(QuerySnapshot.prototype, \"docs\", {\n        get: function () {\n            var result = [];\n            this.forEach(function (doc) { return result.push(doc); });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"empty\", {\n        get: function () {\n            return this._snapshot.docs.isEmpty();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"size\", {\n        get: function () {\n            return this._snapshot.docs.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QuerySnapshot.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n        validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n        this._snapshot.docs.forEach(function (doc) {\n            callback.call(thisArg, _this.convertToDocumentImpl(doc));\n        });\n    };\n    Object.defineProperty(QuerySnapshot.prototype, \"query\", {\n        get: function () {\n            return new Query(this._originalQuery, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"docChanges\", {\n        get: function () {\n            if (!this._cachedChanges) {\n                this._cachedChanges = changesFromSnapshot(this._firestore, this._snapshot);\n            }\n            return this._cachedChanges;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QuerySnapshot.prototype.convertToDocumentImpl = function (doc) {\n        return new DocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);\n    };\n    return QuerySnapshot;\n}());\nexport { QuerySnapshot };\nvar CollectionReference = /** @class */ (function (_super) {\n    __extends(CollectionReference, _super);\n    function CollectionReference(path, firestore) {\n        var _this = _super.call(this, InternalQuery.atPath(path), firestore) || this;\n        if (path.length % 2 !== 1) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' +\n                'references must have an odd number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return _this;\n    }\n    Object.defineProperty(CollectionReference.prototype, \"id\", {\n        get: function () {\n            return this._query.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"parent\", {\n        get: function () {\n            var parentPath = this._query.path.popLast();\n            if (parentPath.isEmpty()) {\n                return null;\n            }\n            else {\n                return new DocumentReference(new DocumentKey(parentPath), this.firestore);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"path\", {\n        get: function () {\n            return this._query.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CollectionReference.prototype.doc = function (pathString) {\n        validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);\n        // We allow omission of 'pathString' but explicitly prohibit passing in both\n        // 'undefined' and 'null'.\n        if (arguments.length === 0) {\n            pathString = AutoId.newId();\n        }\n        validateArgType('CollectionReference.doc', 'string', 1, pathString);\n        if (pathString === '') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');\n        }\n        var path = ResourcePath.fromString(pathString);\n        return DocumentReference.forPath(this._query.path.child(path), this.firestore);\n    };\n    CollectionReference.prototype.add = function (value) {\n        validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n        validateArgType('CollectionReference.add', 'object', 1, value);\n        var docRef = this.doc();\n        return docRef.set(value).then(function () { return docRef; });\n    };\n    return CollectionReference;\n}(Query));\nexport { CollectionReference };\nfunction validateSetOptions(methodName, options) {\n    if (options === undefined) {\n        return {\n            merge: false\n        };\n    }\n    validateOptionNames(methodName, options, ['merge']);\n    validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n    return options;\n}\nfunction validateReference(methodName, documentRef, firestore) {\n    if (!(documentRef instanceof DocumentReference)) {\n        throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n    }\n    else if (documentRef.firestore !== firestore) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\nexport function changesFromSnapshot(firestore, snapshot) {\n    if (snapshot.oldDocs.isEmpty()) {\n        // Special case the first snapshot because index calculation is easy and\n        // fast\n        var lastDoc_1;\n        var index_1 = 0;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');\n            assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');\n            lastDoc_1 = change.doc;\n            return {\n                type: 'added',\n                doc: doc,\n                oldIndex: -1,\n                newIndex: index_1++\n            };\n        });\n    }\n    else {\n        // A DocumentSet that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        var indexTracker_1 = snapshot.oldDocs;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            var oldIndex = -1;\n            var newIndex = -1;\n            if (change.type !== ChangeType.Added) {\n                oldIndex = indexTracker_1.indexOf(change.doc.key);\n                assert(oldIndex >= 0, 'Index for document not found');\n                indexTracker_1 = indexTracker_1.delete(change.doc.key);\n            }\n            if (change.type !== ChangeType.Removed) {\n                indexTracker_1 = indexTracker_1.add(change.doc);\n                newIndex = indexTracker_1.indexOf(change.doc.key);\n            }\n            return { type: resultChangeType(change.type), doc: doc, oldIndex: oldIndex, newIndex: newIndex };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case ChangeType.Added:\n            return 'added';\n        case ChangeType.Modified:\n        case ChangeType.Metadata:\n            return 'modified';\n        case ChangeType.Removed:\n            return 'removed';\n        default:\n            return fail('Unknown change type: ' + type);\n    }\n}\n// Export the classes with a private constructor (it will fail if invoked\n// at runtime). Note that this still allows instanceof checks.\n// We're treating the variables as class names, so disable checking for lower\n// case variable names.\n// tslint:disable:variable-name\nexport var PublicFirestore = makeConstructorPrivate(Firestore, 'Use firebase.firestore() instead.');\nexport var PublicTransaction = makeConstructorPrivate(Transaction, 'Use firebase.firestore().runTransaction() instead.');\nexport var PublicWriteBatch = makeConstructorPrivate(WriteBatch, 'Use firebase.firestore().batch() instead.');\nexport var PublicDocumentReference = makeConstructorPrivate(DocumentReference, 'Use firebase.firestore().doc() instead.');\nexport var PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);\nexport var PublicQuery = makeConstructorPrivate(Query);\nexport var PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);\nexport var PublicCollectionReference = makeConstructorPrivate(CollectionReference, 'Use firebase.firestore().collection() instead.');\n// tslint:enable:variable-name\n\n//# sourceMappingURL=database.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/database.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PublicBlob } from '../api/blob';\nimport { Firestore, PublicCollectionReference, PublicDocumentReference, PublicDocumentSnapshot, PublicFirestore, PublicQuery, PublicQuerySnapshot, PublicTransaction, PublicWriteBatch } from '../api/database';\nimport { FieldPath } from '../api/field_path';\nimport { PublicFieldValue } from '../api/field_value';\nimport { GeoPoint } from '../api/geo_point';\nimport { shallowCopy } from '../util/obj';\nvar firestoreNamespace = {\n    Firestore: PublicFirestore,\n    GeoPoint: GeoPoint,\n    Blob: PublicBlob,\n    Transaction: PublicTransaction,\n    WriteBatch: PublicWriteBatch,\n    DocumentReference: PublicDocumentReference,\n    DocumentSnapshot: PublicDocumentSnapshot,\n    Query: PublicQuery,\n    QuerySnapshot: PublicQuerySnapshot,\n    CollectionReference: PublicCollectionReference,\n    FieldPath: FieldPath,\n    FieldValue: PublicFieldValue,\n    setLogLevel: Firestore.setLogLevel\n};\n/**\n * Configures Firestore as part of the Firebase SDK by calling registerService.\n */\nexport function configureForFirebase(firebase) {\n    firebase.INTERNAL.registerService('firestore', function (app) { return new Firestore(app); }, shallowCopy(firestoreNamespace));\n}\n/**\n * Exports the Firestore namespace into the provided `exportObject` object under\n * the key 'firestore'. This is used for wrapped binary that exposes Firestore\n * as a goog module.\n */\nexport function configureForStandalone(exportObject) {\n    var copiedNamespace = shallowCopy(firestoreNamespace);\n    // Unlike the use with Firebase, the standalone allows the use of the\n    // constructor, so export it's internal class\n    copiedNamespace['Firestore'] = Firestore;\n    exportObject['firestore'] = copiedNamespace;\n}\n\n//# sourceMappingURL=config.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform/config.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport firebase from '@firebase/app';\nimport './src/platform_browser/browser_init';\nimport { configureForFirebase } from './src/platform/config';\nexport function registerFirestore(instance) {\n    configureForFirebase(instance);\n}\nregisterFirestore(firebase);\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/index.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport firebase from '@firebase/app';\n/** The semver (www.semver.org) version of the SDK. */\nexport var SDK_VERSION = firebase.SDK_VERSION;\n\n//# sourceMappingURL=version.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/version.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n// TODO(mcg): Change to a string enum once we've upgraded to typescript 2.4.\n//  tslint:disable-next-line:variable-name Intended to look like a TS 2.4 enum\nexport var Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */\n    OK: 'ok',\n    /** The operation was cancelled (typically by the caller). */\n    CANCELLED: 'cancelled',\n    /** Unknown error or an error from a different error domain. */\n    UNKNOWN: 'unknown',\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    INVALID_ARGUMENT: 'invalid-argument',\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\n    /** Some requested entity (e.g., file or directory) was not found. */\n    NOT_FOUND: 'not-found',\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    ALREADY_EXISTS: 'already-exists',\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller can not be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    PERMISSION_DENIED: 'permission-denied',\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    UNAUTHENTICATED: 'unauthenticated',\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operation's execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    FAILED_PRECONDITION: 'failed-precondition',\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    ABORTED: 'aborted',\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    OUT_OF_RANGE: 'out-of-range',\n    /** Operation is not implemented or not supported/enabled in this service. */\n    UNIMPLEMENTED: 'unimplemented',\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    INTERNAL: 'internal',\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    UNAVAILABLE: 'unavailable',\n    /** Unrecoverable data loss or corruption. */\n    DATA_LOSS: 'data-loss'\n};\n/**\n * An error class used for Firestore-generated errors. Ideally we should be\n * using FirebaseError, but integrating with it is overly arduous at the moment,\n * so we define our own compatible error class (with a `name` of 'FirebaseError'\n * and compatible `code` and `message` fields.)\n */\nvar FirestoreError = /** @class */ (function (_super) {\n    __extends(FirestoreError, _super);\n    function FirestoreError(code, message) {\n        var _this = _super.call(this, message) || this;\n        _this.code = code;\n        _this.message = message;\n        _this.name = 'FirebaseError';\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        _this.toString = function () { return _this.name + \": [code=\" + _this.code + \"]: \" + _this.message; };\n        return _this;\n    }\n    return FirestoreError;\n}(Error));\nexport { FirestoreError };\n\n//# sourceMappingURL=error.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/error.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Code, FirestoreError } from '../util/error';\nimport { validateArgType, validateExactNumberOfArgs } from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\n/**\n * Immutable class representing a geo point as latitude-longitude pair.\n * This class is directly exposed in the public API, including its constructor.\n */\nvar GeoPoint = /** @class */ (function () {\n    function GeoPoint(latitude, longitude) {\n        validateExactNumberOfArgs('GeoPoint', arguments, 2);\n        validateArgType('GeoPoint', 'number', 1, latitude);\n        validateArgType('GeoPoint', 'number', 2, longitude);\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    Object.defineProperty(GeoPoint.prototype, \"latitude\", {\n        /**\n         * Returns the latitude of this geo point, a number between -90 and 90.\n         */\n        get: function () {\n            return this._lat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GeoPoint.prototype, \"longitude\", {\n        /**\n         * Returns the longitude of this geo point, a number between -180 and 180.\n         */\n        get: function () {\n            return this._long;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    GeoPoint.prototype._equals = function (other) {\n        return this._lat === other._lat && this._long === other._long;\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    GeoPoint.prototype._compareTo = function (other) {\n        return (primitiveComparator(this._lat, other._lat) ||\n            primitiveComparator(this._long, other._long));\n    };\n    return GeoPoint;\n}());\nexport { GeoPoint };\n\n//# sourceMappingURL=geo_point.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/geo_point.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { primitiveComparator } from '../util/misc';\nvar DatabaseInfo = /** @class */ (function () {\n    /**\n     * Constructs a DatabaseInfo using the provided host, databaseId and\n     * persistenceKey.\n     *\n     * @param databaseId The database to use.\n     * @param persistenceKey A unique identifier for this Firestore's local\n     * storage (used in conjunction with the databaseId).\n     * @param host The Firestore backend host to connect to.\n     * @param ssl Whether to use SSL when connecting.\n     */\n    function DatabaseInfo(databaseId, persistenceKey, host, ssl) {\n        this.databaseId = databaseId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n    }\n    return DatabaseInfo;\n}());\nexport { DatabaseInfo };\n/** The default database name for a project. */\nvar DEFAULT_DATABASE_NAME = '(default)';\n/** Represents the database ID a Firestore client is associated with. */\nvar DatabaseId = /** @class */ (function () {\n    function DatabaseId(projectId, database) {\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    Object.defineProperty(DatabaseId.prototype, \"isDefaultDatabase\", {\n        get: function () {\n            return this.database === DEFAULT_DATABASE_NAME;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DatabaseId.prototype.equals = function (other) {\n        return (other instanceof DatabaseId &&\n            other.projectId === this.projectId &&\n            other.database === this.database);\n    };\n    DatabaseId.prototype.compareTo = function (other) {\n        return (primitiveComparator(this.projectId, other.projectId) ||\n            primitiveComparator(this.database, other.database));\n    };\n    return DatabaseId;\n}());\nexport { DatabaseId };\n\n//# sourceMappingURL=database_info.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/database_info.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nexport var DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nvar Path = /** @class */ (function () {\n    function Path(segments, offset, length) {\n        this.init(segments, offset, length);\n    }\n    /**\n     * An initialization method that can be called from outside the constructor.\n     * We need this so that we can have a non-static construct method that returns\n     * the polymorphic `this` type.\n     */\n    Path.prototype.init = function (segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail('offset ' + offset + ' out of range ' + segments.length);\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail('length ' + length + ' out of range ' + (segments.length - offset));\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    };\n    /**\n     * Constructs a new instance of Path using the same concrete type as `this`.\n     * We need this instead of using the normal constructor, because polymorphic\n     * `this` doesn't work on static methods.\n     */\n    Path.prototype.construct = function (segments, offset, length) {\n        var path = Object.create(Object.getPrototypeOf(this));\n        path.init(segments, offset, length);\n        return path;\n    };\n    Object.defineProperty(Path.prototype, \"length\", {\n        get: function () {\n            return this.len;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path.prototype.equals = function (other) {\n        return Path.comparator(this, other) === 0;\n    };\n    Path.prototype.child = function (nameOrPath) {\n        var segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof Path) {\n            nameOrPath.forEach(function (segment) {\n                segments.push(segment);\n            });\n        }\n        else if (typeof nameOrPath === 'string') {\n            segments.push(nameOrPath);\n        }\n        else {\n            fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n        }\n        return this.construct(segments);\n    };\n    /** The index of one past the last segment of the path. */\n    Path.prototype.limit = function () {\n        return this.offset + this.length;\n    };\n    Path.prototype.popFirst = function (size) {\n        size = size === undefined ? 1 : size;\n        assert(this.length >= size, \"Can't call popFirst() with less segments\");\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    };\n    Path.prototype.popLast = function () {\n        assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n        return this.construct(this.segments, this.offset, this.length - 1);\n    };\n    Path.prototype.firstSegment = function () {\n        assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n        return this.segments[this.offset];\n    };\n    Path.prototype.lastSegment = function () {\n        assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n        return this.segments[this.limit() - 1];\n    };\n    Path.prototype.get = function (index) {\n        assert(index < this.length, 'Index out of range');\n        return this.segments[this.offset + index];\n    };\n    Path.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    Path.prototype.isPrefixOf = function (other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Path.prototype.forEach = function (fn) {\n        for (var i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    };\n    Path.prototype.toArray = function () {\n        return this.segments.slice(this.offset, this.limit());\n    };\n    Path.comparator = function (p1, p2) {\n        var len = Math.min(p1.length, p2.length);\n        for (var i = 0; i < len; i++) {\n            var left = p1.get(i);\n            var right = p2.get(i);\n            if (left < right)\n                return -1;\n            if (left > right)\n                return 1;\n        }\n        if (p1.length < p2.length)\n            return -1;\n        if (p1.length > p2.length)\n            return 1;\n        return 0;\n    };\n    return Path;\n}());\nexport { Path };\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nvar ResourcePath = /** @class */ (function (_super) {\n    __extends(ResourcePath, _super);\n    function ResourcePath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourcePath.prototype.canonicalString = function () {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    };\n    ResourcePath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Creates a resource path from the given slash-delimited string.\n     */\n    ResourcePath.fromString = function (path) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        if (path.indexOf('//') >= 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid path (\" + path + \"). Paths must not contain // in them.\");\n        }\n        // We may still have an empty segment at the beginning or end if they had a\n        // leading or trailing slash (which we allow).\n        var segments = path.split('/').filter(function (segment) { return segment.length > 0; });\n        return new ResourcePath(segments);\n    };\n    ResourcePath.EMPTY_PATH = new ResourcePath([]);\n    return ResourcePath;\n}(Path));\nexport { ResourcePath };\nvar identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/** A dot-separated path for navigating sub-objects within a document. */\nvar FieldPath = /** @class */ (function (_super) {\n    __extends(FieldPath, _super);\n    function FieldPath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    FieldPath.isValidIdentifier = function (segment) {\n        return identifierRegExp.test(segment);\n    };\n    FieldPath.prototype.canonicalString = function () {\n        return this.toArray()\n            .map(function (str) {\n            str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n            if (!FieldPath.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    };\n    FieldPath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    FieldPath.prototype.isKeyField = function () {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    };\n    /**\n     * The field designating the key of a document.\n     */\n    FieldPath.keyField = function () {\n        return new FieldPath([DOCUMENT_KEY_NAME]);\n    };\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    FieldPath.fromServerFormat = function (path) {\n        var segments = [];\n        var current = '';\n        var i = 0;\n        var addCurrentSegment = function () {\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, begin \" +\n                    \"with '.', end with '.', or contain '..'\");\n            }\n            segments.push(current);\n            current = '';\n        };\n        var inBackticks = false;\n        while (i < path.length) {\n            var c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                var next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath(segments);\n    };\n    FieldPath.EMPTY_PATH = new FieldPath([]);\n    return FieldPath;\n}(Path));\nexport { FieldPath };\n\n//# sourceMappingURL=path.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/path.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { ResourcePath } from './path';\nvar DocumentKey = /** @class */ (function () {\n    function DocumentKey(path) {\n        this.path = path;\n        assert(DocumentKey.isDocumentKey(path), 'Invalid DocumentKey with an odd number of segments: ' +\n            path.toArray().join('/'));\n    }\n    DocumentKey.prototype.equals = function (other) {\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\n    };\n    DocumentKey.prototype.toString = function () {\n        return this.path.toString();\n    };\n    DocumentKey.comparator = function (k1, k2) {\n        return ResourcePath.comparator(k1.path, k2.path);\n    };\n    DocumentKey.isDocumentKey = function (path) {\n        return path.length % 2 === 0;\n    };\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param path The segments of the path to the document\n     * @return A new instance of DocumentKey\n     */\n    DocumentKey.fromSegments = function (segments) {\n        return new DocumentKey(new ResourcePath(segments.slice()));\n    };\n    /**\n     * Creates and returns a new document key using '/' to split the string into\n     * segments.\n     *\n     * @param path The slash-separated path string to the document\n     * @return A new instance of DocumentKey\n     */\n    DocumentKey.fromPathString = function (path) {\n        return new DocumentKey(ResourcePath.fromString(path));\n    };\n    DocumentKey.EMPTY = new DocumentKey(new ResourcePath([]));\n    return DocumentKey;\n}());\nexport { DocumentKey };\n\n//# sourceMappingURL=document_key.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/document_key.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\nimport { DocumentKey } from './document_key';\nvar Document = /** @class */ (function () {\n    function Document(key, version, data, options) {\n        this.key = key;\n        this.version = version;\n        this.data = data;\n        this.hasLocalMutations = options.hasLocalMutations;\n    }\n    Document.prototype.field = function (path) {\n        return this.data.field(path);\n    };\n    Document.prototype.fieldValue = function (path) {\n        var field = this.field(path);\n        return field ? field.value() : undefined;\n    };\n    Document.prototype.value = function () {\n        return this.data.value();\n    };\n    Document.prototype.equals = function (other) {\n        return (other instanceof Document &&\n            this.key.equals(other.key) &&\n            this.version.equals(other.version) &&\n            this.data.equals(other.data) &&\n            this.hasLocalMutations === other.hasLocalMutations);\n    };\n    Document.prototype.toString = function () {\n        return (\"Document(\" + this.key + \", \" + this.version + \", \" + this.data.toString() + \", \" +\n            (\"{hasLocalMutations: \" + this.hasLocalMutations + \"})\"));\n    };\n    Document.compareByKey = function (d1, d2) {\n        return DocumentKey.comparator(d1.key, d2.key);\n    };\n    Document.compareByField = function (field, d1, d2) {\n        var v1 = d1.field(field);\n        var v2 = d2.field(field);\n        if (v1 !== undefined && v2 !== undefined) {\n            return v1.compareTo(v2);\n        }\n        else {\n            return fail(\"Trying to compare documents on fields that don't exist\");\n        }\n    };\n    return Document;\n}());\nexport { Document };\n/**\n * A class representing a deleted document.\n * Version is set to 0 if we don't point to any specific time, otherwise it\n * denotes time we know it didn't exist at.\n */\nvar NoDocument = /** @class */ (function () {\n    function NoDocument(key, version) {\n        this.key = key;\n        this.version = version;\n    }\n    NoDocument.prototype.toString = function () {\n        return \"NoDocument(\" + this.key + \", \" + this.version + \")\";\n    };\n    NoDocument.prototype.equals = function (other) {\n        return (other && other.version.equals(this.version) && other.key.equals(this.key));\n    };\n    NoDocument.compareByKey = function (d1, d2) {\n        return DocumentKey.comparator(d1.key, d2.key);\n    };\n    return NoDocument;\n}());\nexport { NoDocument };\n\n//# sourceMappingURL=document.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/document.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert, fail } from './assert';\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nvar SortedMap = /** @class */ (function () {\n    function SortedMap(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    SortedMap.prototype.insert = function (key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    };\n    // Returns a copy of the map, with the specified key removed.\n    SortedMap.prototype.remove = function (key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    };\n    // Returns the value of the node with the given key, or null.\n    SortedMap.prototype.get = function (key) {\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    };\n    // Returns the key of the item *before* the specified key, or null if key is\n    // the first item.\n    SortedMap.prototype.getPredecessorKey = function (key) {\n        var node = this.root;\n        var rightParent = null;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                if (!node.left.isEmpty()) {\n                    node = node.left;\n                    while (!node.right.isEmpty())\n                        node = node.right;\n                    return node.key;\n                }\n                else if (rightParent) {\n                    return rightParent.key;\n                }\n                else {\n                    return null; // first item.\n                }\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                rightParent = node;\n                node = node.right;\n            }\n        }\n        throw fail('Attempted to find predecessor key for a nonexistent key.' +\n            '  What gives?');\n    };\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    SortedMap.prototype.indexOf = function (key) {\n        // Number of nodes that were pruned when descending right\n        var prunedNodes = 0;\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    };\n    SortedMap.prototype.isEmpty = function () {\n        return this.root.isEmpty();\n    };\n    Object.defineProperty(SortedMap.prototype, \"size\", {\n        // Returns the total number of nodes in the map.\n        get: function () {\n            return this.root.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Returns the minimum key in the map.\n    SortedMap.prototype.minKey = function () {\n        return this.root.minKey();\n    };\n    // Returns the maximum key in the map.\n    SortedMap.prototype.maxKey = function () {\n        return this.root.maxKey();\n    };\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.inorderTraversal = function (action) {\n        return this.root.inorderTraversal(action);\n    };\n    SortedMap.prototype.forEach = function (fn) {\n        this.inorderTraversal(function (k, v) {\n            fn(k, v);\n            return false;\n        });\n    };\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.reverseTraversal = function (action) {\n        return this.root.reverseTraversal(action);\n    };\n    SortedMap.prototype.getIterator = function (resultGenerator) {\n        return new SortedMapIterator(this.root, null, this.comparator, false, resultGenerator);\n    };\n    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {\n        return new SortedMapIterator(this.root, key, this.comparator, false, resultGenerator);\n    };\n    SortedMap.prototype.getReverseIterator = function (resultGenerator) {\n        return new SortedMapIterator(this.root, null, this.comparator, true, resultGenerator);\n    };\n    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {\n        return new SortedMapIterator(this.root, key, this.comparator, true, resultGenerator);\n    };\n    return SortedMap;\n}()); // end SortedMap\nexport { SortedMap };\n// An iterator over an LLRBNode.\nvar SortedMapIterator = /** @class */ (function () {\n    function SortedMapIterator(node, startKey, comparator, isReverse, resultGenerator) {\n        this.resultGenerator = resultGenerator || null;\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        var cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse)\n                cmp *= -1;\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    SortedMapIterator.prototype.getNext = function () {\n        assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');\n        var node = this.nodeStack.pop();\n        var result;\n        if (this.resultGenerator)\n            result = this.resultGenerator(node.key, node.value);\n        else\n            result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    };\n    SortedMapIterator.prototype.hasNext = function () {\n        return this.nodeStack.length > 0;\n    };\n    SortedMapIterator.prototype.peek = function () {\n        if (this.nodeStack.length === 0)\n            return null;\n        var node = this.nodeStack[this.nodeStack.length - 1];\n        if (this.resultGenerator) {\n            return this.resultGenerator(node.key, node.value);\n        }\n        else {\n            return { key: node.key, value: node.value };\n        }\n    };\n    return SortedMapIterator;\n}()); // end SortedMapIterator\nexport { SortedMapIterator };\n// Represents a node in a Left-leaning Red-Black tree.\nvar LLRBNode = /** @class */ (function () {\n    function LLRBNode(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    LLRBNode.prototype.copy = function (key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    };\n    LLRBNode.prototype.isEmpty = function () {\n        return false;\n    };\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.inorderTraversal = function (action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    };\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.reverseTraversal = function (action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    };\n    // Returns the minimum node in the tree.\n    LLRBNode.prototype.min = function () {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.minKey = function () {\n        return this.min().key;\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.maxKey = function () {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    };\n    // Returns new tree, with the key/value added.\n    LLRBNode.prototype.insert = function (key, value, comparator) {\n        var n = this;\n        var cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.removeMin = function () {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        var n = this;\n        if (!n.left.isRed() && !n.left.left.isRed())\n            n = n.moveRedLeft();\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    };\n    // Returns new tree, with the specified item removed.\n    LLRBNode.prototype.remove = function (key, comparator) {\n        var smallest;\n        var n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed())\n                n = n.rotateRight();\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.isRed = function () {\n        return this.color;\n    };\n    // Returns new tree after performing any needed rotations.\n    LLRBNode.prototype.fixUp = function () {\n        var n = this;\n        if (n.right.isRed() && !n.left.isRed())\n            n = n.rotateLeft();\n        if (n.left.isRed() && n.left.left.isRed())\n            n = n.rotateRight();\n        if (n.left.isRed() && n.right.isRed())\n            n = n.colorFlip();\n        return n;\n    };\n    LLRBNode.prototype.moveRedLeft = function () {\n        var n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.moveRedRight = function () {\n        var n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.rotateLeft = function () {\n        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    };\n    LLRBNode.prototype.rotateRight = function () {\n        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    };\n    LLRBNode.prototype.colorFlip = function () {\n        var left = this.left.copy(null, null, !this.left.color, null, null);\n        var right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    };\n    // For testing.\n    LLRBNode.prototype.checkMaxDepth = function () {\n        var blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    LLRBNode.prototype.check = function () {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n        }\n        if (this.right.isRed()) {\n            throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n        }\n        var blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail('Black depths differ');\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    };\n    LLRBNode.EMPTY = null;\n    LLRBNode.RED = true;\n    LLRBNode.BLACK = false;\n    return LLRBNode;\n}()); // end LLRBNode\nexport { LLRBNode };\n// Represents an empty node (a leaf node in the Red-Black Tree).\nvar LLRBEmptyNode = /** @class */ (function () {\n    function LLRBEmptyNode() {\n        this.size = 0;\n    }\n    // Returns a copy of the current node.\n    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\n        return this;\n    };\n    // Returns a copy of the tree, with the specified key/value added.\n    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\n        return new LLRBNode(key, value);\n    };\n    // Returns a copy of the tree, with the specified key removed.\n    LLRBEmptyNode.prototype.remove = function (key, comparator) {\n        return this;\n    };\n    LLRBEmptyNode.prototype.isEmpty = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.inorderTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.reverseTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.minKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.maxKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.isRed = function () {\n        return false;\n    };\n    // For testing.\n    LLRBEmptyNode.prototype.checkMaxDepth = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.check = function () {\n        return 0;\n    };\n    return LLRBEmptyNode;\n}()); // end LLRBEmptyNode\nexport { LLRBEmptyNode };\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n//# sourceMappingURL=sorted_map.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/sorted_map.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { emptyByteString } from '../platform/platform';\n/** An enumeration of the different purposes we have for queries. */\nexport var QueryPurpose;\n(function (QueryPurpose) {\n    /** A regular, normal query. */\n    QueryPurpose[QueryPurpose[\"Listen\"] = 0] = \"Listen\";\n    /**\n     * The query was used to refill a query after an existence filter mismatch.\n     */\n    QueryPurpose[QueryPurpose[\"ExistenceFilterMismatch\"] = 1] = \"ExistenceFilterMismatch\";\n    /** The query was used to resolve a limbo document. */\n    QueryPurpose[QueryPurpose[\"LimboResolution\"] = 2] = \"LimboResolution\";\n})(QueryPurpose = QueryPurpose || (QueryPurpose = {}));\n/**\n * An immutable set of metadata that the local store tracks for each query.\n */\nvar QueryData = /** @class */ (function () {\n    function QueryData(\n        /** The query being listened to. */\n        query, \n        /**\n         * The target ID to which the query corresponds; Assigned by the\n         * LocalStore for user listens and by the SyncEngine for limbo watches.\n         */\n        targetId, \n        /** The purpose of the query. */\n        purpose, \n        /** The latest snapshot version seen for this target. */\n        snapshotVersion, \n        /**\n         * An opaque, server-assigned token that allows watching a query to be\n         * resumed after disconnecting without retransmitting all the data that\n         * matches the query. The resume token essentially identifies a point in\n         * time from which the server should resume sending results.\n         */\n        resumeToken) {\n        if (snapshotVersion === void 0) { snapshotVersion = SnapshotVersion.MIN; }\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        this.query = query;\n        this.targetId = targetId;\n        this.purpose = purpose;\n        this.snapshotVersion = snapshotVersion;\n        this.resumeToken = resumeToken;\n    }\n    /**\n     * Creates a new query data instance with an updated snapshot version and\n     * resume token.\n     */\n    QueryData.prototype.update = function (updated) {\n        return new QueryData(this.query, this.targetId, this.purpose, updated.snapshotVersion, updated.resumeToken);\n    };\n    QueryData.prototype.equals = function (other) {\n        return (this.targetId === other.targetId &&\n            this.purpose === other.purpose &&\n            this.snapshotVersion.equals(other.snapshotVersion) &&\n            this.resumeToken === other.resumeToken &&\n            this.query.equals(other.query));\n    };\n    return QueryData;\n}());\nexport { QueryData };\n\n//# sourceMappingURL=query_data.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/query_data.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nvar isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\nvar Timestamp = /** @class */ (function () {\n    function Timestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n        assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n        assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos);\n        // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n        assert(seconds >= -62135596800, 'timestamp seconds out of range: ' + seconds);\n        // This will break in the year 10,000.\n        assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n    }\n    Timestamp.now = function () {\n        return Timestamp.fromEpochMilliseconds(Date.now());\n    };\n    Timestamp.fromDate = function (date) {\n        return Timestamp.fromEpochMilliseconds(date.getTime());\n    };\n    Timestamp.fromEpochMilliseconds = function (milliseconds) {\n        var seconds = Math.floor(milliseconds / 1000);\n        var nanos = (milliseconds - seconds * 1000) * 1e6;\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.fromISOString = function (utc) {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        var nanos = 0;\n        var fraction = isoRegExp.exec(utc);\n        assert(!!fraction, 'invalid timestamp: ' + utc);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            var nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = parseInt(nanoStr, 10);\n        }\n        // Parse the date to get the seconds.\n        var date = new Date(utc);\n        var seconds = Math.floor(date.getTime() / 1000);\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.prototype.toDate = function () {\n        return new Date(this.toEpochMilliseconds());\n    };\n    Timestamp.prototype.toEpochMilliseconds = function () {\n        return this.seconds * 1000 + this.nanos / 1e6;\n    };\n    Timestamp.prototype.compareTo = function (other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanos, other.nanos);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    };\n    Timestamp.prototype.equals = function (other) {\n        return other.seconds === this.seconds && other.nanos === this.nanos;\n    };\n    Timestamp.prototype.toString = function () {\n        return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n    };\n    return Timestamp;\n}());\nexport { Timestamp };\n\n//# sourceMappingURL=timestamp.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/timestamp.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Timestamp } from './timestamp';\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nvar SnapshotVersion = /** @class */ (function () {\n    function SnapshotVersion(timestamp) {\n        this.timestamp = timestamp;\n    }\n    // TODO(b/34176344): Once we no longer need to use the old alpha protos,\n    // delete this constructor and use a timestamp-backed version everywhere.\n    SnapshotVersion.fromMicroseconds = function (value) {\n        var seconds = Math.floor(value / 1e6);\n        var nanos = (value % 1e6) * 1e3;\n        return new SnapshotVersion(new Timestamp(seconds, nanos));\n    };\n    SnapshotVersion.fromTimestamp = function (value) {\n        return new SnapshotVersion(value);\n    };\n    SnapshotVersion.forDeletedDoc = function () {\n        return SnapshotVersion.MIN;\n    };\n    SnapshotVersion.prototype.compareTo = function (other) {\n        return this.timestamp.compareTo(other.timestamp);\n    };\n    SnapshotVersion.prototype.equals = function (other) {\n        return this.timestamp.equals(other.timestamp);\n    };\n    /** Returns a number representation of the version for use in spec tests. */\n    SnapshotVersion.prototype.toMicroseconds = function () {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanos / 1000;\n    };\n    SnapshotVersion.prototype.toString = function () {\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n    };\n    SnapshotVersion.prototype.toTimestamp = function () {\n        return this.timestamp;\n    };\n    SnapshotVersion.MIN = new SnapshotVersion(new Timestamp(0, 0));\n    return SnapshotVersion;\n}());\nexport { SnapshotVersion };\n\n//# sourceMappingURL=snapshot_version.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/snapshot_version.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { assert, fail } from '../util/assert';\nimport * as misc from '../util/misc';\nimport { Document, NoDocument } from './document';\nimport { ObjectValue, ServerTimestampValue } from './field_value';\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nvar FieldMask = /** @class */ (function () {\n    function FieldMask(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n    }\n    FieldMask.prototype.equals = function (other) {\n        return misc.arrayEquals(this.fields, other.fields);\n    };\n    return FieldMask;\n}());\nexport { FieldMask };\n/** Transforms a value into a server-generated timestamp. */\nvar ServerTimestampTransform = /** @class */ (function () {\n    function ServerTimestampTransform() {\n    }\n    ServerTimestampTransform.prototype.equals = function (other) {\n        return other instanceof ServerTimestampTransform;\n    };\n    ServerTimestampTransform.instance = new ServerTimestampTransform();\n    return ServerTimestampTransform;\n}());\nexport { ServerTimestampTransform };\n/** A field path and the TransformOperation to perform upon it. */\nvar FieldTransform = /** @class */ (function () {\n    function FieldTransform(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n    FieldTransform.prototype.equals = function (other) {\n        return (this.field.equals(other.field) && this.transform.equals(other.transform));\n    };\n    return FieldTransform;\n}());\nexport { FieldTransform };\n/** The result of successfully applying a mutation to the backend. */\nvar MutationResult = /** @class */ (function () {\n    function MutationResult(\n        /**\n           * The version at which the mutation was committed or null for a delete.\n           */\n        version, \n        /**\n           * The resulting fields returned from the backend after a\n           * TransformMutation has been committed. Contains one FieldValue for each\n           * FieldTransform that was in the mutation.\n           *\n           * Will be null if the mutation was not a TransformMutation.\n           */\n        transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n    return MutationResult;\n}());\nexport { MutationResult };\nexport var MutationType;\n(function (MutationType) {\n    MutationType[MutationType[\"Set\"] = 0] = \"Set\";\n    MutationType[MutationType[\"Patch\"] = 1] = \"Patch\";\n    MutationType[MutationType[\"Transform\"] = 2] = \"Transform\";\n    MutationType[MutationType[\"Delete\"] = 3] = \"Delete\";\n})(MutationType = MutationType || (MutationType = {}));\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nvar Precondition = /** @class */ (function () {\n    function Precondition(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n        assert(updateTime === undefined || exists === undefined, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n    }\n    /** Creates a new Precondition with an exists flag. */\n    Precondition.exists = function (exists) {\n        return new Precondition(undefined, exists);\n    };\n    /** Creates a new Precondition based on a version a document exists at. */\n    Precondition.updateTime = function (version) {\n        return new Precondition(version);\n    };\n    Object.defineProperty(Precondition.prototype, \"isNone\", {\n        /** Returns whether this Precondition is empty. */\n        get: function () {\n            return this.updateTime === undefined && this.exists === undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns true if the preconditions is valid for the given document\n     * (or null if no document is available).\n     */\n    Precondition.prototype.isValidFor = function (maybeDoc) {\n        if (this.updateTime !== undefined) {\n            return (maybeDoc instanceof Document && maybeDoc.version.equals(this.updateTime));\n        }\n        else if (this.exists !== undefined) {\n            if (this.exists) {\n                return maybeDoc instanceof Document;\n            }\n            else {\n                return maybeDoc === null || maybeDoc instanceof NoDocument;\n            }\n        }\n        else {\n            assert(this.isNone, 'Precondition should be empty');\n            return true;\n        }\n    };\n    Precondition.prototype.equals = function (other) {\n        return (misc.equals(this.updateTime, other.updateTime) &&\n            this.exists === other.exists);\n    };\n    Precondition.NONE = new Precondition();\n    return Precondition;\n}());\nexport { Precondition };\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nvar Mutation = /** @class */ (function () {\n    function Mutation() {\n    }\n    Mutation.prototype.verifyKeyMatches = function (maybeDoc) {\n        if (maybeDoc != null) {\n            assert(maybeDoc.key.equals(this.key), 'Can only apply a mutation to a document with the same key');\n        }\n    };\n    /**\n     * Returns the version from the given document for use as the result of a\n     * mutation. Mutations are defined to return the version of the base document\n     * only if it is an existing document. Deleted and unknown documents have a\n     * post-mutation version of SnapshotVersion.MIN.\n     */\n    Mutation.getPostMutationVersion = function (maybeDoc) {\n        if (maybeDoc instanceof Document) {\n            return maybeDoc.version;\n        }\n        else {\n            return SnapshotVersion.MIN;\n        }\n    };\n    return Mutation;\n}());\nexport { Mutation };\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nvar SetMutation = /** @class */ (function (_super) {\n    __extends(SetMutation, _super);\n    function SetMutation(key, value, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.value = value;\n        _this.precondition = precondition;\n        _this.type = MutationType.Set;\n        return _this;\n    }\n    SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        return new Document(this.key, version, this.value, {\n            hasLocalMutations: false\n        });\n    };\n    SetMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        return new Document(this.key, version, this.value, {\n            hasLocalMutations: true\n        });\n    };\n    SetMutation.prototype.equals = function (other) {\n        return (other instanceof SetMutation &&\n            this.key.equals(other.key) &&\n            this.value.equals(other.value) &&\n            this.precondition.equals(other.precondition));\n    };\n    return SetMutation;\n}(Mutation));\nexport { SetMutation };\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nvar PatchMutation = /** @class */ (function (_super) {\n    __extends(PatchMutation, _super);\n    function PatchMutation(key, data, fieldMask, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.data = data;\n        _this.fieldMask = fieldMask;\n        _this.precondition = precondition;\n        _this.type = MutationType.Patch;\n        return _this;\n    }\n    PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.');\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new Document(this.key, version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    PatchMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new Document(this.key, version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    PatchMutation.prototype.equals = function (other) {\n        return (other instanceof PatchMutation &&\n            this.key.equals(other.key) &&\n            this.fieldMask.equals(other.fieldMask) &&\n            this.precondition.equals(other.precondition));\n    };\n    /**\n     * Patches the data of document if available or creates a new document. Note\n     * that this does not check whether or not the precondition of this patch\n     * holds.\n     */\n    PatchMutation.prototype.patchDocument = function (maybeDoc) {\n        var data;\n        if (maybeDoc instanceof Document) {\n            data = maybeDoc.data;\n        }\n        else {\n            data = ObjectValue.EMPTY;\n        }\n        return this.patchObject(data);\n    };\n    PatchMutation.prototype.patchObject = function (data) {\n        for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {\n            var fieldPath = _a[_i];\n            var newValue = this.data.field(fieldPath);\n            if (newValue !== undefined) {\n                data = data.set(fieldPath, newValue);\n            }\n            else {\n                data = data.delete(fieldPath);\n            }\n        }\n        return data;\n    };\n    return PatchMutation;\n}(Mutation));\nexport { PatchMutation };\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nvar TransformMutation = /** @class */ (function (_super) {\n    __extends(TransformMutation, _super);\n    function TransformMutation(key, fieldTransforms) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.fieldTransforms = fieldTransforms;\n        _this.type = MutationType.Transform;\n        // NOTE: We set a precondition of exists: true as a safety-check, since we\n        // always combine TransformMutations with a SetMutation or PatchMutation which\n        // (if successful) should end up with an existing document.\n        _this.precondition = Precondition.exists(true);\n        return _this;\n    }\n    TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');\n        var transformResults = mutationResult.transformResults;\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new Document(this.key, doc.version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    TransformMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var transformResults = this.localTransformResults(localWriteTime);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new Document(this.key, doc.version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    TransformMutation.prototype.equals = function (other) {\n        return (other instanceof TransformMutation &&\n            this.key.equals(other.key) &&\n            misc.arrayEquals(this.fieldTransforms, other.fieldTransforms) &&\n            this.precondition.equals(other.precondition));\n    };\n    /**\n     * Asserts that the given MaybeDocument is actually a Document and verifies\n     * that it matches the key for this mutation. Since we only support\n     * transformations with precondition exists this method is guaranteed to be\n     * safe.\n     */\n    TransformMutation.prototype.requireDocument = function (maybeDoc) {\n        assert(maybeDoc instanceof Document, 'Unknown MaybeDocument type ' + maybeDoc);\n        var doc = maybeDoc;\n        assert(doc.key.equals(this.key), 'Can only transform a document with the same key');\n        return doc;\n    };\n    /**\n     * Creates a list of \"transform results\" (a transform result is a field value\n     * representing the result of applying a transform) for use when applying a\n     * TransformMutation locally.\n     *\n     * @param localWriteTime The local time of the transform mutation (used to\n     *     generate ServerTimestampValues).\n     * @return The transform results list.\n     */\n    TransformMutation.prototype.localTransformResults = function (localWriteTime) {\n        var transformResults = [];\n        for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {\n            var fieldTransform = _a[_i];\n            var transform = fieldTransform.transform;\n            if (transform instanceof ServerTimestampTransform) {\n                transformResults.push(new ServerTimestampValue(localWriteTime));\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return transformResults;\n    };\n    TransformMutation.prototype.transformObject = function (data, transformResults) {\n        assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');\n        for (var i = 0; i < this.fieldTransforms.length; i++) {\n            var fieldTransform = this.fieldTransforms[i];\n            var transform = fieldTransform.transform;\n            var fieldPath = fieldTransform.field;\n            if (transform instanceof ServerTimestampTransform) {\n                data = data.set(fieldPath, transformResults[i]);\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return data;\n    };\n    return TransformMutation;\n}(Mutation));\nexport { TransformMutation };\n/** A mutation that deletes the document at the given key. */\nvar DeleteMutation = /** @class */ (function (_super) {\n    __extends(DeleteMutation, _super);\n    function DeleteMutation(key, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.precondition = precondition;\n        _this.type = MutationType.Delete;\n        return _this;\n    }\n    DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        return new NoDocument(this.key, SnapshotVersion.MIN);\n    };\n    DeleteMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(this.key), 'Can only apply mutation to document with same key');\n        }\n        return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());\n    };\n    DeleteMutation.prototype.equals = function (other) {\n        return (other instanceof DeleteMutation &&\n            this.key.equals(other.key) &&\n            this.precondition.equals(other.precondition));\n    };\n    return DeleteMutation;\n}(Mutation));\nexport { DeleteMutation };\n\n//# sourceMappingURL=mutation.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/mutation.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ExistenceFilter = /** @class */ (function () {\n    // TODO(b/33078163): just use simplest form of existence filter for now\n    function ExistenceFilter(count) {\n        this.count = count;\n    }\n    ExistenceFilter.prototype.equals = function (other) {\n        return other && other.count === this.count;\n    };\n    return ExistenceFilter;\n}());\nexport { ExistenceFilter };\n\n//# sourceMappingURL=existence_filter.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/existence_filter.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SortedMap } from './sorted_map';\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nvar SortedSet = /** @class */ (function () {\n    function SortedSet(comparator) {\n        this.comparator = comparator;\n        this.data = new SortedMap(this.comparator);\n    }\n    /**\n     * Creates a SortedSet from the keys of the map.\n     * This is currently implemented as an O(n) copy.\n     */\n    SortedSet.fromMapKeys = function (map) {\n        var keys = new SortedSet(map.comparator);\n        map.forEach(function (key) {\n            keys = keys.add(key);\n        });\n        return keys;\n    };\n    SortedSet.prototype.has = function (elem) {\n        return this.data.get(elem) !== null;\n    };\n    SortedSet.prototype.first = function () {\n        return this.data.minKey();\n    };\n    SortedSet.prototype.last = function () {\n        return this.data.maxKey();\n    };\n    Object.defineProperty(SortedSet.prototype, \"size\", {\n        get: function () {\n            return this.data.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SortedSet.prototype.indexOf = function (elem) {\n        return this.data.indexOf(elem);\n    };\n    /** Iterates elements in order defined by \"comparator\" */\n    SortedSet.prototype.forEach = function (cb) {\n        this.data.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Iterates over `elem`s such that: range[0] <= elem < range[1]. */\n    SortedSet.prototype.forEachInRange = function (range, cb) {\n        var iter = this.data.getIteratorFrom(range[0]);\n        while (iter.hasNext()) {\n            var elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0)\n                return;\n            cb(elem.key);\n        }\n    };\n    /**\n     * Iterates over `elem`s such that: start <= elem until false is returned.\n     */\n    SortedSet.prototype.forEachWhile = function (cb, start) {\n        var iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        }\n        else {\n            iter = this.data.getIterator();\n        }\n        while (iter.hasNext()) {\n            var elem = iter.getNext();\n            var result = cb(elem.key);\n            if (!result)\n                return;\n        }\n    };\n    /** Finds the least element greater than or equal to `elem`. */\n    SortedSet.prototype.firstAfterOrEqual = function (elem) {\n        var iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    };\n    /** Inserts or updates an element */\n    SortedSet.prototype.add = function (elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    };\n    /** Deletes an element */\n    SortedSet.prototype.delete = function (elem) {\n        if (!this.has(elem))\n            return this;\n        return this.copy(this.data.remove(elem));\n    };\n    SortedSet.prototype.isEmpty = function () {\n        return this.data.isEmpty();\n    };\n    SortedSet.prototype.unionWith = function (other) {\n        var result = this;\n        other.forEach(function (elem) {\n            result = result.add(elem);\n        });\n        return result;\n    };\n    SortedSet.prototype.equals = function (other) {\n        if (!(other instanceof SortedSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.data.getIterator();\n        var otherIt = other.data.getIterator();\n        while (thisIt.hasNext()) {\n            var thisElem = thisIt.getNext().key;\n            var otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0)\n                return false;\n        }\n        return true;\n    };\n    SortedSet.prototype.toString = function () {\n        var result = [];\n        this.forEach(function (elem) { return result.push(elem); });\n        return 'SortedSet(' + result.toString() + ')';\n    };\n    SortedSet.prototype.copy = function (data) {\n        var result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    };\n    return SortedSet;\n}());\nexport { SortedSet };\n\n//# sourceMappingURL=sorted_set.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/sorted_set.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { documentKeySet } from '../model/collections';\nimport { emptyByteString } from '../platform/platform';\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nvar RemoteEvent = /** @class */ (function () {\n    function RemoteEvent(\n        /**\n           * The snapshot version this event brings us up to, or MIN if not set.\n           */\n        snapshotVersion, \n        /**\n           * A map from target to changes to the target. See TargetChange.\n           */\n        targetChanges, \n        /**\n           * A set of which documents have changed or been deleted, along with the\n           * doc's new values (if not deleted).\n           */\n        documentUpdates) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.documentUpdates = documentUpdates;\n    }\n    RemoteEvent.prototype.addDocumentUpdate = function (doc) {\n        this.documentUpdates = this.documentUpdates.insert(doc.key, doc);\n    };\n    RemoteEvent.prototype.handleExistenceFilterMismatch = function (targetId) {\n        /*\n         * An existence filter mismatch will reset the query and we need to reset\n         * the mapping to contain no documents and an empty resume token.\n         *\n         * Note:\n         *   * The reset mapping is empty, specifically forcing the consumer of the\n         *     change to forget all keys for this targetID;\n         *   * The resume snapshot for this target must be reset\n         *   * The target must be unacked because unwatching and rewatching\n         *     introduces a race for changes.\n         */\n        this.targetChanges[targetId] = {\n            mapping: new ResetMapping(),\n            snapshotVersion: SnapshotVersion.MIN,\n            currentStatusUpdate: CurrentStatusUpdate.MarkNotCurrent,\n            resumeToken: emptyByteString()\n        };\n    };\n    return RemoteEvent;\n}());\nexport { RemoteEvent };\n/**\n * Represents an update to the current status of a target, either explicitly\n * having no new state, or the new value to set. Note \"current\" has special\n * meaning for in the RPC protocol that implies that a target is both up-to-date\n * and consistent with the rest of the watch stream.\n */\nexport var CurrentStatusUpdate;\n(function (CurrentStatusUpdate) {\n    /** The current status is not affected and should not be modified. */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"None\"] = 0] = \"None\";\n    /** The target must be marked as no longer \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkNotCurrent\"] = 1] = \"MarkNotCurrent\";\n    /** The target must be marked as \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkCurrent\"] = 2] = \"MarkCurrent\";\n})(CurrentStatusUpdate = CurrentStatusUpdate || (CurrentStatusUpdate = {}));\nvar EMPTY_KEY_SET = documentKeySet();\nvar ResetMapping = /** @class */ (function () {\n    function ResetMapping() {\n        this.docs = EMPTY_KEY_SET;\n    }\n    Object.defineProperty(ResetMapping.prototype, \"documents\", {\n        get: function () {\n            return this.docs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ResetMapping.prototype.add = function (key) {\n        this.docs = this.docs.add(key);\n    };\n    ResetMapping.prototype.delete = function (key) {\n        this.docs = this.docs.delete(key);\n    };\n    ResetMapping.prototype.equals = function (other) {\n        return other !== null && this.docs.equals(other.docs);\n    };\n    return ResetMapping;\n}());\nexport { ResetMapping };\nvar UpdateMapping = /** @class */ (function () {\n    function UpdateMapping() {\n        this.addedDocuments = EMPTY_KEY_SET;\n        this.removedDocuments = EMPTY_KEY_SET;\n    }\n    UpdateMapping.prototype.applyToKeySet = function (keys) {\n        var result = keys;\n        this.addedDocuments.forEach(function (key) { return (result = result.add(key)); });\n        this.removedDocuments.forEach(function (key) { return (result = result.delete(key)); });\n        return result;\n    };\n    UpdateMapping.prototype.add = function (key) {\n        this.addedDocuments = this.addedDocuments.add(key);\n        this.removedDocuments = this.removedDocuments.delete(key);\n    };\n    UpdateMapping.prototype.delete = function (key) {\n        this.addedDocuments = this.addedDocuments.delete(key);\n        this.removedDocuments = this.removedDocuments.add(key);\n    };\n    UpdateMapping.prototype.equals = function (other) {\n        return (other !== null &&\n            this.addedDocuments.equals(other.addedDocuments) &&\n            this.removedDocuments.equals(other.removedDocuments));\n    };\n    return UpdateMapping;\n}());\nexport { UpdateMapping };\n\n//# sourceMappingURL=remote_event.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/remote_event.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nvar StreamBridge = /** @class */ (function () {\n    function StreamBridge(args) {\n        this.wrappedOnOpen = null;\n        this.wrappedOnClose = null;\n        this.wrappedOnMessage = null;\n        this.sendFn = args.sendFn;\n        this.closeFn = args.closeFn;\n    }\n    StreamBridge.prototype.onOpen = function (callback) {\n        assert(!this.wrappedOnOpen, 'Called onOpen on stream twice!');\n        this.wrappedOnOpen = callback;\n    };\n    StreamBridge.prototype.onClose = function (callback) {\n        assert(!this.wrappedOnClose, 'Called onClose on stream twice!');\n        this.wrappedOnClose = callback;\n    };\n    StreamBridge.prototype.onMessage = function (callback) {\n        assert(!this.wrappedOnMessage, 'Called onMessage on stream twice!');\n        this.wrappedOnMessage = callback;\n    };\n    StreamBridge.prototype.close = function () {\n        this.closeFn();\n    };\n    StreamBridge.prototype.send = function (msg) {\n        this.sendFn(msg);\n    };\n    StreamBridge.prototype.callOnOpen = function () {\n        assert(this.wrappedOnOpen !== null, 'Cannot call onOpen because no callback ' + 'was set');\n        this.wrappedOnOpen();\n    };\n    StreamBridge.prototype.callOnClose = function (err) {\n        assert(this.wrappedOnClose !== null, 'Cannot call onClose because no ' + 'callback was set');\n        this.wrappedOnClose(err);\n    };\n    StreamBridge.prototype.callOnMessage = function (msg) {\n        assert(this.wrappedOnMessage !== null, 'Cannot call onMessage because no ' + 'callback was set');\n        this.wrappedOnMessage(msg);\n    };\n    return StreamBridge;\n}());\nexport { StreamBridge };\n\n//# sourceMappingURL=stream_bridge.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/stream_bridge.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ErrorCode, EventType, WebChannel, XhrIoPool, createWebChannelTransport } from '@firebase/webchannel-wrapper';\nimport { SDK_VERSION } from '../core/version';\nimport { mapCodeFromHttpStatus, mapCodeFromRpcStatus } from '../remote/rpc_error';\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nvar LOG_TAG = 'Connection';\nvar RPC_URL_VERSION = 'v1beta1';\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nvar X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;\nvar XHR_TIMEOUT_SECS = 15;\nvar WebChannelConnection = /** @class */ (function () {\n    function WebChannelConnection(info) {\n        this.databaseId = info.databaseId;\n        this.pool = new XhrIoPool();\n        var proto = info.ssl ? 'https' : 'http';\n        this.baseUrl = proto + '://' + info.host;\n    }\n    /**\n     * Modifies the headers for a request, adding any authorization token if\n     * present and any additional headers for the request.\n     */\n    WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {\n        if (token) {\n            for (var header in token.authHeaders) {\n                if (token.authHeaders.hasOwnProperty(header)) {\n                    headers[header] = token.authHeaders[header];\n                }\n            }\n        }\n        headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;\n        // This header is used to improve routing and project isolation by the\n        // backend.\n        headers['google-cloud-resource-prefix'] =\n            \"projects/\" + this.databaseId.projectId + \"/\" +\n                (\"databases/\" + this.databaseId.database);\n    };\n    WebChannelConnection.prototype.invoke = function (rpcName, request, token) {\n        var _this = this;\n        var url = this.makeUrl(rpcName);\n        return new Promise(function (resolve, reject) {\n            _this.pool.getObject(function (xhr) {\n                xhr.listenOnce(EventType.COMPLETE, function () {\n                    try {\n                        switch (xhr.getLastErrorCode()) {\n                            case ErrorCode.NO_ERROR:\n                                var json = xhr.getResponseJson();\n                                log.debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                                resolve(json);\n                                break;\n                            case ErrorCode.TIMEOUT:\n                                log.error('RPC \"' + rpcName + '\" timed out, retrying.');\n                                reject(new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out'));\n                                break;\n                            case ErrorCode.HTTP_ERROR:\n                                var status_1 = xhr.getStatus();\n                                log.error('RPC \"' + rpcName + '\" failed with status:', status_1, 'response text:', xhr.getResponseText());\n                                if (status_1 > 0) {\n                                    reject(new FirestoreError(mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));\n                                }\n                                else {\n                                    // If we received an HTTP_ERROR but there's no status code,\n                                    // it's most probably a connection issue, let's retry.\n                                    log.error(LOG_TAG, 'RPC \"' + rpcName + '\" failed, retrying.');\n                                    reject(new FirestoreError(Code.UNAVAILABLE, 'Connection failed.'));\n                                }\n                                break;\n                            default:\n                                fail('RPC \"' +\n                                    rpcName +\n                                    '\" failed with unanticipated ' +\n                                    'webchannel error ' +\n                                    xhr.getLastErrorCode() +\n                                    ': ' +\n                                    xhr.getLastError() +\n                                    ', giving up.');\n                        }\n                    }\n                    finally {\n                        log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n                        _this.pool.releaseObject(xhr);\n                    }\n                });\n                var requestString = JSON.stringify(request);\n                log.debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);\n                // Content-Type: text/plain will avoid preflight requests which might\n                // mess with CORS and redirects by proxies. If we add custom headers\n                // we will need to change this code to potentially use the\n                // $httpOverwrite parameter supported by ESF to avoid\n                // triggering preflight requests.\n                var headers = { 'Content-Type': 'text/plain' };\n                _this.modifyHeadersForRequest(headers, token);\n                xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n            });\n        });\n    };\n    WebChannelConnection.prototype.openStream = function (rpcName, token) {\n        var rpcService = WebChannelConnection.RPC_STREAM_SERVICE_MAPPING[rpcName];\n        var rpcUrlName = WebChannelConnection.RPC_STREAM_NAME_MAPPING[rpcName];\n        if (!rpcService || !rpcUrlName) {\n            fail('Unknown RPC name: ' + rpcName);\n        }\n        var urlParts = [\n            this.baseUrl,\n            '/',\n            rpcService,\n            '/',\n            rpcUrlName,\n            '/channel'\n        ];\n        var webchannelTransport = createWebChannelTransport();\n        var request = {\n            // Background channel test avoids the initial two test calls and decreases\n            // initial cold start time.\n            // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n            // we should monitor closely for any reports.\n            backgroundChannelTest: true,\n            // Required for backend stickiness, routing behavior is based on this\n            // parameter.\n            httpSessionIdParam: 'gsessionid',\n            initMessageHeaders: {},\n            sendRawJson: true,\n            supportsCrossDomainXhr: true\n        };\n        this.modifyHeadersForRequest(request.initMessageHeaders, token);\n        var url = urlParts.join('');\n        log.debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);\n        // tslint:disable-next-line:no-any Because listen isn't defined on it.\n        var channel = webchannelTransport.createWebChannel(url, request);\n        // WebChannel supports sending the first message with the handshake - saving\n        // a network round trip. However, it will have to call send in the same\n        // JS event loop as open. In order to enforce this, we delay actually\n        // opening the WebChannel until send is called. Whether we have called\n        // open is tracked with this variable.\n        var opened = false;\n        // A flag to determine whether the stream was closed (by us or through an\n        // error/close event) to avoid delivering multiple close events or sending\n        // on a closed stream\n        var closed = false;\n        // tslint:disable-next-line:no-any\n        var streamBridge = new StreamBridge({\n            sendFn: function (msg) {\n                if (!closed) {\n                    if (!opened) {\n                        log.debug(LOG_TAG, 'Opening WebChannel transport.');\n                        channel.open();\n                        opened = true;\n                    }\n                    log.debug(LOG_TAG, 'WebChannel sending:', msg);\n                    channel.send(msg);\n                }\n                else {\n                    log.debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n                }\n            },\n            closeFn: function () { return channel.close(); }\n        });\n        // Closure events are guarded and exceptions are swallowed, so catch any\n        // exception and rethrow using a setTimeout so they become visible again.\n        // Note that eventually this function could go away if we are confident\n        // enough the code is exception free.\n        var unguardedEventListen = function (type, fn) {\n            // TODO(dimond): closure typing seems broken because WebChannel does\n            // not implement goog.events.Listenable\n            channel.listen(type, function (param) {\n                try {\n                    fn(param);\n                }\n                catch (e) {\n                    setTimeout(function () {\n                        throw e;\n                    }, 0);\n                }\n            });\n        };\n        unguardedEventListen(WebChannel.EventType.OPEN, function () {\n            if (!closed) {\n                log.debug(LOG_TAG, 'WebChannel transport opened.');\n            }\n        });\n        unguardedEventListen(WebChannel.EventType.CLOSE, function () {\n            if (!closed) {\n                closed = true;\n                log.debug(LOG_TAG, 'WebChannel transport closed');\n                streamBridge.callOnClose();\n            }\n        });\n        unguardedEventListen(WebChannel.EventType.ERROR, function (err) {\n            if (!closed) {\n                closed = true;\n                log.debug(LOG_TAG, 'WebChannel transport errored:', err);\n                streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE, 'The operation could not be completed'));\n            }\n        });\n        unguardedEventListen(WebChannel.EventType.MESSAGE, function (msg) {\n            if (!closed) {\n                // WebChannel delivers message events as array. If batching\n                // is not enabled (it's off by default) each message will be\n                // delivered alone, resulting in a single element array.\n                var msgData = msg.data[0];\n                assert(!!msgData, 'Got a webchannel message without data.');\n                // TODO(b/35143891): There is a bug in One Platform that caused errors\n                // (and only errors) to be wrapped in an extra array. To be forward\n                // compatible with the bug we need to check either condition. The latter\n                // can be removed once the fix has been rolled out.\n                var error = msgData.error || (msgData[0] && msgData[0].error);\n                if (error) {\n                    log.debug(LOG_TAG, 'WebChannel received error:', error);\n                    // error.status will be a string like 'OK' or 'NOT_FOUND'.\n                    var status_2 = error.status;\n                    var code = mapCodeFromRpcStatus(status_2);\n                    var message = error.message;\n                    if (code === undefined) {\n                        code = Code.INTERNAL;\n                        message =\n                            'Unknown error status: ' +\n                                status_2 +\n                                ' with message ' +\n                                error.message;\n                    }\n                    // Mark closed so no further events are propagated\n                    closed = true;\n                    streamBridge.callOnClose(new FirestoreError(code, message));\n                    channel.close();\n                }\n                else {\n                    log.debug(LOG_TAG, 'WebChannel received:', msgData);\n                    streamBridge.callOnMessage(msgData);\n                }\n            }\n        });\n        setTimeout(function () {\n            // Technically we could/should wait for the WebChannel opened event,\n            // but because we want to send the first message with the WebChannel\n            // handshake we pretend the channel opened here (asynchronously), and\n            // then delay the actual open until the first message is sent.\n            streamBridge.callOnOpen();\n        }, 0);\n        return streamBridge;\n    };\n    // visible for testing\n    WebChannelConnection.prototype.makeUrl = function (rpcName) {\n        var url = [this.baseUrl, '/', RPC_URL_VERSION];\n        url.push('/projects/');\n        url.push(this.databaseId.projectId);\n        url.push('/databases/');\n        url.push(this.databaseId.database);\n        url.push('/documents');\n        url.push(':');\n        url.push(rpcName);\n        return url.join('');\n    };\n    /**\n     * Mapping from RPC name to service providing the RPC.\n     * For streaming RPCs only.\n     */\n    WebChannelConnection.RPC_STREAM_SERVICE_MAPPING = {\n        Write: 'google.firestore.v1beta1.Firestore',\n        Listen: 'google.firestore.v1beta1.Firestore'\n    };\n    /**\n     * Mapping from RPC name to actual RPC name in URLs.\n     * For streaming RPCs only.\n     */\n    WebChannelConnection.RPC_STREAM_NAME_MAPPING = {\n        Write: 'Write',\n        Listen: 'Listen'\n    };\n    return WebChannelConnection;\n}());\nexport { WebChannelConnection };\n\n//# sourceMappingURL=webchannel_connection.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform_browser/webchannel_connection.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { WebChannelConnection } from './webchannel_connection';\nvar BrowserPlatform = /** @class */ (function () {\n    function BrowserPlatform() {\n        this.emptyByteString = '';\n        this.base64Available = typeof atob !== 'undefined';\n    }\n    BrowserPlatform.prototype.loadConnection = function (databaseInfo) {\n        return Promise.resolve(new WebChannelConnection(databaseInfo));\n    };\n    BrowserPlatform.prototype.newSerializer = function (databaseId) {\n        return new JsonProtoSerializer(databaseId, { useProto3Json: true });\n    };\n    BrowserPlatform.prototype.atob = function (encoded) {\n        return atob(encoded);\n    };\n    BrowserPlatform.prototype.btoa = function (raw) {\n        return btoa(raw);\n    };\n    return BrowserPlatform;\n}());\nexport { BrowserPlatform };\n\n//# sourceMappingURL=browser_platform.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform_browser/browser_platform.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PlatformSupport } from '../platform/platform';\nimport { BrowserPlatform } from './browser_platform';\n/**\n * This code needs to run before Firestore is used. This can be achieved in\n * several ways:\n *   1) Through the JSCompiler compiling this code and then (automatically)\n *      executing it before exporting the Firestore symbols.\n *   2) Through importing this module first in a Firestore main module\n */\nPlatformSupport.setPlatform(new BrowserPlatform());\n\n//# sourceMappingURL=browser_init.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform_browser/browser_init.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** Describes the online state of the Firestore client */\nexport var OnlineState;\n(function (OnlineState) {\n    /**\n     * The Firestore client is in an unknown online state. This means the client\n     * is either not actively trying to establish a connection or it was\n     * previously in an unknown state and is trying to establish a connection.\n     */\n    OnlineState[OnlineState[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * The client is connected and the connections are healthy. This state is\n     * reached after a successful connection and there has been at least one\n     * succesful message received from the backends.\n     */\n    OnlineState[OnlineState[\"Healthy\"] = 1] = \"Healthy\";\n    /**\n     * The client has tried to establish a connection but has failed.\n     * This state is reached after either a connection attempt failed or a\n     * healthy stream was closed for unexpected reasons.\n     */\n    OnlineState[OnlineState[\"Failed\"] = 2] = \"Failed\";\n})(OnlineState = OnlineState || (OnlineState = {}));\n\n//# sourceMappingURL=types.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/types.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\nexport var ChangeType;\n(function (ChangeType) {\n    ChangeType[ChangeType[\"Added\"] = 0] = \"Added\";\n    ChangeType[ChangeType[\"Removed\"] = 1] = \"Removed\";\n    ChangeType[ChangeType[\"Modified\"] = 2] = \"Modified\";\n    ChangeType[ChangeType[\"Metadata\"] = 3] = \"Metadata\";\n})(ChangeType = ChangeType || (ChangeType = {}));\nexport var SyncState;\n(function (SyncState) {\n    SyncState[SyncState[\"Local\"] = 0] = \"Local\";\n    SyncState[SyncState[\"Synced\"] = 1] = \"Synced\";\n})(SyncState = SyncState || (SyncState = {}));\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nvar DocumentChangeSet = /** @class */ (function () {\n    function DocumentChangeSet() {\n        this.changeMap = new SortedMap(DocumentKey.comparator);\n    }\n    DocumentChangeSet.prototype.track = function (change) {\n        var key = change.doc.key;\n        var oldChange = this.changeMap.get(key);\n        if (!oldChange) {\n            this.changeMap = this.changeMap.insert(key, change);\n            return;\n        }\n        // Merge the new change with the existing change.\n        if (change.type !== ChangeType.Added &&\n            oldChange.type === ChangeType.Metadata) {\n            this.changeMap = this.changeMap.insert(key, change);\n        }\n        else if (change.type === ChangeType.Metadata &&\n            oldChange.type !== ChangeType.Removed) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: oldChange.type,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Modified &&\n            oldChange.type === ChangeType.Modified) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Modified,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Modified &&\n            oldChange.type === ChangeType.Added) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Added,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Removed &&\n            oldChange.type === ChangeType.Added) {\n            this.changeMap = this.changeMap.remove(key);\n        }\n        else if (change.type === ChangeType.Removed &&\n            oldChange.type === ChangeType.Modified) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Removed,\n                doc: oldChange.doc\n            });\n        }\n        else if (change.type === ChangeType.Added &&\n            oldChange.type === ChangeType.Removed) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Modified,\n                doc: change.doc\n            });\n        }\n        else {\n            // This includes these cases, which don't make sense:\n            // Added->Added\n            // Removed->Removed\n            // Modified->Added\n            // Removed->Modified\n            // Metadata->Added\n            // Removed->Metadata\n            fail('unsupported combination of changes: ' +\n                JSON.stringify(change) +\n                ' after ' +\n                JSON.stringify(oldChange));\n        }\n    };\n    DocumentChangeSet.prototype.getChanges = function () {\n        var changes = [];\n        this.changeMap.inorderTraversal(function (key, change) {\n            changes.push(change);\n        });\n        return changes;\n    };\n    return DocumentChangeSet;\n}());\nexport { DocumentChangeSet };\n\n//# sourceMappingURL=view_snapshot.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/view_snapshot.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar RESERVED_BITS = 1;\nvar GeneratorIds;\n(function (GeneratorIds) {\n    GeneratorIds[GeneratorIds[\"LocalStore\"] = 0] = \"LocalStore\";\n    GeneratorIds[GeneratorIds[\"SyncEngine\"] = 1] = \"SyncEngine\";\n})(GeneratorIds || (GeneratorIds = {}));\n/**\n * TargetIdGenerator generates monotonically increasing integer IDs. There are\n * separate generators for different scopes. While these generators will operate\n * independently of each other, they are scoped, such that no two generators\n * will ever produce the same ID. This is useful, because sometimes the backend\n * may group IDs from separate parts of the client into the same ID space.\n */\nvar TargetIdGenerator = /** @class */ (function () {\n    function TargetIdGenerator(generatorId, initAfter) {\n        if (initAfter === void 0) { initAfter = 0; }\n        this.generatorId = generatorId;\n        // Replace the generator part of initAfter with this generator's ID.\n        var afterWithoutGenerator = (initAfter >> RESERVED_BITS) << RESERVED_BITS;\n        var afterGenerator = initAfter - afterWithoutGenerator;\n        if (afterGenerator >= generatorId) {\n            // For example, if:\n            //   this.generatorId = 0b0000\n            //   after = 0b1011\n            //   afterGenerator = 0b0001\n            // Then:\n            //   previous = 0b1010\n            //   next = 0b1100\n            this.previousId = afterWithoutGenerator | this.generatorId;\n        }\n        else {\n            // For example, if:\n            //   this.generatorId = 0b0001\n            //   after = 0b1010\n            //   afterGenerator = 0b0000\n            // Then:\n            //   previous = 0b1001\n            //   next = 0b1011\n            this.previousId =\n                (afterWithoutGenerator | this.generatorId) - (1 << RESERVED_BITS);\n        }\n    }\n    TargetIdGenerator.prototype.next = function () {\n        this.previousId += 1 << RESERVED_BITS;\n        return this.previousId;\n    };\n    TargetIdGenerator.forLocalStore = function (initAfter) {\n        if (initAfter === void 0) { initAfter = 0; }\n        return new TargetIdGenerator(GeneratorIds.LocalStore, initAfter);\n    };\n    TargetIdGenerator.forSyncEngine = function () {\n        return new TargetIdGenerator(GeneratorIds.SyncEngine);\n    };\n    return TargetIdGenerator;\n}());\nexport { TargetIdGenerator };\n\n//# sourceMappingURL=target_id_generator.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/target_id_generator.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\nimport { documentMap } from './collections';\nimport { DocumentKey } from './document_key';\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nvar DocumentSet = /** @class */ (function () {\n    /** The default ordering is by key if the comparator is omitted */\n    function DocumentSet(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = function (d1, d2) {\n                return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        else {\n            this.comparator = function (d1, d2) {\n                return DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new SortedMap(this.comparator);\n    }\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    DocumentSet.emptySet = function (oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    };\n    DocumentSet.prototype.has = function (key) {\n        return this.keyedMap.get(key) != null;\n    };\n    DocumentSet.prototype.get = function (key) {\n        return this.keyedMap.get(key);\n    };\n    DocumentSet.prototype.first = function () {\n        return this.sortedSet.minKey();\n    };\n    DocumentSet.prototype.last = function () {\n        return this.sortedSet.maxKey();\n    };\n    DocumentSet.prototype.isEmpty = function () {\n        return this.sortedSet.isEmpty();\n    };\n    /**\n     * Returns previous document or null if it's a first doc.\n     *\n     * @param key A key that MUST be present in the DocumentSet.\n     */\n    DocumentSet.prototype.prevDoc = function (key) {\n        assert(this.has(key), 'Trying to get a previous document to non-existing key: ' + key);\n        var doc = this.keyedMap.get(key);\n        return this.sortedSet.getPredecessorKey(doc);\n    };\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    DocumentSet.prototype.indexOf = function (key) {\n        var doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    };\n    Object.defineProperty(DocumentSet.prototype, \"size\", {\n        get: function () {\n            return this.sortedSet.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Iterates documents in order defined by \"comparator\" */\n    DocumentSet.prototype.forEach = function (cb) {\n        this.sortedSet.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Inserts or updates a document with the same key */\n    DocumentSet.prototype.add = function (doc) {\n        // First remove the element if we have it.\n        var set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    };\n    /** Deletes a document with a given key */\n    DocumentSet.prototype.delete = function (key) {\n        var doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    };\n    DocumentSet.prototype.equals = function (other) {\n        if (!(other instanceof DocumentSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.sortedSet.getIterator();\n        var otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            var thisDoc = thisIt.getNext().key;\n            var otherDoc = otherIt.getNext().key;\n            if (!thisDoc.equals(otherDoc))\n                return false;\n        }\n        return true;\n    };\n    DocumentSet.prototype.toString = function () {\n        var docStrings = [];\n        this.forEach(function (doc) {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    };\n    DocumentSet.prototype.copy = function (keyedMap, sortedSet) {\n        var newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    };\n    return DocumentSet;\n}());\nexport { DocumentSet };\n\n//# sourceMappingURL=document_set.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/document_set.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as objUtil from './obj';\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nvar ObjectMap = /** @class */ (function () {\n    function ObjectMap(mapKeyFn) {\n        this.mapKeyFn = mapKeyFn;\n        /**\n         * The inner map for a key -> value pair. Due to the possibility of\n         * collisions we keep a list of entries that we do a linear search through\n         * to find an actual match. Note that collisions should be rare, so we still\n         * expect near constant time lookups in practice.\n         */\n        this.inner = {};\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    ObjectMap.prototype.get = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n            var _a = matches_1[_i], otherKey = _a[0], value = _a[1];\n            if (otherKey.equals(key)) {\n                return value;\n            }\n        }\n        return undefined;\n    };\n    ObjectMap.prototype.has = function (key) {\n        return this.get(key) !== undefined;\n    };\n    /** Put this key and value in the map. */\n    ObjectMap.prototype.set = function (key, value) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            return;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].equals(key)) {\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n    };\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    ObjectMap.prototype.delete = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].equals(key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    ObjectMap.prototype.forEach = function (fn) {\n        objUtil.forEach(this.inner, function (_, entries) {\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                fn(k, v);\n            }\n        });\n    };\n    ObjectMap.prototype.isEmpty = function () {\n        return objUtil.isEmpty(this.inner);\n    };\n    return ObjectMap;\n}());\nexport { ObjectMap };\n\n//# sourceMappingURL=obj_map.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/obj_map.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OnlineState } from './types';\nimport { ChangeType } from './view_snapshot';\nimport { DocumentSet } from '../model/document_set';\nimport { assert } from '../util/assert';\nimport { ObjectMap } from '../util/obj_map';\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nvar QueryListenersInfo = /** @class */ (function () {\n    function QueryListenersInfo() {\n        this.listeners = [];\n    }\n    return QueryListenersInfo;\n}());\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\nvar EventManager = /** @class */ (function () {\n    function EventManager(syncEngine) {\n        this.syncEngine = syncEngine;\n        this.queries = new ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.onlineState = OnlineState.Unknown;\n        this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));\n    }\n    EventManager.prototype.listen = function (listener) {\n        var query = listener.query;\n        var firstListen = false;\n        var queryInfo = this.queries.get(query);\n        if (!queryInfo) {\n            firstListen = true;\n            queryInfo = new QueryListenersInfo();\n            this.queries.set(query, queryInfo);\n        }\n        queryInfo.listeners.push(listener);\n        listener.onOnlineStateChanged(this.onlineState);\n        if (queryInfo.viewSnap)\n            listener.onViewSnapshot(queryInfo.viewSnap);\n        if (firstListen) {\n            return this.syncEngine.listen(query).then(function (targetId) {\n                queryInfo.targetId = targetId;\n                return targetId;\n            });\n        }\n        else {\n            return Promise.resolve(queryInfo.targetId);\n        }\n    };\n    EventManager.prototype.unlisten = function (listener) {\n        var query = listener.query;\n        var lastListen = false;\n        var queryInfo = this.queries.get(query);\n        if (queryInfo) {\n            var i = queryInfo.listeners.indexOf(listener);\n            if (i >= 0) {\n                queryInfo.listeners.splice(i, 1);\n                lastListen = queryInfo.listeners.length === 0;\n            }\n        }\n        if (lastListen) {\n            this.queries.delete(query);\n            return this.syncEngine.unlisten(query);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    EventManager.prototype.onChange = function (viewSnaps) {\n        for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {\n            var viewSnap = viewSnaps_1[_i];\n            var query = viewSnap.query;\n            var queryInfo = this.queries.get(query);\n            if (queryInfo) {\n                for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {\n                    var listener = _b[_a];\n                    listener.onViewSnapshot(viewSnap);\n                }\n                queryInfo.viewSnap = viewSnap;\n            }\n        }\n    };\n    EventManager.prototype.onError = function (query, error) {\n        var queryInfo = this.queries.get(query);\n        if (queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.onError(error);\n            }\n        }\n        // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n        // after an error.\n        this.queries.delete(query);\n    };\n    EventManager.prototype.onOnlineStateChanged = function (onlineState) {\n        this.onlineState = onlineState;\n        this.queries.forEach(function (_, queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.onOnlineStateChanged(onlineState);\n            }\n        });\n    };\n    return EventManager;\n}());\nexport { EventManager };\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nvar QueryListener = /** @class */ (function () {\n    function QueryListener(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.onlineState = OnlineState.Unknown;\n        this.options = options || {};\n    }\n    QueryListener.prototype.onViewSnapshot = function (snap) {\n        assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');\n        if (!this.options.includeDocumentMetadataChanges) {\n            // Remove the metadata only changes.\n            var docChanges = [];\n            for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {\n                var docChange = _a[_i];\n                if (docChange.type !== ChangeType.Metadata) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = {\n                query: snap.query,\n                docs: snap.docs,\n                oldDocs: snap.oldDocs,\n                docChanges: docChanges,\n                fromCache: snap.fromCache,\n                hasPendingWrites: snap.hasPendingWrites,\n                syncStateChanged: snap.syncStateChanged\n            };\n        }\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n        }\n        this.snap = snap;\n    };\n    QueryListener.prototype.onError = function (error) {\n        this.queryObserver.error(error);\n    };\n    QueryListener.prototype.onOnlineStateChanged = function (onlineState) {\n        this.onlineState = onlineState;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n        }\n    };\n    QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) {\n        assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event');\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Failed\n        // or Online if we wait long enough).\n        var maybeOnline = onlineState !== OnlineState.Failed;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');\n            return false;\n        }\n        // Raise data from cache if we have any documents or we are offline\n        return !snap.docs.isEmpty() || onlineState === OnlineState.Failed;\n    };\n    QueryListener.prototype.shouldRaiseEvent = function (snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeQueryMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    };\n    QueryListener.prototype.raiseInitialEvent = function (snap) {\n        assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');\n        snap = {\n            query: snap.query,\n            docs: snap.docs,\n            oldDocs: DocumentSet.emptySet(snap.docs),\n            docChanges: QueryListener.getInitialViewChanges(snap),\n            fromCache: snap.fromCache,\n            hasPendingWrites: snap.hasPendingWrites,\n            syncStateChanged: true\n        };\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    };\n    /** Returns changes as if all documents in the snap were added. */\n    QueryListener.getInitialViewChanges = function (snap) {\n        var result = [];\n        snap.docs.forEach(function (doc) {\n            result.push({ type: ChangeType.Added, doc: doc });\n        });\n        return result;\n    };\n    return QueryListener;\n}());\nexport { QueryListener };\n\n//# sourceMappingURL=event_manager.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/event_manager.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nvar PersistencePromise = /** @class */ (function () {\n    function PersistencePromise(callback) {\n        var _this = this;\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        this.nextCallback = null;\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = null;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(function (value) {\n            _this.isDone = true;\n            _this.result = value;\n            if (_this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                _this.nextCallback(value);\n            }\n        }, function (error) {\n            _this.isDone = true;\n            _this.error = error;\n            if (_this.catchCallback) {\n                _this.catchCallback(error);\n            }\n        });\n    }\n    PersistencePromise.prototype.catch = function (fn) {\n        return this.next(undefined, fn);\n    };\n    PersistencePromise.prototype.next = function (nextFn, catchFn) {\n        var _this = this;\n        if (this.callbackAttached) {\n            fail('Called next() or catch() twice for PersistencePromise');\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise(function (resolve, reject) {\n                _this.nextCallback = function (value) {\n                    _this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                _this.catchCallback = function (error) {\n                    _this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    };\n    PersistencePromise.prototype.toPromise = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.next(resolve, reject);\n        });\n    };\n    PersistencePromise.prototype.wrapUserFunction = function (fn) {\n        try {\n            var result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    };\n    PersistencePromise.prototype.wrapSuccess = function (nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(function () { return nextFn(value); });\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T but we\n            // can't express that in the type system.\n            return PersistencePromise.resolve(value);\n        }\n    };\n    PersistencePromise.prototype.wrapFailure = function (catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(function () { return catchFn(error); });\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    };\n    PersistencePromise.resolve = function (result) {\n        return new PersistencePromise(function (resolve, reject) {\n            resolve(result);\n        });\n    };\n    PersistencePromise.reject = function (error) {\n        return new PersistencePromise(function (resolve, reject) {\n            reject(error);\n        });\n    };\n    PersistencePromise.waitFor = function (all) {\n        return all.reduce(function (promise, nextPromise, idx) {\n            return promise.next(function () {\n                return nextPromise;\n            });\n        }, PersistencePromise.resolve());\n    };\n    PersistencePromise.map = function (all) {\n        var results = [];\n        var first = true;\n        // initial is ignored, so we can cheat on the type.\n        var initial = PersistencePromise.resolve(null);\n        return all\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (!first) {\n                    results.push(result);\n                }\n                first = false;\n                return nextPromise;\n            });\n        }, initial)\n            .next(function (result) {\n            results.push(result);\n            return results;\n        });\n    };\n    return PersistencePromise;\n}());\nexport { PersistencePromise };\n\n//# sourceMappingURL=persistence_promise.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/persistence_promise.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A garbage collector implementation that eagerly collects documents as soon as\n * they're no longer referenced in any of its registered GarbageSources.\n *\n * This implementation keeps track of a set of keys that are potentially garbage\n * without keeping an exact reference count. During collectGarbage, the\n * collector verifies that all potential garbage keys actually have no\n * references by consulting its list of garbage sources.\n */\nvar EagerGarbageCollector = /** @class */ (function () {\n    function EagerGarbageCollector() {\n        this.isEager = true;\n        /**\n         * The garbage collectible sources to double-check during garbage collection.\n         */\n        this.sources = [];\n        /**\n         * A set of potentially garbage keys.\n         * PORTING NOTE: This would be a mutable set if Javascript had one.\n         */\n        this.potentialGarbage = documentKeySet();\n    }\n    EagerGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        this.sources.push(garbageSource);\n        garbageSource.setGarbageCollector(this);\n    };\n    EagerGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        this.sources.splice(this.sources.indexOf(garbageSource), 1);\n        garbageSource.setGarbageCollector(null);\n    };\n    EagerGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        this.potentialGarbage = this.potentialGarbage.add(key);\n    };\n    EagerGarbageCollector.prototype.collectGarbage = function (txn) {\n        var _this = this;\n        var promises = [];\n        var garbageKeys = documentKeySet();\n        this.potentialGarbage.forEach(function (key) {\n            var hasRefsPromise = _this.documentHasAnyReferences(txn, key);\n            promises.push(hasRefsPromise.next(function (hasRefs) {\n                // If there are no references, get the key.\n                if (!hasRefs) {\n                    garbageKeys = garbageKeys.add(key);\n                }\n                return PersistencePromise.resolve();\n            }));\n        });\n        // Clear locally retained potential keys and returned confirmed garbage.\n        this.potentialGarbage = documentKeySet();\n        return PersistencePromise.waitFor(promises).next(function () { return garbageKeys; });\n    };\n    EagerGarbageCollector.prototype.documentHasAnyReferences = function (txn, key) {\n        var initial = PersistencePromise.resolve(false);\n        return this.sources\n            .map(function (source) { return function () { return source.containsKey(txn, key); }; })\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (result) {\n                    return PersistencePromise.resolve(true);\n                }\n                else {\n                    return nextPromise();\n                }\n            });\n        }, initial);\n    };\n    return EagerGarbageCollector;\n}());\nexport { EagerGarbageCollector };\n\n//# sourceMappingURL=eager_garbage_collector.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/eager_garbage_collector.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChangeType } from '../core/view_snapshot';\nimport { documentKeySet } from '../model/collections';\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nvar LocalViewChanges = /** @class */ (function () {\n    function LocalViewChanges(query, addedKeys, removedKeys) {\n        this.query = query;\n        this.addedKeys = addedKeys;\n        this.removedKeys = removedKeys;\n    }\n    LocalViewChanges.fromSnapshot = function (viewSnapshot) {\n        var addedKeys = documentKeySet();\n        var removedKeys = documentKeySet();\n        for (var _i = 0, _a = viewSnapshot.docChanges; _i < _a.length; _i++) {\n            var docChange = _a[_i];\n            switch (docChange.type) {\n                case ChangeType.Added:\n                    addedKeys = addedKeys.add(docChange.doc.key);\n                    break;\n                case ChangeType.Removed:\n                    removedKeys = removedKeys.add(docChange.doc.key);\n                    break;\n                default:\n            }\n        }\n        return new LocalViewChanges(viewSnapshot.query, addedKeys, removedKeys);\n    };\n    return LocalViewChanges;\n}());\nexport { LocalViewChanges };\n\n//# sourceMappingURL=local_view_changes.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/local_view_changes.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nvar ReferenceSet = /** @class */ (function () {\n    function ReferenceSet() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\n        /** Keeps track of keys that have references */\n        this.garbageCollector = null;\n    }\n    /** Returns true if the reference set contains no references. */\n    ReferenceSet.prototype.isEmpty = function () {\n        return this.refsByKey.isEmpty();\n    };\n    /** Adds a reference to the given document key for the given ID. */\n    ReferenceSet.prototype.addReference = function (key, id) {\n        var ref = new DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    };\n    /** Add references to the given document keys for the given ID. */\n    ReferenceSet.prototype.addReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.addReference(key, id); });\n    };\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    ReferenceSet.prototype.removeReference = function (key, id) {\n        this.removeRef(new DocReference(key, id));\n    };\n    ReferenceSet.prototype.removeReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.removeReference(key, id); });\n    };\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    ReferenceSet.prototype.removeReferencesForId = function (id) {\n        var _this = this;\n        var emptyKey = DocumentKey.EMPTY;\n        var startRef = new DocReference(emptyKey, id);\n        var endRef = new DocReference(emptyKey, id + 1);\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            _this.removeRef(ref);\n        });\n    };\n    ReferenceSet.prototype.removeAllReferences = function () {\n        var _this = this;\n        this.refsByKey.forEach(function (ref) { return _this.removeRef(ref); });\n    };\n    ReferenceSet.prototype.removeRef = function (ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n        if (this.garbageCollector !== null) {\n            this.garbageCollector.addPotentialGarbageKey(ref.key);\n        }\n    };\n    ReferenceSet.prototype.referencesForId = function (id) {\n        var emptyKey = DocumentKey.EMPTY;\n        var startRef = new DocReference(emptyKey, id);\n        var endRef = new DocReference(emptyKey, id + 1);\n        var keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    };\n    ReferenceSet.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    ReferenceSet.prototype.containsKey = function (txn, key) {\n        var ref = new DocReference(key, 0);\n        var firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(firstRef !== null && key.equals(firstRef.key));\n    };\n    return ReferenceSet;\n}());\nexport { ReferenceSet };\nvar DocReference = /** @class */ (function () {\n    function DocReference(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    DocReference.compareByKey = function (left, right) {\n        return (DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    };\n    /** Compare by ID then by key */\n    DocReference.compareByTargetId = function (left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            DocumentKey.comparator(left.key, right.key));\n    };\n    return DocReference;\n}());\nexport { DocReference };\n\n//# sourceMappingURL=reference_set.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/reference_set.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { ExponentialBackoff } from './backoff';\nvar LOG_TAG = 'PersistentStream';\nvar PersistentStreamState;\n(function (PersistentStreamState) {\n    /**\n     * The streaming RPC is not running and there's no error condition.\n     * Calling `start` will start the stream immediately without backoff.\n     * While in this state isStarted will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Initial\"] = 0] = \"Initial\";\n    /**\n     * The stream is starting, and is waiting for an auth token to attach to\n     * the initial request. While in this state, isStarted will return\n     * true but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Auth\"] = 1] = \"Auth\";\n    /**\n     * The streaming RPC is up and running. Requests and responses can flow\n     * freely. Both isStarted and isOpen will return true.\n     */\n    PersistentStreamState[PersistentStreamState[\"Open\"] = 2] = \"Open\";\n    /**\n     * The stream encountered an error. The next start attempt will back off.\n     * While in this state isStarted() will return false.\n     *\n     */\n    PersistentStreamState[PersistentStreamState[\"Error\"] = 3] = \"Error\";\n    /**\n     * An in-between state after an error where the stream is waiting before\n     * re-starting. After\n     * waiting is complete, the stream will try to open. While in this\n     * state isStarted() will return YES but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Backoff\"] = 4] = \"Backoff\";\n    /**\n     * The stream has been explicitly stopped; no further events will be emitted.\n     */\n    PersistentStreamState[PersistentStreamState[\"Stopped\"] = 5] = \"Stopped\";\n})(PersistentStreamState || (PersistentStreamState = {}));\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nvar BACKOFF_INITIAL_DELAY_MS = 1000;\n/** Maximum backoff time in milliseconds */\nvar BACKOFF_MAX_DELAY_MS = 60 * 1000;\nvar BACKOFF_FACTOR = 1.5;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nvar PersistentStream = /** @class */ (function () {\n    function PersistentStream(queue, connection, credentialsProvider, listener, \n        // Used for faster retries in testing\n        initialBackoffDelay) {\n        this.queue = queue;\n        this.connection = connection;\n        this.credentialsProvider = credentialsProvider;\n        this.stream = null;\n        this.listener = null;\n        this.backoff = new ExponentialBackoff(initialBackoffDelay ? initialBackoffDelay : BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);\n        this.state = PersistentStreamState.Initial;\n        this.listener = listener;\n    }\n    /**\n     * Returns true if `start` has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    PersistentStream.prototype.isStarted = function () {\n        return (this.state === PersistentStreamState.Backoff ||\n            this.state === PersistentStreamState.Auth ||\n            this.state === PersistentStreamState.Open);\n    };\n    /**\n     * Returns true if the underlying RPC is open (the openHandler has been\n     * called) and the stream is ready for outbound requests.\n     */\n    PersistentStream.prototype.isOpen = function () {\n        return this.state === PersistentStreamState.Open;\n    };\n    /**\n     * Starts the RPC. Only allowed if isStarted returns false. The stream is\n     * not immediately ready for use: onOpen will be invoked when the RPC is ready\n     * for outbound requests, at which point isOpen will return true.\n     *\n     *  When start returns, isStarted will return true.\n     */\n    PersistentStream.prototype.start = function () {\n        if (this.state === PersistentStreamState.Error) {\n            this.performBackoff();\n            return;\n        }\n        assert(this.state === PersistentStreamState.Initial, 'Already started');\n        this.auth();\n    };\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted state.\n     *\n     * When stop returns, isStarted and isOpen will both return false.\n     */\n    PersistentStream.prototype.stop = function () {\n        // Prevent any possible future restart of this stream\n        this.state = PersistentStreamState.Stopped;\n        // Clear the listener to avoid bleeding of events from the underlying\n        // streams\n        this.listener = null;\n        // Clean up the underlying stream because we are no longer interested in\n        // events\n        if (this.stream !== null) {\n            this.stream.close();\n            this.stream = null;\n        }\n    };\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose function. That function can decide to\n     * inhibit backoff if required.\n     */\n    PersistentStream.prototype.inhibitBackoff = function () {\n        assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n        this.state = PersistentStreamState.Initial;\n        this.backoff.reset();\n    };\n    PersistentStream.prototype.auth = function () {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');\n        this.state = PersistentStreamState.Auth;\n        this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(function (token) {\n            // Normally we'd have to schedule the callback on the AsyncQueue.\n            // However, the following calls are safe to be called outside the\n            // AsyncQueue since they don't chain asynchronous calls\n            _this.startStream(token);\n        }, function (error) {\n            _this.queue.schedule(function () {\n                if (_this.state !== PersistentStreamState.Stopped) {\n                    // Stream can be stopped while waiting for authorization.\n                    var rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                    return _this.handleStreamClose(rpcError);\n                }\n                else {\n                    return Promise.resolve();\n                }\n            });\n        });\n    };\n    PersistentStream.prototype.startStream = function (token) {\n        var _this = this;\n        if (this.state === PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            return;\n        }\n        assert(this.state === PersistentStreamState.Auth, 'Trying to start stream in a non-auth state');\n        // Helper function to dispatch to AsyncQueue and make sure that any\n        // close will seem instantaneous and events are prevented from being\n        // raised after the close call\n        var dispatchIfNotStopped = function (fn) {\n            _this.queue.schedule(function () {\n                // Only raise events if the listener has not changed\n                if (_this.state !== PersistentStreamState.Stopped) {\n                    return fn();\n                }\n                else {\n                    return Promise.resolve();\n                }\n            });\n        };\n        // Only start stream if listener has not changed\n        if (this.listener !== null) {\n            this.stream = this.startRpc(token);\n            this.stream.onOpen(function () {\n                dispatchIfNotStopped(function () {\n                    assert(_this.state === PersistentStreamState.Auth, 'Expected stream to be in state auth, but was ' + _this.state);\n                    _this.state = PersistentStreamState.Open;\n                    return _this.listener.onOpen();\n                });\n            });\n            this.stream.onClose(function (error) {\n                dispatchIfNotStopped(function () {\n                    return _this.handleStreamClose(error);\n                });\n            });\n            this.stream.onMessage(function (msg) {\n                dispatchIfNotStopped(function () {\n                    return _this.onMessage(msg);\n                });\n            });\n        }\n    };\n    PersistentStream.prototype.performBackoff = function () {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Error, 'Should only perform backoff in an error case');\n        this.state = PersistentStreamState.Backoff;\n        this.backoff.backoffAndWait().then(function () {\n            // Backoff does not run on the AsyncQueue, so we need to reschedule to\n            // make sure the queue blocks\n            _this.queue.schedule(function () {\n                if (_this.state === PersistentStreamState.Stopped) {\n                    // Stream can be stopped while waiting for backoff to complete.\n                    return Promise.resolve();\n                }\n                _this.state = PersistentStreamState.Initial;\n                _this.start();\n                assert(_this.isStarted(), 'PersistentStream should have started');\n                return Promise.resolve();\n            });\n        });\n    };\n    PersistentStream.prototype.handleStreamClose = function (error) {\n        assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n        log.debug(LOG_TAG, \"close with error: \" + error);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        this.state = PersistentStreamState.Error;\n        if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n            log.debug(LOG_TAG, 'Using maximum backoff delay to prevent overloading the backend.');\n            this.backoff.resetToMax();\n        }\n        return this.listener.onClose(error);\n    };\n    return PersistentStream;\n}());\nexport { PersistentStream };\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nvar PersistentListenStream = /** @class */ (function (_super) {\n    __extends(PersistentListenStream, _super);\n    function PersistentListenStream(databaseInfo, queue, connection, credentials, serializer, listener, initialBackoffDelay) {\n        var _this = _super.call(this, queue, connection, credentials, listener, initialBackoffDelay) || this;\n        _this.databaseInfo = databaseInfo;\n        _this.serializer = serializer;\n        return _this;\n    }\n    PersistentListenStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Listen', token);\n    };\n    PersistentListenStream.prototype.onMessage = function (watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        var watchChange = this.serializer.fromWatchChange(watchChangeProto);\n        var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    };\n    /**\n     * Registers interest in the results of the given query. If the query\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the query will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    PersistentListenStream.prototype.watch = function (queryData) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.addTarget = this.serializer.toTarget(queryData);\n        var labels = this.serializer.toListenRequestLabels(queryData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.stream.send(request);\n    };\n    /**\n     * Unregisters interest in the results of the query associated with the\n     * given targetId.\n     */\n    PersistentListenStream.prototype.unwatch = function (targetId) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.removeTarget = targetId;\n        this.stream.send(request);\n    };\n    return PersistentListenStream;\n}(PersistentStream));\nexport { PersistentListenStream };\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nvar PersistentWriteStream = /** @class */ (function (_super) {\n    __extends(PersistentWriteStream, _super);\n    function PersistentWriteStream(databaseInfo, queue, connection, credentials, serializer, listener, initialBackoffDelay) {\n        var _this = _super.call(this, queue, connection, credentials, listener, initialBackoffDelay) || this;\n        _this.databaseInfo = databaseInfo;\n        _this.serializer = serializer;\n        _this.handshakeComplete_ = false;\n        return _this;\n    }\n    Object.defineProperty(PersistentWriteStream.prototype, \"handshakeComplete\", {\n        /**\n         * Tracks whether or not a handshake has been successfully exchanged and\n         * the stream is ready to accept mutations.\n         */\n        get: function () {\n            return this.handshakeComplete_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Override of PersistentStream.start\n    PersistentWriteStream.prototype.start = function () {\n        this.handshakeComplete_ = false;\n        _super.prototype.start.call(this);\n    };\n    PersistentWriteStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Write', token);\n    };\n    PersistentWriteStream.prototype.onMessage = function (responseProto) {\n        // Always capture the last stream token.\n        assert(!!responseProto.streamToken, 'Got a write response without a stream token');\n        this.lastStreamToken = responseProto.streamToken;\n        if (!this.handshakeComplete_) {\n            // The first response is always the handshake response\n            assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');\n            this.handshakeComplete_ = true;\n            return this.listener.onHandshakeComplete();\n        }\n        else {\n            // A successful first write response means the stream is healthy,\n            // Note, that we could consider a successful handshake healthy, however,\n            // the write itself might be causing an error we want to back off from.\n            this.backoff.reset();\n            var results = this.serializer.fromWriteResults(responseProto.writeResults);\n            var commitVersion = this.serializer.fromVersion(responseProto.commitTime);\n            return this.listener.onMutationResult(commitVersion, results);\n        }\n    };\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    PersistentWriteStream.prototype.writeHandshake = function () {\n        assert(this.isOpen(), 'Writing handshake requires an opened stream');\n        assert(!this.handshakeComplete_, 'Handshake already completed');\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        this.stream.send(request);\n    };\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    PersistentWriteStream.prototype.writeMutations = function (mutations) {\n        var _this = this;\n        assert(this.isOpen(), 'Writing mutations requires an opened stream');\n        assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');\n        assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');\n        var request = {\n            // Protos are typed with string, but we support UInt8Array on Node\n            // tslint:disable-next-line:no-any\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(function (mutation) { return _this.serializer.toMutation(mutation); })\n        };\n        this.stream.send(request);\n    };\n    return PersistentWriteStream;\n}(PersistentStream));\nexport { PersistentWriteStream };\n\n//# sourceMappingURL=persistent_stream.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/persistent_stream.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { LocalViewChanges } from '../local/local_view_changes';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { ReferenceSet } from '../local/reference_set';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { CurrentStatusUpdate, RemoteEvent } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport { primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\nimport { SortedMap } from '../util/sorted_map';\nimport { isNullOrUndefined } from '../util/types';\nimport { Query } from './query';\nimport { SnapshotVersion } from './snapshot_version';\nimport { TargetIdGenerator } from './target_id_generator';\nimport { AddedLimboDocument, RemovedLimboDocument, View } from './view';\nvar LOG_TAG = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nvar QueryView = /** @class */ (function () {\n    function QueryView(\n        /**\n         * The query itself.\n         */\n        query, \n        /**\n         * The target number created by the client that is used in the watch\n         * stream to identify this query.\n         */\n        targetId, \n        /**\n         * An identifier from the datastore backend that indicates the last state\n         * of the results that was received. This can be used to indicate where\n         * to continue receiving new doc changes for the query.\n         */\n        resumeToken, \n        /**\n         * The view is responsible for computing the final merged truth of what\n         * docs are in the query. It gets notified of local and remote changes,\n         * and applies the query filters and limits to determine the most correct\n         * possible results.\n         */\n        view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.resumeToken = resumeToken;\n        this.view = view;\n    }\n    return QueryView;\n}());\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngine’s methods should only ever be called by methods running in the\n * global async queue.\n */\nvar SyncEngine = /** @class */ (function () {\n    function SyncEngine(localStore, remoteStore, currentUser) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.currentUser = currentUser;\n        this.viewHandler = null;\n        this.errorHandler = null;\n        this.queryViewsByQuery = new ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.queryViewsByTarget = {};\n        this.limboTargetsByKey = new SortedMap(DocumentKey.comparator);\n        this.limboKeysByTarget = {};\n        this.limboDocumentRefs = new ReferenceSet();\n        this.limboCollector = new EagerGarbageCollector();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        this.targetIdGenerator = TargetIdGenerator.forSyncEngine();\n    }\n    /** Subscribes view and error handler. Can be called only once. */\n    SyncEngine.prototype.subscribe = function (viewHandler, errorHandler) {\n        assert(viewHandler !== null && errorHandler !== null, 'View and error handlers cannot be null');\n        assert(this.viewHandler === null && this.errorHandler === null, 'SyncEngine already has a subscriber.');\n        this.viewHandler = viewHandler;\n        this.errorHandler = errorHandler;\n        this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n    };\n    /**\n     * Initiates the new listen, resolves promise when listen enqueued to the\n     * server. All the subsequent view snapshots or errors are sent to the\n     * subscribed handlers. Returns the targetId of the query.\n     */\n    SyncEngine.prototype.listen = function (query) {\n        var _this = this;\n        this.assertSubscribed('listen()');\n        assert(!this.queryViewsByQuery.has(query), 'We already listen to the query: ' + query);\n        return this.localStore.allocateQuery(query).then(function (queryData) {\n            return _this.localStore\n                .executeQuery(query)\n                .then(function (docs) {\n                return _this.localStore\n                    .remoteDocumentKeys(queryData.targetId)\n                    .then(function (remoteKeys) {\n                    var view = new View(query, remoteKeys);\n                    var viewDocChanges = view.computeDocChanges(docs);\n                    var viewChange = view.applyChanges(viewDocChanges);\n                    assert(viewChange.limboChanges.length === 0, 'View returned limbo docs before target ack from the server.');\n                    assert(!!viewChange.snapshot, 'applyChanges for new view should always return a snapshot');\n                    var data = new QueryView(query, queryData.targetId, queryData.resumeToken, view);\n                    _this.queryViewsByQuery.set(query, data);\n                    _this.queryViewsByTarget[queryData.targetId] = data;\n                    _this.viewHandler([viewChange.snapshot]);\n                    _this.remoteStore.listen(queryData);\n                });\n            })\n                .then(function () {\n                return queryData.targetId;\n            });\n        });\n    };\n    /** Stops listening to the query. */\n    SyncEngine.prototype.unlisten = function (query) {\n        var _this = this;\n        this.assertSubscribed('unlisten()');\n        var queryView = this.queryViewsByQuery.get(query);\n        assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n        return this.localStore.releaseQuery(query).then(function () {\n            _this.remoteStore.unlisten(queryView.targetId);\n            return _this.removeAndCleanupQuery(queryView).then(function () {\n                return _this.localStore.collectGarbage();\n            });\n        });\n    };\n    /**\n     * Initiates the write of local mutation batch which involves adding the\n     * writes to the mutation queue, notifying the remote store about new\n     * mutations and raising events for any changes this write caused.\n     *\n     * The promise returned by this call is resolved when the above steps\n     * have completed, *not* when the write was acked by the backend. The\n     * userCallback is resolved once the write was acked/rejected by the\n     * backend (or failed locally for any other reason).\n     */\n    SyncEngine.prototype.write = function (batch, userCallback) {\n        var _this = this;\n        this.assertSubscribed('write()');\n        return this.localStore\n            .localWrite(batch)\n            .then(function (result) {\n            _this.addMutationCallback(result.batchId, userCallback);\n            return _this.emitNewSnapsAndNotifyLocalStore(result.changes);\n        })\n            .then(function () {\n            return _this.remoteStore.fillWritePipeline();\n        });\n    };\n    // TODO(klimt): Wrap the given error in a standard Firestore error object.\n    SyncEngine.prototype.wrapUpdateFunctionError = function (error) {\n        return error;\n    };\n    /**\n     * Takes an updateFunction in which a set of reads and writes can be performed\n     * atomically. In the updateFunction, the client can read and write values\n     * using the supplied transaction object. After the updateFunction, all\n     * changes will be committed. If some other client has changed any of the data\n     * referenced, then the updateFunction will be called again. If the\n     * updateFunction still fails after the given number of retries, then the\n     * transaction will be rejection.\n     *\n     * The transaction object passed to the updateFunction contains methods for\n     * accessing documents and collections. Unlike other datastore access, data\n     * accessed with the transaction will not reflect local changes that have not\n     * been committed. For this reason, it is required that all reads are\n     * performed before any writes. Transactions must be performed while online.\n     *\n     * The promise returned is resolved when the transaction is fully committed.\n     */\n    SyncEngine.prototype.runTransaction = function (updateFunction, retries) {\n        var _this = this;\n        if (retries === void 0) { retries = 5; }\n        assert(retries >= 0, 'Got negative number of retries for transaction.');\n        var transaction = this.remoteStore.createTransaction();\n        var wrappedUpdateFunction = function () {\n            try {\n                var userPromise = updateFunction(transaction);\n                if (isNullOrUndefined(userPromise) ||\n                    !userPromise.catch ||\n                    !userPromise.then) {\n                    return Promise.reject(Error('Transaction callback must return a Promise'));\n                }\n                return userPromise.catch(function (e) {\n                    return Promise.reject(_this.wrapUpdateFunctionError(e));\n                });\n            }\n            catch (e) {\n                return Promise.reject(_this.wrapUpdateFunctionError(e));\n            }\n        };\n        return wrappedUpdateFunction().then(function (result) {\n            return transaction\n                .commit()\n                .then(function () {\n                return result;\n            })\n                .catch(function (error) {\n                if (retries === 0) {\n                    return Promise.reject(error);\n                }\n                // TODO(klimt): Put in a retry delay?\n                return _this.runTransaction(updateFunction, retries - 1);\n            });\n        });\n    };\n    SyncEngine.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        this.assertSubscribed('applyRemoteEvent()');\n        // Make sure limbo documents are deleted if there were no results\n        objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, targetChange) {\n            var limboKey = _this.limboKeysByTarget[targetId];\n            if (limboKey &&\n                targetChange.currentStatusUpdate ===\n                    CurrentStatusUpdate.MarkCurrent &&\n                !remoteEvent.documentUpdates.get(limboKey)) {\n                // When listening to a query the server responds with a snapshot\n                // containing documents matching the query and a current marker\n                // telling us we're now in sync. It's possible for these to arrive\n                // as separate remote events or as a single remote event.\n                // For a document query, there will be no documents sent in the\n                // response if the document doesn't exist.\n                //\n                // If the snapshot arrives separately from the current marker,\n                // we handle it normally and updateTrackedLimbos will resolve the\n                // limbo status of the document, removing it from limboDocumentRefs.\n                // This works because clients only initiate limbo resolution when\n                // a target is current and because all current targets are\n                // always at a consistent snapshot.\n                //\n                // However, if the document doesn't exist and the current marker\n                // arrives, the document is not present in the snapshot and our\n                // normal view handling would consider the document to remain in\n                // limbo indefinitely because there are no updates to the document.\n                // To avoid this, we specially handle this just this case here:\n                // synthesizing a delete.\n                //\n                // TODO(dimond): Ideally we would have an explicit lookup query\n                // instead resulting in an explicit delete message and we could\n                // remove this special logic.\n                remoteEvent.addDocumentUpdate(new NoDocument(limboKey, remoteEvent.snapshotVersion));\n            }\n        });\n        return this.localStore.applyRemoteEvent(remoteEvent).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n        });\n    };\n    SyncEngine.prototype.rejectListen = function (targetId, err) {\n        var _this = this;\n        this.assertSubscribed('rejectListens()');\n        var limboKey = this.limboKeysByTarget[targetId];\n        if (limboKey) {\n            // Since this query failed, we won't want to manually unlisten to it.\n            // So go ahead and remove it from bookkeeping.\n            this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n            delete this.limboKeysByTarget[targetId];\n            // TODO(klimt): We really only should do the following on permission\n            // denied errors, but we don't have the cause code here.\n            // It's a limbo doc. Create a synthetic event saying it was deleted.\n            // This is kind of a hack. Ideally, we would have a method in the local\n            // store to purge a document. However, it would be tricky to keep all of\n            // the local store's invariants with another method.\n            var docMap = new SortedMap(DocumentKey.comparator);\n            docMap = docMap.insert(limboKey, new NoDocument(limboKey, SnapshotVersion.forDeletedDoc()));\n            var event_1 = new RemoteEvent(SnapshotVersion.MIN, {}, docMap);\n            return this.applyRemoteEvent(event_1);\n        }\n        else {\n            var queryView_1 = this.queryViewsByTarget[targetId];\n            assert(!!queryView_1, 'Unknown targetId: ' + targetId);\n            return this.localStore.releaseQuery(queryView_1.query).then(function () {\n                return _this.removeAndCleanupQuery(queryView_1).then(function () {\n                    _this.errorHandler(queryView_1.query, err);\n                });\n            });\n        }\n    };\n    SyncEngine.prototype.applySuccessfulWrite = function (mutationBatchResult) {\n        var _this = this;\n        this.assertSubscribed('applySuccessfulWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        this.processUserCallback(mutationBatchResult.batch.batchId, \n        /*error=*/ null);\n        return this.localStore\n            .acknowledgeBatch(mutationBatchResult)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.rejectFailedWrite = function (batchId, error) {\n        var _this = this;\n        this.assertSubscribed('rejectFailedWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        this.processUserCallback(batchId, error);\n        return this.localStore.rejectBatch(batchId).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.addMutationCallback = function (batchId, callback) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        if (!newCallbacks) {\n            newCallbacks = new SortedMap(primitiveComparator);\n        }\n        newCallbacks = newCallbacks.insert(batchId, callback);\n        this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    };\n    /**\n     * Resolves or rejects the user callback for the given batch and then discards\n     * it.\n     */\n    SyncEngine.prototype.processUserCallback = function (batchId, error) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        // NOTE: Mutations restored from persistence won't have callbacks, so it's\n        // okay for there to be no callback for this ID.\n        if (newCallbacks) {\n            var callback = newCallbacks.get(batchId);\n            if (callback) {\n                assert(batchId === newCallbacks.minKey(), 'Mutation callbacks processed out-of-order?');\n                if (error) {\n                    callback.reject(error);\n                }\n                else {\n                    callback.resolve();\n                }\n                newCallbacks = newCallbacks.remove(batchId);\n            }\n            this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n        }\n    };\n    SyncEngine.prototype.removeAndCleanupQuery = function (queryView) {\n        this.queryViewsByQuery.delete(queryView.query);\n        delete this.queryViewsByTarget[queryView.targetId];\n        this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.updateTrackedLimbos = function (targetId, limboChanges) {\n        for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {\n            var limboChange = limboChanges_1[_i];\n            if (limboChange instanceof AddedLimboDocument) {\n                this.limboDocumentRefs.addReference(limboChange.key, targetId);\n                this.trackLimboChange(limboChange);\n            }\n            else if (limboChange instanceof RemovedLimboDocument) {\n                log.debug(LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n                this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            }\n            else {\n                fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n            }\n        }\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.trackLimboChange = function (limboChange) {\n        var key = limboChange.key;\n        if (!this.limboTargetsByKey.get(key)) {\n            log.debug(LOG_TAG, 'New document in limbo: ' + key);\n            var limboTargetId = this.targetIdGenerator.next();\n            var query = Query.atPath(key.path);\n            this.limboKeysByTarget[limboTargetId] = key;\n            this.remoteStore.listen(new QueryData(query, limboTargetId, QueryPurpose.Listen));\n            this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);\n        }\n    };\n    SyncEngine.prototype.gcLimboDocuments = function () {\n        var _this = this;\n        // HACK: We can use a null transaction here, because we know that the\n        // reference set is entirely within memory and doesn't need a store engine.\n        return this.limboCollector\n            .collectGarbage(null)\n            .next(function (keys) {\n            keys.forEach(function (key) {\n                var limboTargetId = _this.limboTargetsByKey.get(key);\n                if (limboTargetId === null) {\n                    // This target already got removed, because the query failed.\n                    return;\n                }\n                _this.remoteStore.unlisten(limboTargetId);\n                _this.limboTargetsByKey = _this.limboTargetsByKey.remove(key);\n                delete _this.limboKeysByTarget[limboTargetId];\n            });\n        })\n            .toPromise();\n    };\n    // Visible for testing\n    SyncEngine.prototype.currentLimboDocs = function () {\n        return this.limboTargetsByKey;\n    };\n    SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function (changes, remoteEvent) {\n        var _this = this;\n        var newSnaps = [];\n        var docChangesInAllViews = [];\n        var queriesProcessed = [];\n        this.queryViewsByQuery.forEach(function (_, queryView) {\n            queriesProcessed.push(Promise.resolve()\n                .then(function () {\n                var viewDocChanges = queryView.view.computeDocChanges(changes);\n                if (!viewDocChanges.needsRefill) {\n                    return viewDocChanges;\n                }\n                // The query has a limit and some docs were removed, so we need\n                // to re-run the query against the local store to make sure we\n                // didn't lose any good docs that had been past the limit.\n                return _this.localStore.executeQuery(queryView.query).then(function (docs) {\n                    return queryView.view.computeDocChanges(docs, viewDocChanges);\n                });\n            })\n                .then(function (viewDocChanges) {\n                var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n                var viewChange = queryView.view.applyChanges(viewDocChanges, targetChange);\n                return _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges).then(function () {\n                    if (viewChange.snapshot) {\n                        newSnaps.push(viewChange.snapshot);\n                        var docChanges = LocalViewChanges.fromSnapshot(viewChange.snapshot);\n                        docChangesInAllViews.push(docChanges);\n                    }\n                });\n            }));\n        });\n        return Promise.all(queriesProcessed)\n            .then(function () {\n            _this.viewHandler(newSnaps);\n            return _this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n        })\n            .then(function () {\n            return _this.localStore.collectGarbage();\n        });\n    };\n    SyncEngine.prototype.assertSubscribed = function (fnName) {\n        assert(this.viewHandler !== null && this.errorHandler !== null, 'Trying to call ' + fnName + ' before calling subscribe().');\n    };\n    SyncEngine.prototype.handleUserChange = function (user) {\n        var _this = this;\n        this.currentUser = user;\n        return this.localStore\n            .handleUserChange(user)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        })\n            .then(function () {\n            return _this.remoteStore.handleUserChange(user);\n        });\n    };\n    return SyncEngine;\n}());\nexport { SyncEngine };\n\n//# sourceMappingURL=sync_engine.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/sync_engine.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet, documentVersionMap } from './collections';\nimport { assert } from '../util/assert';\nimport * as misc from '../util/misc';\nexport var BATCHID_UNKNOWN = -1;\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nvar MutationBatch = /** @class */ (function () {\n    function MutationBatch(batchId, localWriteTime, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to create a new remote document\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     * @param batchResult The result of applying the MutationBatch to the\n     * backend.\n     */\n    MutationBatch.prototype.applyToRemoteDocument = function (docKey, maybeDoc, batchResult) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(docKey), \"applyToRemoteDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        var mutationResults = batchResult.mutationResults;\n        assert(mutationResults.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + mutationResults.length + \").\");\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.equals(docKey)) {\n                var mutationResult = mutationResults[i];\n                maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n            }\n        }\n        return maybeDoc;\n    };\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     */\n    MutationBatch.prototype.applyToLocalView = function (docKey, maybeDoc) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.equals(docKey), \"applyToLocalDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.equals(docKey)) {\n                maybeDoc = mutation.applyToLocalView(maybeDoc, this.localWriteTime);\n            }\n        }\n        return maybeDoc;\n    };\n    MutationBatch.prototype.keys = function () {\n        var keySet = documentKeySet();\n        for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {\n            var mutation = _a[_i];\n            keySet = keySet.add(mutation.key);\n        }\n        return keySet;\n    };\n    MutationBatch.prototype.equals = function (other) {\n        return (this.batchId === other.batchId &&\n            misc.arrayEquals(this.mutations, other.mutations));\n    };\n    /**\n     * Returns true if this mutation batch has already been removed from the\n     * mutation queue.\n     *\n     * Note that not all implementations of the MutationQueue necessarily use\n     * tombstones as part of their implementation and generally speaking no code\n     * outside the mutation queues should really care about this.\n     */\n    MutationBatch.prototype.isTombstone = function () {\n        return this.mutations.length === 0;\n    };\n    /** Converts this batch into a tombstone */\n    MutationBatch.prototype.toTombstone = function () {\n        return new MutationBatch(this.batchId, this.localWriteTime, []);\n    };\n    return MutationBatch;\n}());\nexport { MutationBatch };\n/** The result of applying a mutation batch to the backend. */\nvar MutationBatchResult = /** @class */ (function () {\n    function MutationBatchResult(batch, commitVersion, mutationResults, streamToken, \n        /**\n         * A pre-computed mapping from each mutated document to the resulting\n         * version.\n         */\n        docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.streamToken = streamToken;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=>version mapping (docVersions).\n     */\n    MutationBatchResult.from = function (batch, commitVersion, results, streamToken) {\n        assert(batch.mutations.length === results.length, 'Mutations sent ' +\n            batch.mutations.length +\n            ' must equal results received ' +\n            results.length);\n        var versionMap = documentVersionMap();\n        var mutations = batch.mutations;\n        for (var i = 0; i < mutations.length; i++) {\n            var version = results[i].version;\n            if (version === null) {\n                // deletes don't have a version, so we substitute the commitVersion\n                // of the entire batch.\n                version = commitVersion;\n            }\n            versionMap = versionMap.insert(mutations[i].key, version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);\n    };\n    return MutationBatchResult;\n}());\nexport { MutationBatchResult };\n\n//# sourceMappingURL=mutation_batch.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/mutation_batch.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AutoId } from '../util/misc';\nimport { IndexedDbMutationQueue } from './indexeddb_mutation_queue';\nimport { IndexedDbQueryCache } from './indexeddb_query_cache';\nimport { IndexedDbRemoteDocumentCache } from './indexeddb_remote_document_cache';\nimport { ALL_STORES, DbOwner } from './indexeddb_schema';\nimport { createOrUpgradeDb, SCHEMA_VERSION } from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDb } from './simple_db';\nvar LOG_TAG = 'IndexedDbPersistence';\n/** If the owner lease is older than 5 seconds, try to take ownership. */\nvar OWNER_LEASE_MAX_AGE_MS = 5000;\n/** Refresh the owner lease every 4 seconds while owner. */\nvar OWNER_LEASE_REFRESH_INTERVAL_MS = 4000;\n/** LocalStorage location to indicate a zombied ownerId (see class comment). */\nvar ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = 'zombiedOwnerId';\n/** Error when the owner lease cannot be acquired or is lost. */\nvar EXISTING_OWNER_ERROR_MSG = 'There is another tab open with offline' +\n    ' persistence enabled. Only one such tab is allowed at a time. The' +\n    ' other tab must be closed or persistence must be disabled.';\nvar UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing' +\n    ' IndexedDB or is known to have an incomplete implementation. Offline' +\n    ' persistence has been disabled.';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * Currently the Firestore SDK only supports a single consumer of the database,\n * but browsers obviously support multiple tabs. IndexedDbPersistence ensures a\n * single consumer of the database via an \"owner lease\" stored in the database.\n *\n * On startup, IndexedDbPersistence assigns itself a random \"ownerId\" and writes\n * it to a special \"owner\" object in the database (if no entry exists already or\n * the current entry is expired). This owner lease is then verified inside every\n * transaction to ensure the lease has not been lost.\n *\n * If a tab opts not to acquire the owner lease (because there's an existing\n * non-expired owner) or loses the owner lease, IndexedDbPersistence enters a\n * failed state and all subsequent operations will automatically fail.\n *\n * The current owner regularly refreshes the owner lease with new timestamps to\n * prevent newly-opened tabs from taking over ownership.\n *\n * Additionally there is an optimization so that when a tab is closed, the owner\n * lease is released immediately (this is especially important to make sure that\n * a refreshed tab is able to immediately re-acquire the owner lease).\n * Unfortunately, IndexedDB cannot be reliably used in window.unload since it is\n * an asynchronous API. So in addition to attempting to give up the lease,\n * the owner writes its ownerId to a \"zombiedOwnerId\" entry in LocalStorage\n * which acts as an indicator that another tab should go ahead and take the\n * owner lease immediately regardless of the current lease timestamp.\n */\nvar IndexedDbPersistence = /** @class */ (function () {\n    function IndexedDbPersistence(prefix, serializer) {\n        this.ownerId = this.generateOwnerId();\n        this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;\n        this.serializer = new LocalSerializer(serializer);\n        this.localStoragePrefix = prefix;\n    }\n    IndexedDbPersistence.prototype.start = function () {\n        var _this = this;\n        if (!IndexedDbPersistence.isAvailable()) {\n            this.persistenceError = new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n            return Promise.reject(this.persistenceError);\n        }\n        assert(!this.started, 'IndexedDbPersistence double-started!');\n        this.started = true;\n        return SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb)\n            .then(function (db) {\n            _this.simpleDb = db;\n        })\n            .then(function () { return _this.tryAcquireOwnerLease(); })\n            .then(function () {\n            _this.scheduleOwnerLeaseRefreshes();\n            _this.attachWindowUnloadHook();\n        });\n    };\n    IndexedDbPersistence.prototype.shutdown = function () {\n        var _this = this;\n        assert(this.started, 'IndexedDbPersistence shutdown without start!');\n        this.started = false;\n        this.detachWindowUnloadHook();\n        this.stopOwnerLeaseRefreshes();\n        return this.releaseOwnerLease().then(function () {\n            _this.simpleDb.close();\n        });\n    };\n    IndexedDbPersistence.prototype.getMutationQueue = function (user) {\n        return IndexedDbMutationQueue.forUser(user, this.serializer);\n    };\n    IndexedDbPersistence.prototype.getQueryCache = function () {\n        return new IndexedDbQueryCache(this.serializer);\n    };\n    IndexedDbPersistence.prototype.getRemoteDocumentCache = function () {\n        return new IndexedDbRemoteDocumentCache(this.serializer);\n    };\n    IndexedDbPersistence.prototype.runTransaction = function (action, operation) {\n        var _this = this;\n        if (this.persistenceError) {\n            return Promise.reject(this.persistenceError);\n        }\n        log.debug(LOG_TAG, 'Starting transaction:', action);\n        // Do all transactions as readwrite against all object stores, since we\n        // are the only reader/writer.\n        return this.simpleDb.runTransaction('readwrite', ALL_STORES, function (txn) {\n            // Verify that we still have the owner lease as part of every transaction.\n            return _this.ensureOwnerLease(txn).next(function () { return operation(txn); });\n        });\n    };\n    IndexedDbPersistence.isAvailable = function () {\n        return SimpleDb.isAvailable();\n    };\n    /**\n     * Generates a string used as a prefix when storing data in IndexedDB and\n     * LocalStorage.\n     */\n    IndexedDbPersistence.buildStoragePrefix = function (databaseInfo) {\n        // Use two different prefix formats:\n        //\n        //   * firestore / persistenceKey / projectID . databaseID / ...\n        //   * firestore / persistenceKey / projectID / ...\n        //\n        // projectIDs are DNS-compatible names and cannot contain dots\n        // so there's no danger of collisions.\n        var database = databaseInfo.databaseId.projectId;\n        if (!databaseInfo.databaseId.isDefaultDatabase) {\n            database += '.' + databaseInfo.databaseId.database;\n        }\n        return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';\n    };\n    /**\n     * Acquires the owner lease if there's no valid owner. Else returns a rejected\n     * promise.\n     */\n    IndexedDbPersistence.prototype.tryAcquireOwnerLease = function () {\n        var _this = this;\n        // NOTE: Don't use this.runTransaction, since it requires us to already\n        // have the lease.\n        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n            var store = txn.store(DbOwner.store);\n            return store.get('owner').next(function (dbOwner) {\n                if (!_this.validOwner(dbOwner)) {\n                    var newDbOwner = new DbOwner(_this.ownerId, Date.now());\n                    log.debug(LOG_TAG, 'No valid owner. Acquiring owner lease. Current owner:', dbOwner, 'New owner:', newDbOwner);\n                    return store.put('owner', newDbOwner);\n                }\n                else {\n                    log.debug(LOG_TAG, 'Valid owner already. Failing. Current owner:', dbOwner);\n                    _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n                    return PersistencePromise.reject(_this.persistenceError);\n                }\n            });\n        });\n    };\n    /** Checks the owner lease and deletes it if we are the current owner. */\n    IndexedDbPersistence.prototype.releaseOwnerLease = function () {\n        var _this = this;\n        // NOTE: Don't use this.runTransaction, since it requires us to already\n        // have the lease.\n        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n            var store = txn.store(DbOwner.store);\n            return store.get('owner').next(function (dbOwner) {\n                if (dbOwner !== null && dbOwner.ownerId === _this.ownerId) {\n                    log.debug(LOG_TAG, 'Releasing owner lease.');\n                    return store.delete('owner');\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            });\n        });\n    };\n    /**\n     * Checks the owner lease and returns a rejected promise if we are not the\n     * current owner. This should be included in every transaction to guard\n     * against losing the owner lease.\n     */\n    IndexedDbPersistence.prototype.ensureOwnerLease = function (txn) {\n        var _this = this;\n        var store = txn.store(DbOwner.store);\n        return store.get('owner').next(function (dbOwner) {\n            if (dbOwner === null || dbOwner.ownerId !== _this.ownerId) {\n                _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n                return PersistencePromise.reject(_this.persistenceError);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns true if the provided owner exists, has a recent timestamp, and\n     * isn't zombied.\n     *\n     * NOTE: To determine if the owner is zombied, this method reads from\n     * LocalStorage which could be mildly expensive.\n     */\n    IndexedDbPersistence.prototype.validOwner = function (dbOwner) {\n        var now = Date.now();\n        var minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;\n        var maxAcceptable = now;\n        if (dbOwner === null) {\n            return false; // no owner.\n        }\n        else if (dbOwner.leaseTimestampMs < minAcceptable) {\n            return false; // owner lease has expired.\n        }\n        else if (dbOwner.leaseTimestampMs > maxAcceptable) {\n            log.error('Persistence owner-lease is in the future. Discarding.', dbOwner);\n            return false;\n        }\n        else if (dbOwner.ownerId === this.getZombiedOwnerId()) {\n            return false; // owner's tab closed.\n        }\n        else {\n            return true;\n        }\n    };\n    /**\n     * Schedules a recurring timer to update the owner lease timestamp to prevent\n     * other tabs from taking the lease.\n     */\n    IndexedDbPersistence.prototype.scheduleOwnerLeaseRefreshes = function () {\n        var _this = this;\n        // NOTE: This doesn't need to be scheduled on the async queue and doing so\n        // would increase the chances of us not refreshing on time if the queue is\n        // backed up for some reason.\n        this.ownerLeaseRefreshHandle = setInterval(function () {\n            var txResult = _this.runTransaction('Refresh owner timestamp', function (txn) {\n                // NOTE: We don't need to validate the current owner contents, since\n                // runTransaction does that automatically.\n                var store = txn.store(DbOwner.store);\n                return store.put('owner', new DbOwner(_this.ownerId, Date.now()));\n            });\n            txResult.catch(function (reason) {\n                // Probably means we lost the lease. Report the error and stop trying to\n                // refresh the lease.\n                log.error(reason);\n                _this.stopOwnerLeaseRefreshes();\n            });\n        }, OWNER_LEASE_REFRESH_INTERVAL_MS);\n    };\n    IndexedDbPersistence.prototype.stopOwnerLeaseRefreshes = function () {\n        if (this.ownerLeaseRefreshHandle) {\n            clearInterval(this.ownerLeaseRefreshHandle);\n            this.ownerLeaseRefreshHandle = null;\n        }\n    };\n    /**\n     * Attaches a window.unload handler that will synchronously write our\n     * ownerId to a \"zombie owner id\" location in localstorage. This can be used\n     * by tabs trying to acquire the lease to determine that the lease should be\n     * acquired immediately even if the timestamp is recent. This is particularly\n     * important for the refresh case (so the tab correctly re-acquires the owner\n     * lease). LocalStorage is used for this rather than IndexedDb because it is\n     * a synchronous API and so can be used reliably from an unload handler.\n     */\n    IndexedDbPersistence.prototype.attachWindowUnloadHook = function () {\n        var _this = this;\n        this.windowUnloadHandler = function () {\n            // Record that we're zombied.\n            _this.setZombiedOwnerId(_this.ownerId);\n            // Attempt graceful shutdown (including releasing our owner lease), but\n            // there's no guarantee it will complete.\n            _this.shutdown();\n        };\n        window.addEventListener('unload', this.windowUnloadHandler);\n    };\n    IndexedDbPersistence.prototype.detachWindowUnloadHook = function () {\n        if (this.windowUnloadHandler) {\n            window.removeEventListener('unload', this.windowUnloadHandler);\n            this.windowUnloadHandler = null;\n        }\n    };\n    /**\n     * Returns any recorded \"zombied owner\" (i.e. a previous owner that became\n     * zombied due to their tab closing) from LocalStorage, or null if no such\n     * record exists.\n     */\n    IndexedDbPersistence.prototype.getZombiedOwnerId = function () {\n        try {\n            var zombiedOwnerId = window.localStorage.getItem(this.zombiedOwnerLocalStorageKey());\n            log.debug(LOG_TAG, 'Zombied ownerID from LocalStorage:', zombiedOwnerId);\n            return zombiedOwnerId;\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            log.error(LOG_TAG, 'Failed to get zombie owner id.', e);\n            return null;\n        }\n    };\n    /**\n     * Records a zombied owner (an owner that had its tab closed) in LocalStorage\n     * or, if passed null, deletes any recorded zombied owner.\n     */\n    IndexedDbPersistence.prototype.setZombiedOwnerId = function (zombieOwnerId) {\n        try {\n            if (zombieOwnerId === null) {\n                window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey());\n            }\n            else {\n                window.localStorage.setItem(this.zombiedOwnerLocalStorageKey(), zombieOwnerId);\n            }\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            log.error(LOG_TAG, 'Failed to set zombie owner id.', e);\n        }\n    };\n    IndexedDbPersistence.prototype.zombiedOwnerLocalStorageKey = function () {\n        return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;\n    };\n    IndexedDbPersistence.prototype.generateOwnerId = function () {\n        // For convenience, just use an AutoId.\n        return AutoId.newId();\n    };\n    /**\n     * The name of the main (and currently only) IndexedDB database. this name is\n     * appended to the prefix provided to the IndexedDbPersistence constructor.\n     */\n    IndexedDbPersistence.MAIN_DATABASE = 'main';\n    return IndexedDbPersistence;\n}());\nexport { IndexedDbPersistence };\n\n//# sourceMappingURL=indexeddb_persistence.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_persistence.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { documentKeySet, documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nvar LocalDocumentsView = /** @class */ (function () {\n    function LocalDocumentsView(remoteDocumentCache, mutationQueue) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @return Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    LocalDocumentsView.prototype.getDocument = function (transaction, key) {\n        var _this = this;\n        return this.remoteDocumentCache\n            .getEntry(transaction, key)\n            .next(function (remoteDoc) {\n            return _this.computeLocalDocument(transaction, key, remoteDoc);\n        });\n    };\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {\n        var _this = this;\n        var promises = [];\n        var results = maybeDocumentMap();\n        keys.forEach(function (key) {\n            promises.push(_this.getDocument(transaction, key).next(function (maybeDoc) {\n                // TODO(http://b/32275378): Don't conflate missing / deleted.\n                if (!maybeDoc) {\n                    maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());\n                }\n                results = results.insert(key, maybeDoc);\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(function () { return results; });\n    };\n    /** Performs a query against the local view of all documents. */\n    LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        if (DocumentKey.isDocumentKey(query.path)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query);\n        }\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(function (maybeDoc) {\n            var result = documentMap();\n            if (maybeDoc instanceof Document) {\n                result = result.insert(maybeDoc.key, maybeDoc);\n            }\n            return result;\n        });\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {\n        var _this = this;\n        // Query the remote documents and overlay mutations.\n        // TODO(mikelehen): There may be significant overlap between the mutations\n        // affecting these remote documents and the\n        // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n        var results;\n        return this.remoteDocumentCache\n            .getDocumentsMatchingQuery(transaction, query)\n            .next(function (queryResults) {\n            return _this.computeLocalDocuments(transaction, queryResults);\n        })\n            .next(function (promisedResults) {\n            results = promisedResults;\n            // Now use the mutation queue to discover any other documents that may\n            // match the query after applying mutations.\n            return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);\n        })\n            .next(function (matchingMutationBatches) {\n            var matchingKeys = documentKeySet();\n            for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {\n                var batch = matchingMutationBatches_1[_i];\n                for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                    var mutation = _b[_a];\n                    // TODO(mikelehen): PERF: Check if this mutation actually\n                    // affects the query to reduce work.\n                    if (!results.get(mutation.key)) {\n                        matchingKeys = matchingKeys.add(mutation.key);\n                    }\n                }\n            }\n            // Now add in the results for the matchingKeys.\n            var promises = [];\n            matchingKeys.forEach(function (key) {\n                promises.push(_this.getDocument(transaction, key).next(function (doc) {\n                    if (doc instanceof Document) {\n                        results = results.insert(doc.key, doc);\n                    }\n                }));\n            });\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            // Finally, filter out any documents that don't actually match\n            // the query.\n            results.forEach(function (key, doc) {\n                if (!query.matches(doc)) {\n                    results = results.remove(key);\n                }\n            });\n            return results;\n        });\n    };\n    /**\n     * Takes a remote document and applies local mutations to generate the local\n     * view of the document.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the document (necessary when remoteDocument\n     *     is null).\n     * @param document The base remote document to apply mutations to or null.\n     */\n    LocalDocumentsView.prototype.computeLocalDocument = function (transaction, documentKey, document) {\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKey(transaction, documentKey)\n            .next(function (batches) {\n            for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n                var batch = batches_1[_i];\n                document = batch.applyToLocalView(documentKey, document);\n            }\n            return document;\n        });\n    };\n    /**\n     * Takes a set of remote documents and applies local mutations to generate the\n     * local view of the documents.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documents The base remote documents to apply mutations to.\n     * @return The local view of the documents.\n     */\n    LocalDocumentsView.prototype.computeLocalDocuments = function (transaction, documents) {\n        var _this = this;\n        var promises = [];\n        documents.forEach(function (key, doc) {\n            promises.push(_this.computeLocalDocument(transaction, key, doc).next(function (mutatedDoc) {\n                if (mutatedDoc instanceof Document) {\n                    documents = documents.insert(mutatedDoc.key, mutatedDoc);\n                }\n                else if (mutatedDoc instanceof NoDocument) {\n                    documents = documents.remove(mutatedDoc.key);\n                }\n                else {\n                    fail('Unknown MaybeDocument: ' + mutatedDoc);\n                }\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(function () { return documents; });\n    };\n    return LocalDocumentsView;\n}());\nexport { LocalDocumentsView };\n\n//# sourceMappingURL=local_documents_view.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/local_documents_view.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { assert } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * NOTE: This class was introduced in iOS to work around a limitation in\n * LevelDB. Given IndexedDb has full transaction support with\n * read-your-own-writes capability, this class is not technically needed, but\n * has been preserved as a convenience and to aid portability.\n */\nvar RemoteDocumentChangeBuffer = /** @class */ (function () {\n    function RemoteDocumentChangeBuffer(remoteDocumentCache) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.changes = maybeDocumentMap();\n    }\n    /** Buffers a `RemoteDocumentCache.addEntry()` call. */\n    RemoteDocumentChangeBuffer.prototype.addEntry = function (maybeDocument) {\n        var changes = this.assertChanges();\n        this.changes = changes.insert(maybeDocument.key, maybeDocument);\n    };\n    // NOTE: removeEntry() is not presently necessary and so is omitted.\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the entry to look up.\n     * @return The cached Document or NoDocument entry, or null if we have nothing\n     * cached.\n     */\n    RemoteDocumentChangeBuffer.prototype.getEntry = function (transaction, documentKey) {\n        var changes = this.assertChanges();\n        var bufferedEntry = changes.get(documentKey);\n        if (bufferedEntry) {\n            return PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.remoteDocumentCache.getEntry(transaction, documentKey);\n        }\n    };\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    RemoteDocumentChangeBuffer.prototype.apply = function (transaction) {\n        var _this = this;\n        var changes = this.assertChanges();\n        var promises = [];\n        changes.forEach(function (key, maybeDoc) {\n            promises.push(_this.remoteDocumentCache.addEntry(transaction, maybeDoc));\n        });\n        // We should not be used to buffer any more changes.\n        this.changes = null;\n        return PersistencePromise.waitFor(promises);\n    };\n    /** Helper to assert this.changes is not null and return it. */\n    RemoteDocumentChangeBuffer.prototype.assertChanges = function () {\n        assert(this.changes !== null, 'Changes have already been applied.');\n        return this.changes;\n    };\n    return RemoteDocumentChangeBuffer;\n}());\nexport { RemoteDocumentChangeBuffer };\n\n//# sourceMappingURL=remote_document_change_buffer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/remote_document_change_buffer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetIdGenerator } from '../core/target_id_generator';\nimport { Timestamp } from '../core/timestamp';\nimport { documentKeySet } from '../model/collections';\nimport { BATCHID_UNKNOWN } from '../model/mutation_batch';\nimport { ResetMapping, UpdateMapping } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\nimport { LocalDocumentsView } from './local_documents_view';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryData, QueryPurpose } from './query_data';\nimport { ReferenceSet } from './reference_set';\nimport { RemoteDocumentChangeBuffer } from './remote_document_change_buffer';\nvar LOG_TAG = 'LocalStore';\n/**\n * Local storage in the Firestore client. Coordinates persistence components\n * like the mutation queue and remote document cache to present a\n * latency-compensated view of stored data.\n *\n * The LocalStore is responsible for accepting mutations from the Sync Engine.\n * Writes from the client are put into a queue as provisional Mutations until\n * they are processed by the RemoteStore and confirmed as having been written\n * to the server.\n *\n * The local store provides the local version of documents that have been\n * modified locally. It maintains the constraint:\n *\n *   LocalDocument = RemoteDocument + Active(LocalMutations)\n *\n * (Active mutations are those that are enqueued and have not been previously\n * acknowledged or rejected).\n *\n * The RemoteDocument (\"ground truth\") state is provided via the\n * applyChangeBatch method. It will be some version of a server-provided\n * document OR will be a server-provided document PLUS acknowledged mutations:\n *\n *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)\n *\n * Note that this \"dirty\" version of a RemoteDocument will not be identical to a\n * server base version, since it has LocalMutations added to it pending getting\n * an authoritative copy from the server.\n *\n * Since LocalMutations can be rejected by the server, we have to be able to\n * revert a LocalMutation that has already been applied to the LocalDocument\n * (typically done by replaying all remaining LocalMutations to the\n * RemoteDocument to re-apply).\n *\n * The LocalStore is responsible for the garbage collection of the documents it\n * contains. For now, it every doc referenced by a view, the mutation queue, or\n * the RemoteStore.\n *\n * It also maintains the persistence of mapping queries to resume tokens and\n * target ids. It needs to know this data about queries to properly know what\n * docs it would be allowed to garbage collect.\n *\n * The LocalStore must be able to efficiently execute queries against its local\n * cache of the documents, to provide the initial set of results before any\n * remote changes have been received.\n *\n * Note: In TypeScript, most methods return Promises since the implementation\n * may rely on fetching data from IndexedDB which is async.\n * These Promises will only be rejected on an I/O error or other internal\n * (unexpected) failure (e.g. failed assert) and always represent an\n * unrecoverable error (should be caught / reported by the async_queue).\n */\nvar LocalStore = /** @class */ (function () {\n    function LocalStore(\n        /** Manages our in-memory or durable persistence. */\n        persistence, initialUser, \n        /**\n           * The garbage collector collects documents that should no longer be\n           * cached (e.g. if they are no longer retained by the above reference sets\n           * and the garbage collector is performing eager collection).\n           */\n        garbageCollector) {\n        this.persistence = persistence;\n        this.garbageCollector = garbageCollector;\n        /**\n         * The set of document references maintained by any local views.\n         */\n        this.localViewReferences = new ReferenceSet();\n        /** Maps a targetID to data about its query. */\n        this.targetIds = {};\n        /** Used to generate targetIDs for queries tracked locally. */\n        this.targetIdGenerator = TargetIdGenerator.forLocalStore();\n        /**\n         * A heldBatchResult is a mutation batch result (from a write acknowledgement)\n         * that arrived before the watch stream got notified of a snapshot that\n         * includes the write. So we \"hold\" it until the watch stream catches up. It\n         * ensures that the local write remains visible (latency compensation) and\n         * doesn't temporarily appear reverted because the watch stream is slower than\n         * the write stream and so wasn't reflecting it.\n         *\n         * NOTE: Eventually we want to move this functionality into the remote store.\n         */\n        this.heldBatchResults = [];\n        this.mutationQueue = persistence.getMutationQueue(initialUser);\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\n        this.queryCache = persistence.getQueryCache();\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue);\n        this.garbageCollector.addGarbageSource(this.localViewReferences);\n        this.garbageCollector.addGarbageSource(this.queryCache);\n        this.garbageCollector.addGarbageSource(this.mutationQueue);\n    }\n    /** Performs any initial startup actions required by the local store. */\n    LocalStore.prototype.start = function () {\n        var _this = this;\n        return this.persistence.runTransaction('Start LocalStore', function (txn) {\n            return _this.startMutationQueue(txn).next(function () { return _this.startQueryCache(txn); });\n        });\n    };\n    /**\n     * Tells the LocalStore that the currently authenticated user has changed.\n     *\n     * In response the local store switches the mutation queue to the new user and\n     * returns any resulting document changes.\n     */\n    LocalStore.prototype.handleUserChange = function (user) {\n        var _this = this;\n        return this.persistence.runTransaction('Handle user change', function (txn) {\n            // Swap out the mutation queue, grabbing the pending mutation batches\n            // before and after.\n            var oldBatches;\n            return _this.mutationQueue\n                .getAllMutationBatches(txn)\n                .next(function (promisedOldBatches) {\n                oldBatches = promisedOldBatches;\n                _this.garbageCollector.removeGarbageSource(_this.mutationQueue);\n                _this.mutationQueue = _this.persistence.getMutationQueue(user);\n                _this.garbageCollector.addGarbageSource(_this.mutationQueue);\n                return _this.startMutationQueue(txn);\n            })\n                .next(function () {\n                // Recreate our LocalDocumentsView using the new\n                // MutationQueue.\n                _this.localDocuments = new LocalDocumentsView(_this.remoteDocuments, _this.mutationQueue);\n                return _this.mutationQueue.getAllMutationBatches(txn);\n            })\n                .next(function (newBatches) {\n                // Union the old/new changed keys.\n                var changedKeys = documentKeySet();\n                for (var _i = 0, _a = [oldBatches, newBatches]; _i < _a.length; _i++) {\n                    var batches = _a[_i];\n                    for (var _b = 0, batches_1 = batches; _b < batches_1.length; _b++) {\n                        var batch = batches_1[_b];\n                        for (var _c = 0, _d = batch.mutations; _c < _d.length; _c++) {\n                            var mutation = _d[_c];\n                            changedKeys = changedKeys.add(mutation.key);\n                        }\n                    }\n                }\n                // Return the set of all (potentially) changed documents as the\n                // result of the user change.\n                return _this.localDocuments.getDocuments(txn, changedKeys);\n            });\n        });\n    };\n    LocalStore.prototype.startQueryCache = function (txn) {\n        var _this = this;\n        return this.queryCache.start(txn).next(function () {\n            var targetId = _this.queryCache.getHighestTargetId();\n            _this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);\n        });\n    };\n    LocalStore.prototype.startMutationQueue = function (txn) {\n        var _this = this;\n        return this.mutationQueue\n            .start(txn)\n            .next(function () {\n            // If we have any leftover mutation batch results from a prior run,\n            // just drop them.\n            // TODO(http://b/33446471): We probably need to repopulate\n            // heldBatchResults or similar instead, but that is not\n            // straightforward since we're not persisting the write ack versions.\n            _this.heldBatchResults = [];\n            return _this.mutationQueue.getHighestAcknowledgedBatchId(txn);\n        })\n            .next(function (highestAck) {\n            // TODO(mikelehen): This is the only usage of\n            // getAllMutationBatchesThroughBatchId(). Consider removing it in\n            // favor of a getAcknowledgedBatches() method.\n            if (highestAck !== BATCHID_UNKNOWN) {\n                return _this.mutationQueue.getAllMutationBatchesThroughBatchId(txn, highestAck);\n            }\n            else {\n                return PersistencePromise.resolve([]);\n            }\n        })\n            .next(function (ackedBatches) {\n            if (ackedBatches.length > 0) {\n                return _this.mutationQueue.removeMutationBatches(txn, ackedBatches);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    };\n    /* Accept locally generated Mutations and commit them to storage. */\n    LocalStore.prototype.localWrite = function (mutations) {\n        var _this = this;\n        return this.persistence.runTransaction('Locally write mutations', function (txn) {\n            var batch;\n            var localWriteTime = Timestamp.now();\n            return _this.mutationQueue\n                .addMutationBatch(txn, localWriteTime, mutations)\n                .next(function (promisedBatch) {\n                batch = promisedBatch;\n                // TODO(koss): This is doing an N^2 update by replaying ALL the\n                // mutations on each document (instead of just the ones added) in\n                // this batch.\n                var keys = batch.keys();\n                return _this.localDocuments.getDocuments(txn, keys);\n            })\n                .next(function (changedDocuments) {\n                return { batchId: batch.batchId, changes: changedDocuments };\n            });\n        });\n    };\n    /**\n     * Acknowledge the given batch.\n     *\n     * On the happy path when a batch is acknowledged, the local store will\n     *\n     *  + remove the batch from the mutation queue;\n     *  + apply the changes to the remote document cache;\n     *  + recalculate the latency compensated view implied by those changes (there\n     *    may be mutations in the queue that affect the documents but haven't been\n     *    acknowledged yet); and\n     *  + give the changed documents back the sync engine\n     *\n     * @returns The resulting (modified) documents.\n     */\n    LocalStore.prototype.acknowledgeBatch = function (batchResult) {\n        var _this = this;\n        return this.persistence.runTransaction('Acknowledge batch', function (txn) {\n            var affected;\n            return _this.mutationQueue\n                .acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken)\n                .next(function () {\n                if (_this.shouldHoldBatchResult(batchResult.commitVersion)) {\n                    _this.heldBatchResults.push(batchResult);\n                    affected = documentKeySet();\n                    return PersistencePromise.resolve();\n                }\n                else {\n                    var documentBuffer_1 = new RemoteDocumentChangeBuffer(_this.remoteDocuments);\n                    return _this.releaseBatchResults(txn, [batchResult], documentBuffer_1).next(function (promisedAffectedKeys) {\n                        affected = promisedAffectedKeys;\n                        return documentBuffer_1.apply(txn);\n                    });\n                }\n            })\n                .next(function () {\n                return _this.mutationQueue.performConsistencyCheck(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, affected);\n            });\n        });\n    };\n    /**\n     * Remove mutations from the MutationQueue for the specified batch;\n     * LocalDocuments will be recalculated.\n     *\n     * @returns The resulting modified documents.\n     */\n    LocalStore.prototype.rejectBatch = function (batchId) {\n        var _this = this;\n        return this.persistence.runTransaction('Reject batch', function (txn) {\n            var toReject;\n            var affectedKeys;\n            return _this.mutationQueue\n                .lookupMutationBatch(txn, batchId)\n                .next(function (promisedToReject) {\n                assert(promisedToReject != null, 'Attempt to reject nonexistent batch!');\n                toReject = promisedToReject;\n                return _this.mutationQueue\n                    .getHighestAcknowledgedBatchId(txn)\n                    .next(function (lastAcked) {\n                    assert(batchId > lastAcked, \"Acknowledged batches can't be rejected.\");\n                    return toReject;\n                });\n            })\n                .next(function () {\n                return _this.removeMutationBatch(txn, toReject);\n            })\n                .next(function (promisedAffectedKeys) {\n                affectedKeys = promisedAffectedKeys;\n                return _this.mutationQueue.performConsistencyCheck(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, affectedKeys);\n            });\n        });\n    };\n    /** Returns the last recorded stream token for the current user. */\n    LocalStore.prototype.getLastStreamToken = function () {\n        var _this = this;\n        return this.persistence.runTransaction('Get last stream token', function (txn) {\n            return _this.mutationQueue.getLastStreamToken(txn);\n        });\n    };\n    /**\n     * Sets the stream token for the current user without acknowledging any\n     * mutation batch. This is usually only useful after a stream handshake or in\n     * response to an error that requires clearing the stream token.\n     */\n    LocalStore.prototype.setLastStreamToken = function (streamToken) {\n        var _this = this;\n        return this.persistence.runTransaction('Set last stream token', function (txn) {\n            return _this.mutationQueue.setLastStreamToken(txn, streamToken);\n        });\n    };\n    /**\n     * Returns the last consistent snapshot processed (used by the RemoteStore to\n     * determine whether to buffer incoming snapshots from the backend).\n     */\n    LocalStore.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.queryCache.getLastRemoteSnapshotVersion();\n    };\n    /**\n     * Update the \"ground-state\" (remote) documents. We assume that the remote\n     * event reflects any write batches that have been acknowledged or rejected\n     * (i.e. we do not re-apply local mutations to updates from this event).\n     *\n     * LocalDocuments are re-calculated if there are remaining mutations in the\n     * queue.\n     */\n    LocalStore.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        var documentBuffer = new RemoteDocumentChangeBuffer(this.remoteDocuments);\n        return this.persistence.runTransaction('Apply remote event', function (txn) {\n            var promises = [];\n            objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                // Do not ref/unref unassigned targetIds - it may lead to leaks.\n                var queryData = _this.targetIds[targetId];\n                if (!queryData)\n                    return;\n                var mapping = change.mapping;\n                if (mapping) {\n                    // First make sure that all references are deleted\n                    if (mapping instanceof ResetMapping) {\n                        promises.push(_this.queryCache\n                            .removeMatchingKeysForTargetId(txn, targetId)\n                            .next(function () {\n                            return _this.queryCache.addMatchingKeys(txn, mapping.documents, targetId);\n                        }));\n                    }\n                    else if (mapping instanceof UpdateMapping) {\n                        promises.push(_this.queryCache\n                            .removeMatchingKeys(txn, mapping.removedDocuments, targetId)\n                            .next(function () {\n                            return _this.queryCache.addMatchingKeys(txn, mapping.addedDocuments, targetId);\n                        }));\n                    }\n                    else {\n                        return fail('Unknown mapping type: ' + JSON.stringify(mapping));\n                    }\n                }\n                // Update the resume token if the change includes one. Don't clear\n                // any preexisting value.\n                var resumeToken = change.resumeToken;\n                if (resumeToken.length > 0) {\n                    queryData = queryData.update({\n                        resumeToken: resumeToken,\n                        snapshotVersion: change.snapshotVersion\n                    });\n                    _this.targetIds[targetId] = queryData;\n                    promises.push(_this.queryCache.addQueryData(txn, queryData));\n                }\n            });\n            var changedDocKeys = documentKeySet();\n            remoteEvent.documentUpdates.forEach(function (key, doc) {\n                changedDocKeys = changedDocKeys.add(key);\n                promises.push(documentBuffer.getEntry(txn, key).next(function (existingDoc) {\n                    // Make sure we don't apply an old document version to the remote\n                    // cache, though we make an exception for SnapshotVersion.MIN which\n                    // can happen for manufactured events (e.g. in the case of a limbo\n                    // document resolution failing).\n                    if (existingDoc == null ||\n                        doc.version.equals(SnapshotVersion.MIN) ||\n                        doc.version.compareTo(existingDoc.version) >= 0) {\n                        documentBuffer.addEntry(doc);\n                    }\n                    else {\n                        log.debug(LOG_TAG, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n                    }\n                    // The document might be garbage because it was unreferenced by\n                    // everything. Make sure to mark it as garbage if it is...\n                    _this.garbageCollector.addPotentialGarbageKey(key);\n                }));\n            });\n            // HACK: The only reason we allow a null snapshot version is so that we\n            // can synthesize remote events when we get permission denied errors while\n            // trying to resolve the state of a locally cached document that is in\n            // limbo.\n            var lastRemoteVersion = _this.queryCache.getLastRemoteSnapshotVersion();\n            var remoteVersion = remoteEvent.snapshotVersion;\n            if (!remoteVersion.equals(SnapshotVersion.MIN)) {\n                assert(remoteVersion.compareTo(lastRemoteVersion) >= 0, 'Watch stream reverted to previous snapshot?? ' +\n                    remoteVersion +\n                    ' < ' +\n                    lastRemoteVersion);\n                promises.push(_this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion));\n            }\n            var releasedWriteKeys;\n            return PersistencePromise.waitFor(promises)\n                .next(function () { return _this.releaseHeldBatchResults(txn, documentBuffer); })\n                .next(function (promisedReleasedWriteKeys) {\n                releasedWriteKeys = promisedReleasedWriteKeys;\n                return documentBuffer.apply(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, changedDocKeys.unionWith(releasedWriteKeys));\n            });\n        });\n    };\n    /**\n     * Notify local store of the changed views to locally pin documents.\n     */\n    LocalStore.prototype.notifyLocalViewChanges = function (viewChanges) {\n        var _this = this;\n        return this.persistence.runTransaction('Notify local view changes', function (txn) {\n            var promises = [];\n            var _loop_1 = function (view) {\n                promises.push(_this.queryCache\n                    .getQueryData(txn, view.query)\n                    .next(function (queryData) {\n                    assert(queryData !== null, 'Local view changes contain unallocated query.');\n                    var targetId = queryData.targetId;\n                    _this.localViewReferences.addReferences(view.addedKeys, targetId);\n                    _this.localViewReferences.removeReferences(view.removedKeys, targetId);\n                }));\n            };\n            for (var _i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {\n                var view = viewChanges_1[_i];\n                _loop_1(view);\n            }\n            return PersistencePromise.waitFor(promises);\n        });\n    };\n    /**\n     * Gets the mutation batch after the passed in batchId in the mutation queue\n     *  or null if empty.\n     *  @param afterBatchId If provided, the batch to search after.\n     *  @returns The next mutation or null if there wasn't one.\n     */\n    LocalStore.prototype.nextMutationBatch = function (afterBatchId) {\n        var _this = this;\n        return this.persistence.runTransaction('Get next mutation batch', function (txn) {\n            if (afterBatchId === undefined) {\n                afterBatchId = BATCHID_UNKNOWN;\n            }\n            return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n        });\n    };\n    /**\n     * Read the current value of a Document with a given key or null if not\n     * found - used for testing.\n     */\n    LocalStore.prototype.readDocument = function (key) {\n        var _this = this;\n        return this.persistence.runTransaction('read document', function (txn) {\n            return _this.localDocuments.getDocument(txn, key);\n        });\n    };\n    /**\n     * Assigns the given query an internal ID so that its results can be pinned so\n     * they don't get GC'd. A query must be allocated in the local store before\n     * the store can be used to manage its view.\n     */\n    LocalStore.prototype.allocateQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Allocate query', function (txn) {\n            var queryData;\n            return _this.queryCache\n                .getQueryData(txn, query)\n                .next(function (cached) {\n                if (cached) {\n                    // This query has been listened to previously, so reuse the\n                    // previous targetID.\n                    // TODO(mcg): freshen last accessed date?\n                    queryData = cached;\n                    return PersistencePromise.resolve();\n                }\n                else {\n                    var targetId = _this.targetIdGenerator.next();\n                    queryData = new QueryData(query, targetId, QueryPurpose.Listen);\n                    return _this.queryCache.addQueryData(txn, queryData);\n                }\n            })\n                .next(function () {\n                assert(!_this.targetIds[queryData.targetId], 'Tried to allocate an already allocated query: ' + query);\n                _this.targetIds[queryData.targetId] = queryData;\n                return queryData;\n            });\n        });\n    };\n    /** Unpin all the documents associated with the given query. */\n    LocalStore.prototype.releaseQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Release query', function (txn) {\n            return _this.queryCache\n                .getQueryData(txn, query)\n                .next(function (queryData) {\n                assert(queryData != null, 'Tried to release nonexistent query: ' + query);\n                _this.localViewReferences.removeReferencesForId(queryData.targetId);\n                delete _this.targetIds[queryData.targetId];\n                if (_this.garbageCollector.isEager) {\n                    return _this.queryCache.removeQueryData(txn, queryData);\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            })\n                .next(function () {\n                // If this was the last watch target, then we won't get any more\n                // watch snapshots, so we should release any held batch results.\n                if (objUtils.isEmpty(_this.targetIds)) {\n                    var documentBuffer_2 = new RemoteDocumentChangeBuffer(_this.remoteDocuments);\n                    return _this.releaseHeldBatchResults(txn, documentBuffer_2).next(function () {\n                        documentBuffer_2.apply(txn);\n                    });\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            });\n        });\n    };\n    /**\n     * Runs the specified query against all the documents in the local store and\n     * returns the results.\n     */\n    LocalStore.prototype.executeQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Execute query', function (txn) {\n            return _this.localDocuments.getDocumentsMatchingQuery(txn, query);\n        });\n    };\n    /**\n     * Returns the keys of the documents that are associated with the given\n     * target id in the remote table.\n     */\n    LocalStore.prototype.remoteDocumentKeys = function (targetId) {\n        var _this = this;\n        return this.persistence.runTransaction('Remote document keys', function (txn) {\n            return _this.queryCache.getMatchingKeysForTargetId(txn, targetId);\n        });\n    };\n    /**\n     * Collect garbage if necessary.\n     * Should be called periodically by Sync Engine to recover resources. The\n     * implementation must guarantee that GC won't happen in other places than\n     * this method call.\n     */\n    LocalStore.prototype.collectGarbage = function () {\n        var _this = this;\n        // Call collectGarbage regardless of whether isGCEnabled so the referenceSet\n        // doesn't continue to accumulate the garbage keys.\n        return this.persistence.runTransaction('Garbage collection', function (txn) {\n            return _this.garbageCollector.collectGarbage(txn).next(function (garbage) {\n                var promises = [];\n                garbage.forEach(function (key) {\n                    promises.push(_this.remoteDocuments.removeEntry(txn, key));\n                });\n                return PersistencePromise.waitFor(promises);\n            });\n        });\n    };\n    LocalStore.prototype.releaseHeldBatchResults = function (txn, documentBuffer) {\n        var toRelease = [];\n        for (var _i = 0, _a = this.heldBatchResults; _i < _a.length; _i++) {\n            var batchResult = _a[_i];\n            if (!this.isRemoteUpToVersion(batchResult.commitVersion)) {\n                break;\n            }\n            toRelease.push(batchResult);\n        }\n        if (toRelease.length === 0) {\n            return PersistencePromise.resolve(documentKeySet());\n        }\n        else {\n            this.heldBatchResults.splice(0, toRelease.length);\n            return this.releaseBatchResults(txn, toRelease, documentBuffer);\n        }\n    };\n    LocalStore.prototype.isRemoteUpToVersion = function (version) {\n        // If there are no watch targets, then we won't get remote snapshots, and\n        // we are always \"up-to-date.\"\n        var lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n        return (version.compareTo(lastRemoteVersion) <= 0 ||\n            objUtils.isEmpty(this.targetIds));\n    };\n    LocalStore.prototype.shouldHoldBatchResult = function (version) {\n        // Check if watcher isn't up to date or prior results are already held.\n        return (!this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0);\n    };\n    LocalStore.prototype.releaseBatchResults = function (txn, batchResults, documentBuffer) {\n        var _this = this;\n        var promiseChain = PersistencePromise.resolve();\n        var _loop_2 = function (batchResult) {\n            promiseChain = promiseChain.next(function () {\n                return _this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer);\n            });\n        };\n        for (var _i = 0, batchResults_1 = batchResults; _i < batchResults_1.length; _i++) {\n            var batchResult = batchResults_1[_i];\n            _loop_2(batchResult);\n        }\n        return promiseChain.next(function () {\n            return _this.removeMutationBatches(txn, batchResults.map(function (result) { return result.batch; }));\n        });\n    };\n    LocalStore.prototype.removeMutationBatch = function (txn, batch) {\n        return this.removeMutationBatches(txn, [batch]);\n    };\n    /** Removes all the mutation batches named in the given array. */\n    LocalStore.prototype.removeMutationBatches = function (txn, batches) {\n        var affectedDocs = documentKeySet();\n        for (var _i = 0, batches_2 = batches; _i < batches_2.length; _i++) {\n            var batch = batches_2[_i];\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                affectedDocs = affectedDocs.add(key);\n            }\n        }\n        return this.mutationQueue\n            .removeMutationBatches(txn, batches)\n            .next(function () { return affectedDocs; });\n    };\n    LocalStore.prototype.applyWriteToRemoteDocuments = function (txn, batchResult, documentBuffer) {\n        var batch = batchResult.batch;\n        var docKeys = batch.keys();\n        var promiseChain = PersistencePromise.resolve();\n        docKeys.forEach(function (docKey) {\n            promiseChain = promiseChain\n                .next(function () {\n                return documentBuffer.getEntry(txn, docKey);\n            })\n                .next(function (remoteDoc) {\n                var doc = remoteDoc;\n                var ackVersion = batchResult.docVersions.get(docKey);\n                assert(ackVersion !== null, 'ackVersions should contain every doc in the write.');\n                if (!doc || doc.version.compareTo(ackVersion) < 0) {\n                    doc = batch.applyToRemoteDocument(docKey, doc, batchResult);\n                    if (!doc) {\n                        assert(!remoteDoc, 'Mutation batch ' +\n                            batch +\n                            ' applied to document ' +\n                            remoteDoc +\n                            ' resulted in null');\n                    }\n                    else {\n                        documentBuffer.addEntry(doc);\n                    }\n                }\n            });\n        });\n        return promiseChain;\n    };\n    return LocalStore;\n}());\nexport { LocalStore };\n\n//# sourceMappingURL=local_store.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/local_store.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DocumentKey } from '../model/document_key';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PersistencePromise } from './persistence_promise';\nimport { DocReference } from './reference_set';\nvar MemoryMutationQueue = /** @class */ (function () {\n    function MemoryMutationQueue() {\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** The highest acknowledged mutation in the queue. */\n        this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        /** The last received stream token from the server, used to acknowledge which\n         * responses the client has processed. Stream tokens are opaque checkpoint\n         * markers whose only real value is their inclusion in the next request.\n         */\n        this.lastStreamToken = emptyByteString();\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n    }\n    MemoryMutationQueue.prototype.start = function (transaction) {\n        // NOTE: The queue may be shutdown / started multiple times, since we\n        // maintain the queue for the duration of the app session in case a user\n        // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n        // accommodate tests that expect as much), we reset nextBatchId and\n        // highestAcknowledgedBatchId if the queue is empty.\n        if (this.mutationQueue.length === 0) {\n            this.nextBatchId = 1;\n            this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        }\n        assert(this.highestAcknowledgedBatchId < this.nextBatchId, 'highestAcknowledgedBatchId must be less than the nextBatchId');\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.checkEmpty = function (transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\n    };\n    MemoryMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.nextBatchId);\n    };\n    MemoryMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n    };\n    MemoryMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.highestAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        var batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');\n        // Verify that the batch in the queue is the one to be acknowledged.\n        var check = this.mutationQueue[batchIndex];\n        assert(batchId === check.batchId, 'Queue ordering failure: expected batch ' +\n            batchId +\n            ', got batch ' +\n            check.batchId);\n        assert(!check.isTombstone(), \"Can't acknowledge a previously removed batch\");\n        this.highestAcknowledgedBatchId = batchId;\n        this.lastStreamToken = streamToken;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return PersistencePromise.resolve(this.lastStreamToken);\n    };\n    MemoryMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.lastStreamToken = streamToken;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        assert(mutations.length !== 0, 'Mutation batches should not be empty');\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            var prior = this.mutationQueue[this.mutationQueue.length - 1];\n            assert(prior.batchId < batchId, 'Mutation batchIDs must be monotonically increasing order');\n        }\n        var batch = new MutationBatch(batchId, localWriteTime, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key.\n        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n            var mutation = mutations_1[_i];\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\n        }\n        return PersistencePromise.resolve(batch);\n    };\n    MemoryMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\n    };\n    MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var size = this.mutationQueue.length;\n        // All batches with batchId <= this.highestAcknowledgedBatchId have been\n        // acknowledged so the first unacknowledged batch after batchID will have a\n        // batchID larger than both of these values.\n        batchId = Math.max(batchId + 1, this.highestAcknowledgedBatchId);\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        var rawIndex = this.indexOfBatchId(batchId);\n        var index = rawIndex < 0 ? 0 : rawIndex;\n        // Finally return the first non-tombstone batch.\n        for (; index < size; index++) {\n            var batch = this.mutationQueue[index];\n            if (!batch.isTombstone()) {\n                return PersistencePromise.resolve(batch);\n            }\n        }\n        return PersistencePromise.resolve(null);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var count = this.mutationQueue.length;\n        var endIndex = this.indexOfBatchId(batchId);\n        if (endIndex < 0) {\n            endIndex = 0;\n        }\n        else if (endIndex >= count) {\n            endIndex = count;\n        }\n        else {\n            // The endIndex is in the queue so increment to pull everything in the\n            // queue including it.\n            endIndex++;\n        }\n        return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(endIndex));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        var start = new DocReference(documentKey, 0);\n        var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n        var result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {\n            assert(documentKey.equals(ref.key), \"Should only iterate over a single key's batches\");\n            var batch = _this.findMutationBatch(ref.targetOrBatchId);\n            assert(batch !== null, 'Batches in the index must exist in the main table');\n            result.push(batch);\n        });\n        return PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        var prefix = query.path;\n        var immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        var startPath = prefix;\n        if (!DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        var start = new DocReference(new DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        var uniqueBatchIDs = new SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(function (ref) {\n            var rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        var result = [];\n        uniqueBatchIDs.forEach(function (batchId) {\n            var batch = _this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var batchCount = batches.length;\n        assert(batchCount > 0, 'Should not remove mutations when none exist.');\n        var firstBatchId = batches[0].batchId;\n        var queueCount = this.mutationQueue.length;\n        // Find the position of the first batch for removal. This need not be the\n        // first entry in the queue.\n        var startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n        assert(this.mutationQueue[startIndex].batchId === firstBatchId, 'Removed batches must exist in the queue');\n        // Check that removed batches are contiguous (while excluding tombstones).\n        var batchIndex = 1;\n        var queueIndex = startIndex + 1;\n        while (batchIndex < batchCount && queueIndex < queueCount) {\n            var batch = this.mutationQueue[queueIndex];\n            if (batch.isTombstone()) {\n                queueIndex++;\n                continue;\n            }\n            assert(batch.batchId === batches[batchIndex].batchId, 'Removed batches must be contiguous in the queue');\n            batchIndex++;\n            queueIndex++;\n        }\n        // Only actually remove batches if removing at the front of the queue.\n        // Previously rejected batches may have left tombstones in the queue, so\n        // expand the removal range to include any tombstones.\n        if (startIndex === 0) {\n            for (; queueIndex < queueCount; queueIndex++) {\n                var batch = this.mutationQueue[queueIndex];\n                if (!batch.isTombstone()) {\n                    break;\n                }\n            }\n            var length_1 = queueIndex - startIndex;\n            this.mutationQueue.splice(startIndex, length_1);\n        }\n        else {\n            // Mark the tombstones\n            for (var i = startIndex; i < queueIndex; i++) {\n                this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n            }\n        }\n        var references = this.batchesByDocumentKey;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            var batchId = batch.batchId;\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                if (this.garbageCollector !== null) {\n                    this.garbageCollector.addPotentialGarbageKey(key);\n                }\n                var ref = new DocReference(key, batchId);\n                references = references.delete(ref);\n            }\n        }\n        this.batchesByDocumentKey = references;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    MemoryMutationQueue.prototype.containsKey = function (txn, key) {\n        var ref = new DocReference(key, 0);\n        var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(key.equals(firstRef && firstRef.key));\n    };\n    MemoryMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        if (this.mutationQueue.length === 0) {\n            assert(this.batchesByDocumentKey.isEmpty(), 'Document leak -- detected dangling mutation references when queue is empty.');\n        }\n        return PersistencePromise.resolve();\n    };\n    /**\n     * A private helper that collects all the mutations batches in the queue up to\n     * but not including the given endIndex. All tombstones in the queue are\n     * excluded.\n     */\n    MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function (endIndex) {\n        var result = [];\n        for (var i = 0; i < endIndex; i++) {\n            var batch = this.mutationQueue[i];\n            if (!batch.isTombstone()) {\n                result.push(batch);\n            }\n        }\n        return result;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId The batchId to search for\n     * @param action A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    MemoryMutationQueue.prototype.indexOfExistingBatchId = function (batchId, action) {\n        var index = this.indexOfBatchId(batchId);\n        assert(index >= 0 && index < this.mutationQueue.length, 'Batches must exist to be ' + action);\n        return index;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @return The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been remvoed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    MemoryMutationQueue.prototype.indexOfBatchId = function (batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        var firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    };\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficent.\n     */\n    MemoryMutationQueue.prototype.findMutationBatch = function (batchId) {\n        var index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        var batch = this.mutationQueue[index];\n        assert(batch.batchId === batchId, 'If found batch must match');\n        return batch.isTombstone() ? null : batch;\n    };\n    return MemoryMutationQueue;\n}());\nexport { MemoryMutationQueue };\n\n//# sourceMappingURL=memory_mutation_queue.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/memory_mutation_queue.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ObjectMap } from '../util/obj_map';\nimport { PersistencePromise } from './persistence_promise';\nimport { ReferenceSet } from './reference_set';\nvar MemoryQueryCache = /** @class */ (function () {\n    function MemoryQueryCache() {\n        /**\n         * Maps a query to the data about that query\n         */\n        this.queries = new ObjectMap(function (q) { return q.canonicalId(); });\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new ReferenceSet();\n    }\n    MemoryQueryCache.prototype.start = function (transaction) {\n        // Nothing to do.\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    MemoryQueryCache.prototype.getHighestTargetId = function () {\n        return this.highestTargetId;\n    };\n    MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        this.queries.set(queryData.query, queryData);\n        var targetId = queryData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.highestTargetId = targetId;\n        }\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        this.queries.delete(queryData.query);\n        this.references.removeReferencesForId(queryData.targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getQueryData = function (transaction, query) {\n        var queryData = this.queries.get(query) || null;\n        return PersistencePromise.resolve(queryData);\n    };\n    MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var matchingKeys = this.references.referencesForId(targetId);\n        return PersistencePromise.resolve(matchingKeys);\n    };\n    MemoryQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.references.setGarbageCollector(gc);\n    };\n    MemoryQueryCache.prototype.containsKey = function (txn, key) {\n        return this.references.containsKey(txn, key);\n    };\n    return MemoryQueryCache;\n}());\nexport { MemoryQueryCache };\n\n//# sourceMappingURL=memory_query_cache.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/memory_query_cache.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { PersistencePromise } from './persistence_promise';\nvar MemoryRemoteDocumentCache = /** @class */ (function () {\n    function MemoryRemoteDocumentCache() {\n        this.docs = maybeDocumentMap();\n    }\n    MemoryRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        this.docs = this.docs.insert(maybeDocument.key, maybeDocument);\n        return PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        this.docs = this.docs.remove(documentKey);\n        return PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        return PersistencePromise.resolve(this.docs.get(documentKey));\n    };\n    MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var prefix = new DocumentKey(query.path.child(''));\n        var iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            var _a = iterator.getNext(), key = _a.key, maybeDoc = _a.value;\n            if (!query.path.isPrefixOf(key.path)) {\n                break;\n            }\n            if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        }\n        return PersistencePromise.resolve(results);\n    };\n    return MemoryRemoteDocumentCache;\n}());\nexport { MemoryRemoteDocumentCache };\n\n//# sourceMappingURL=memory_remote_document_cache.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/memory_remote_document_cache.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { MemoryMutationQueue } from './memory_mutation_queue';\nimport { MemoryQueryCache } from './memory_query_cache';\nimport { MemoryRemoteDocumentCache } from './memory_remote_document_cache';\nvar LOG_TAG = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nvar MemoryPersistence = /** @class */ (function () {\n    function MemoryPersistence() {\n        /**\n         * Note that these are retained here to make it easier to write tests\n         * affecting both the in-memory and IndexedDB-backed persistence layers. Tests\n         * can create a new LocalStore wrapping this Persistence instance and this\n         * will make the in-memory persistence layer behave as if it were actually\n         * persisting values.\n         */\n        this.mutationQueues = {};\n        this.remoteDocumentCache = new MemoryRemoteDocumentCache();\n        this.queryCache = new MemoryQueryCache();\n        this.started = false;\n    }\n    MemoryPersistence.prototype.start = function () {\n        assert(!this.started, 'MemoryPersistence double-started!');\n        this.started = true;\n        // No durable state to read on startup.\n        return Promise.resolve();\n    };\n    MemoryPersistence.prototype.shutdown = function () {\n        // No durable state to ensure is closed on shutdown.\n        assert(this.started, 'MemoryPersistence shutdown without start!');\n        this.started = false;\n        return Promise.resolve();\n    };\n    MemoryPersistence.prototype.getMutationQueue = function (user) {\n        var queue = this.mutationQueues[user.toKey()];\n        if (!queue) {\n            queue = new MemoryMutationQueue();\n            this.mutationQueues[user.toKey()] = queue;\n        }\n        return queue;\n    };\n    MemoryPersistence.prototype.getQueryCache = function () {\n        return this.queryCache;\n    };\n    MemoryPersistence.prototype.getRemoteDocumentCache = function () {\n        return this.remoteDocumentCache;\n    };\n    MemoryPersistence.prototype.runTransaction = function (action, operation) {\n        debug(LOG_TAG, 'Starting transaction:', action);\n        return operation(new MemoryPersistenceTransaction()).toPromise();\n    };\n    return MemoryPersistence;\n}());\nexport { MemoryPersistence };\n/** Dummy class since memory persistence doesn't actually use transactions. */\nvar MemoryPersistenceTransaction = /** @class */ (function () {\n    function MemoryPersistenceTransaction() {\n    }\n    return MemoryPersistenceTransaction;\n}());\n\n//# sourceMappingURL=memory_persistence.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/memory_persistence.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A garbage collector implementation that does absolutely nothing. It ignores\n * all addGarbageSource and addPotentialGarbageKey messages and and never\n * produces any garbage.\n */\nvar NoOpGarbageCollector = /** @class */ (function () {\n    function NoOpGarbageCollector() {\n        this.isEager = false;\n    }\n    NoOpGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        // Not tracking garbage so don't track sources.\n    };\n    NoOpGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        // Not tracking garbage so don't track sources.\n    };\n    NoOpGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        // Not tracking garbage so ignore.\n    };\n    NoOpGarbageCollector.prototype.collectGarbage = function (txn) {\n        return PersistencePromise.resolve(documentKeySet());\n    };\n    return NoOpGarbageCollector;\n}());\nexport { NoOpGarbageCollector };\n\n//# sourceMappingURL=no_op_garbage_collector.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/no_op_garbage_collector.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Deferred = /** @class */ (function () {\n    function Deferred() {\n        var _this = this;\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n    }\n    return Deferred;\n}());\nexport { Deferred };\n/**\n * Takes an array of values and sequences them using the promise (or value)\n * returned by the supplied callback. The callback for each item is called\n * after the promise is resolved for the previous item.\n * The function returns a promise which is resolved after the promise for\n * the last item is resolved.\n */\nexport function sequence(values, fn, initialValue) {\n    var result = Promise.resolve(initialValue);\n    values.forEach(function (value) {\n        result = result.then(function (lastResult) { return fn(value, lastResult); });\n    });\n    return result;\n}\n\n//# sourceMappingURL=promise.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/promise.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as log from '../util/log';\nimport { Deferred } from '../util/promise';\nvar LOG_TAG = 'ExponentialBackoff';\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nvar ExponentialBackoff = /** @class */ (function () {\n    function ExponentialBackoff(\n        /**\n           * The initial delay (used as the base delay on the first retry attempt).\n           * Note that jitter will still be applied, so the actual delay could be as\n           * little as 0.5*initialDelayMs.\n           */\n        initialDelayMs, \n        /**\n           * The multiplier to use to determine the extended base delay after each\n           * attempt.\n           */\n        backoffFactor, \n        /**\n           * The maximum base delay after which no further backoff is performed.\n           * Note that jitter will still be applied, so the actual delay could be as\n           * much as 1.5*maxDelayMs.\n           */\n        maxDelayMs) {\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    ExponentialBackoff.prototype.reset = function () {\n        this.currentBaseMs = 0;\n    };\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    ExponentialBackoff.prototype.resetToMax = function () {\n        this.currentBaseMs = this.maxDelayMs;\n    };\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts.\n     */\n    ExponentialBackoff.prototype.backoffAndWait = function () {\n        var def = new Deferred();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n        if (this.currentBaseMs > 0) {\n            log.debug(LOG_TAG, \"Backing off for \" + delayWithJitterMs + \" ms \" +\n                (\"(base delay: \" + this.currentBaseMs + \" ms)\"));\n        }\n        setTimeout(function () {\n            def.resolve();\n        }, delayWithJitterMs);\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n        return def.promise;\n    };\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    ExponentialBackoff.prototype.jitterDelayMs = function () {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    };\n    return ExponentialBackoff;\n}());\nexport { ExponentialBackoff };\n\n//# sourceMappingURL=backoff.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/backoff.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { assert } from '../util/assert';\nimport { PersistentListenStream, PersistentWriteStream } from './persistent_stream';\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\nvar Datastore = /** @class */ (function () {\n    function Datastore(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {\n        this.databaseInfo = databaseInfo;\n        this.queue = queue;\n        this.connection = connection;\n        this.credentials = credentials;\n        this.serializer = serializer;\n        this.initialBackoffDelay = initialBackoffDelay;\n    }\n    Datastore.prototype.newPersistentWriteStream = function (listener) {\n        return new PersistentWriteStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, listener, this.initialBackoffDelay);\n    };\n    Datastore.prototype.newPersistentWatchStream = function (listener) {\n        return new PersistentListenStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, listener, this.initialBackoffDelay);\n    };\n    Datastore.prototype.commit = function (mutations) {\n        var _this = this;\n        var params = {\n            writes: mutations.map(function (m) { return _this.serializer.toMutation(m); })\n        };\n        return this.invokeRPC('commit', params).then(function (response) {\n            return _this.serializer.fromWriteResults(response.writeResults);\n        });\n    };\n    Datastore.prototype.lookup = function (keys) {\n        var _this = this;\n        var params = {\n            documents: keys.map(function (k) { return _this.serializer.toName(k); })\n        };\n        return this.invokeRPC('batchGet', params).then(function (response) {\n            var docs = maybeDocumentMap();\n            response.forEach(function (proto) {\n                var doc = _this.serializer.fromMaybeDocument(proto);\n                docs = docs.insert(doc.key, doc);\n            });\n            var result = [];\n            keys.forEach(function (key) {\n                var doc = docs.get(key);\n                assert(!!doc, 'Missing entity in write response for ' + key);\n                result.push(doc);\n            });\n            return result;\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC. */\n    Datastore.prototype.invokeRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invoke(rpcName, request, token);\n        });\n    };\n    return Datastore;\n}());\nexport { Datastore };\n\n//# sourceMappingURL=datastore.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/datastore.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from './snapshot_version';\nimport { documentVersionMap } from '../model/collections';\nimport { NoDocument } from '../model/document';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { Code, FirestoreError } from '../util/error';\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nvar Transaction = /** @class */ (function () {\n    function Transaction(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = documentVersionMap();\n        this.mutations = [];\n        this.committed = false;\n    }\n    Transaction.prototype.recordVersion = function (doc) {\n        var docVersion = doc.version;\n        if (doc instanceof NoDocument) {\n            // For deleted docs, we must use baseVersion 0 when we overwrite them.\n            docVersion = SnapshotVersion.forDeletedDoc();\n        }\n        var existingVersion = this.readVersions.get(doc.key);\n        if (existingVersion !== null) {\n            if (!docVersion.equals(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions = this.readVersions.insert(doc.key, docVersion);\n        }\n    };\n    Transaction.prototype.lookup = function (keys) {\n        var _this = this;\n        if (this.committed) {\n            return Promise.reject('Transaction has already completed.');\n        }\n        if (this.mutations.length > 0) {\n            return Promise.reject('Transactions lookups are invalid after writes.');\n        }\n        return this.datastore.lookup(keys).then(function (docs) {\n            docs.forEach(function (doc) { return _this.recordVersion(doc); });\n            return docs;\n        });\n    };\n    Transaction.prototype.write = function (mutations) {\n        if (this.committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');\n        }\n        this.mutations = this.mutations.concat(mutations);\n    };\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    Transaction.prototype.precondition = function (key) {\n        var version = this.readVersions.get(key);\n        if (version) {\n            return Precondition.updateTime(version);\n        }\n        else {\n            return Precondition.NONE;\n        }\n    };\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    Transaction.prototype.preconditionForUpdate = function (key) {\n        var version = this.readVersions.get(key);\n        if (version && version.equals(SnapshotVersion.forDeletedDoc())) {\n            // The document doesn't exist, so fail the transaction.\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n        }\n        else if (version) {\n            // Document exists, base precondition on document update time.\n            return Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return Precondition.exists(true);\n        }\n    };\n    Transaction.prototype.set = function (key, data) {\n        this.write(data.toMutations(key, this.precondition(key)));\n    };\n    Transaction.prototype.update = function (key, data) {\n        this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n    };\n    Transaction.prototype.delete = function (key) {\n        this.write([new DeleteMutation(key, this.precondition(key))]);\n        // Since the delete will be applied before all following writes, we need to\n        // ensure that the precondition for the next write will be exists: false.\n        this.readVersions = this.readVersions.insert(key, SnapshotVersion.forDeletedDoc());\n    };\n    Transaction.prototype.commit = function () {\n        var _this = this;\n        var unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(function (mutation) {\n            unwritten = unwritten.remove(mutation.key);\n        });\n        if (!unwritten.isEmpty()) {\n            return Promise.reject(Error('Every document read in a transaction must also be written.'));\n        }\n        return this.datastore.commit(this.mutations).then(function () {\n            _this.committed = true;\n        });\n    };\n    return Transaction;\n}());\nexport { Transaction };\n\n//# sourceMappingURL=transaction.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/transaction.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { OnlineState } from '../core/types';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { BATCHID_UNKNOWN, MutationBatchResult } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { Code } from '../util/error';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\nimport { ResetMapping, UpdateMapping } from './remote_event';\nimport { isPermanentError } from './rpc_error';\nimport { WatchChangeAggregator, WatchTargetChange, WatchTargetChangeState } from './watch_change';\nvar LOG_TAG = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nvar MAX_PENDING_WRITES = 10;\n// The RemoteStore notifies an onlineStateHandler with OnlineState.Failed if we\n// fail to connect to the backend. This subsequently triggers get() requests to\n// fail or use cached data, etc. Unfortunately, our connections have\n// historically been subject to various transient failures. So we wait for\n// multiple failures before notifying the onlineStateHandler.\nvar ONLINE_ATTEMPTS_BEFORE_FAILURE = 2;\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nvar RemoteStore = /** @class */ (function () {\n    function RemoteStore(databaseInfo, asyncQueue, \n        /**\n         * The local store, used to fill the write pipeline with outbound\n         * mutations and resolve existence filter mismatches.\n         */\n        localStore, \n        /** The client-side proxy for interacting with the backend. */\n        datastore, onlineStateHandler) {\n        this.databaseInfo = databaseInfo;\n        this.asyncQueue = asyncQueue;\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.onlineStateHandler = onlineStateHandler;\n        this.pendingWrites = [];\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = {};\n        /**\n         * A mapping of targetId to pending acks needed.\n         *\n         * If a targetId is present in this map, then we're waiting for watch to\n         * acknowledge a removal or addition of the target. If a target is not in this\n         * mapping, and it's in the listenTargets map, then we consider the target to\n         * be active.\n         *\n         * We increment the count here every time we issue a request over the stream\n         * to watch or unwatch. We then decrement the count every time we get a target\n         * added or target removed message from the server. Once the count is equal to\n         * 0 we know that the client and server are in the same state (once this state\n         * is reached the targetId is removed from the map to free the memory).\n         */\n        this.pendingTargetResponses = {};\n        this.accumulatedWatchChanges = [];\n        this.watchStream = null;\n        this.writeStream = null;\n        /**\n         * The online state of the watch stream. The state is set to healthy if and\n         * only if there are messages received by the backend.\n         */\n        this.watchStreamOnlineState = OnlineState.Unknown;\n        /** A count of consecutive failures to open the stream. */\n        this.watchStreamFailures = 0;\n    }\n    /**\n     * Starts up the remote store, creating streams, restoring state from\n     * LocalStore, etc.\n     */\n    RemoteStore.prototype.start = function () {\n        return this.enableNetwork();\n    };\n    RemoteStore.prototype.setOnlineStateToHealthy = function () {\n        this.updateAndBroadcastOnlineState(OnlineState.Healthy);\n    };\n    RemoteStore.prototype.setOnlineStateToUnknown = function () {\n        // The state is set to unknown when a healthy stream is closed (e.g. due to\n        // a token timeout) or when we have no active listens and therefore there's\n        // no need to start the stream. Assuming there is (possibly in the future)\n        // an active listen, then we will eventually move to state Online or Failed,\n        // but we always want to make at least ONLINE_ATTEMPTS_BEFORE_FAILURE\n        // attempts before failing, so we reset the count here.\n        this.watchStreamFailures = 0;\n        this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n    };\n    RemoteStore.prototype.updateOnlineStateAfterFailure = function () {\n        // The first failure after we are successfully connected moves us to the\n        // 'Unknown' state. We then may make multiple attempts (based on\n        // ONLINE_ATTEMPTS_BEFORE_FAILURE) before we actually report failure.\n        if (this.watchStreamOnlineState === OnlineState.Healthy) {\n            this.setOnlineStateToUnknown();\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= ONLINE_ATTEMPTS_BEFORE_FAILURE) {\n                this.updateAndBroadcastOnlineState(OnlineState.Failed);\n            }\n        }\n    };\n    RemoteStore.prototype.updateAndBroadcastOnlineState = function (onlineState) {\n        var didChange = this.watchStreamOnlineState !== onlineState;\n        this.watchStreamOnlineState = onlineState;\n        if (didChange) {\n            this.onlineStateHandler(onlineState);\n        }\n    };\n    RemoteStore.prototype.isNetworkEnabled = function () {\n        assert((this.watchStream == null) == (this.writeStream == null), 'WatchStream and WriteStream should both be null or non-null');\n        return this.watchStream != null;\n    };\n    /** Re-enables the network. Only to be called as the counterpart to disableNetwork(). */\n    RemoteStore.prototype.enableNetwork = function () {\n        var _this = this;\n        assert(this.watchStream == null, 'enableNetwork() called with non-null watchStream.');\n        assert(this.writeStream == null, 'enableNetwork() called with non-null writeStream.');\n        // Create new streams (but note they're not started yet).\n        this.watchStream = this.datastore.newPersistentWatchStream({\n            onOpen: this.onWatchStreamOpen.bind(this),\n            onClose: this.onWatchStreamClose.bind(this),\n            onWatchChange: this.onWatchStreamChange.bind(this)\n        });\n        this.writeStream = this.datastore.newPersistentWriteStream({\n            onOpen: this.onWriteStreamOpen.bind(this),\n            onClose: this.onWriteStreamClose.bind(this),\n            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n            onMutationResult: this.onMutationResult.bind(this)\n        });\n        // Load any saved stream token from persistent storage\n        return this.localStore.getLastStreamToken().then(function (token) {\n            _this.writeStream.lastStreamToken = token;\n            if (_this.shouldStartWatchStream()) {\n                _this.startWatchStream();\n            }\n            _this.updateAndBroadcastOnlineState(OnlineState.Unknown);\n            return _this.fillWritePipeline(); // This may start the writeStream.\n        });\n    };\n    /** Temporarily disables the network. The network can be re-enabled using enableNetwork(). */\n    RemoteStore.prototype.disableNetwork = function () {\n        this.updateAndBroadcastOnlineState(OnlineState.Failed);\n        // NOTE: We're guaranteed not to get any further events from these streams (not even a close\n        // event).\n        this.watchStream.stop();\n        this.writeStream.stop();\n        this.cleanUpWatchStreamState();\n        this.cleanUpWriteStreamState();\n        this.writeStream = null;\n        this.watchStream = null;\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.shutdown = function () {\n        log.debug(LOG_TAG, 'RemoteStore shutting down.');\n        this.disableNetwork();\n        return Promise.resolve(undefined);\n    };\n    /** Starts new listen for the given query. Uses resume token if provided */\n    RemoteStore.prototype.listen = function (queryData) {\n        assert(!objUtils.contains(this.listenTargets, queryData.targetId), 'listen called with duplicate targetId!');\n        // Mark this as something the client is currently listening for.\n        this.listenTargets[queryData.targetId] = queryData;\n        if (this.shouldStartWatchStream()) {\n            // The listen will be sent in onWatchStreamOpen\n            this.startWatchStream();\n        }\n        else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n            this.sendWatchRequest(queryData);\n        }\n    };\n    /** Removes the listen from server */\n    RemoteStore.prototype.unlisten = function (targetId) {\n        assert(objUtils.contains(this.listenTargets, targetId), 'unlisten called without assigned target ID!');\n        var queryData = this.listenTargets[targetId];\n        delete this.listenTargets[targetId];\n        if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n            this.sendUnwatchRequest(targetId);\n        }\n    };\n    /**\n     * We need to increment the the expected number of pending responses we're due\n     * from watch so we wait for the ack to process any messages from this target.\n     */\n    RemoteStore.prototype.sendWatchRequest = function (queryData) {\n        this.recordPendingTargetRequest(queryData.targetId);\n        this.watchStream.watch(queryData);\n    };\n    /**\n     * We need to increment the expected number of pending responses we're due\n     * from watch so we wait for the removal on the server before we process any\n     * messages from this target.\n     */\n    RemoteStore.prototype.sendUnwatchRequest = function (targetId) {\n        this.recordPendingTargetRequest(targetId);\n        this.watchStream.unwatch(targetId);\n    };\n    /**\n     * Increment the mapping of how many acks are needed from watch before we can\n     * consider the server to be 'in-sync' with the client's active targets.\n     */\n    RemoteStore.prototype.recordPendingTargetRequest = function (targetId) {\n        // For each request we get we need to record we need a response for it.\n        this.pendingTargetResponses[targetId] =\n            (this.pendingTargetResponses[targetId] || 0) + 1;\n    };\n    RemoteStore.prototype.startWatchStream = function () {\n        assert(this.shouldStartWatchStream(), 'startWriteStream() called when shouldStartWatchStream() is false.');\n        this.watchStream.start();\n    };\n    /**\n     * Returns whether the watch stream should be started because there are\n     * active targets trying to be listened too\n     */\n    RemoteStore.prototype.shouldStartWatchStream = function () {\n        return (this.isNetworkEnabled() &&\n            !this.watchStream.isStarted() &&\n            !objUtils.isEmpty(this.listenTargets));\n    };\n    RemoteStore.prototype.cleanUpWatchStreamState = function () {\n        // If the connection is closed then we'll never get a snapshot version for\n        // the accumulated changes and so we'll never be able to complete the batch.\n        // When we start up again the server is going to resend these changes\n        // anyway, so just toss the accumulated state.\n        this.accumulatedWatchChanges = [];\n        this.pendingTargetResponses = {};\n    };\n    RemoteStore.prototype.onWatchStreamOpen = function () {\n        var _this = this;\n        // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n        // targets are active\n        objUtils.forEachNumber(this.listenTargets, function (targetId, queryData) {\n            _this.sendWatchRequest(queryData);\n        });\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWatchStreamClose = function (error) {\n        assert(this.isNetworkEnabled(), 'onWatchStreamClose() should only be called when the network is enabled');\n        this.cleanUpWatchStreamState();\n        // If there was an error, retry the connection.\n        if (this.shouldStartWatchStream()) {\n            this.updateOnlineStateAfterFailure();\n            this.startWatchStream();\n        }\n        else {\n            // No need to restart watch stream because there are no active targets.\n            // The online state is set to unknown because there is no active attempt\n            // at establishing a connection\n            this.setOnlineStateToUnknown();\n        }\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWatchStreamChange = function (watchChange, snapshotVersion) {\n        // Mark the connection as healthy because we got a message from the server\n        this.setOnlineStateToHealthy();\n        if (watchChange instanceof WatchTargetChange &&\n            watchChange.state === WatchTargetChangeState.Removed &&\n            watchChange.cause) {\n            // There was an error on a target, don't wait for a consistent snapshot\n            // to raise events\n            return this.handleTargetError(watchChange);\n        }\n        // Accumulate watch changes but don't process them if there's no\n        // snapshotVersion or it's older than a previous snapshot we've processed\n        // (can happen after we resume a target using a resume token).\n        this.accumulatedWatchChanges.push(watchChange);\n        if (!snapshotVersion.equals(SnapshotVersion.MIN) &&\n            snapshotVersion.compareTo(this.localStore.getLastRemoteSnapshotVersion()) >= 0) {\n            var changes = this.accumulatedWatchChanges;\n            this.accumulatedWatchChanges = [];\n            return this.handleWatchChangeBatch(snapshotVersion, changes);\n        }\n        else {\n            return Promise.resolve();\n        }\n    };\n    /**\n     * Takes a batch of changes from the Datastore, repackages them as a\n     * RemoteEvent, and passes that on to the listener, which is typically the\n     * SyncEngine.\n     */\n    RemoteStore.prototype.handleWatchChangeBatch = function (snapshotVersion, changes) {\n        var _this = this;\n        var aggregator = new WatchChangeAggregator(snapshotVersion, this.listenTargets, this.pendingTargetResponses);\n        aggregator.addChanges(changes);\n        var remoteEvent = aggregator.createRemoteEvent();\n        // Get the new response counts from the aggregator\n        this.pendingTargetResponses = aggregator.pendingTargetResponses;\n        var promises = [];\n        // Handle existence filters and existence filter mismatches.\n        objUtils.forEachNumber(aggregator.existenceFilters, function (targetId, filter) {\n            var queryData = _this.listenTargets[targetId];\n            if (!queryData) {\n                // A watched target might have been removed already.\n                return;\n            }\n            var query = queryData.query;\n            if (query.isDocumentQuery()) {\n                if (filter.count === 0) {\n                    // The existence filter told us the document does not exist.\n                    // We need to deduce that this document does not exist and apply\n                    // a deleted document to our updates. Without applying a deleted\n                    // document there might be another query that will raise this\n                    // document as part of a snapshot until it is resolved,\n                    // essentially exposing inconsistency between queries.\n                    var key = new DocumentKey(query.path);\n                    var deletedDoc = new NoDocument(key, snapshotVersion);\n                    remoteEvent.addDocumentUpdate(deletedDoc);\n                }\n                else {\n                    assert(filter.count === 1, 'Single document existence filter with count: ' + filter.count);\n                }\n            }\n            else {\n                // Not a document query.\n                var promise = _this.localStore\n                    .remoteDocumentKeys(targetId)\n                    .then(function (trackedRemote) {\n                    if (remoteEvent.targetChanges[targetId]) {\n                        var mapping = remoteEvent.targetChanges[targetId].mapping;\n                        if (mapping !== null) {\n                            if (mapping instanceof UpdateMapping) {\n                                trackedRemote = mapping.applyToKeySet(trackedRemote);\n                            }\n                            else {\n                                assert(mapping instanceof ResetMapping, 'Expected either reset or update mapping but got something else: ' +\n                                    mapping);\n                                trackedRemote = mapping.documents;\n                            }\n                        }\n                    }\n                    if (trackedRemote.size !== filter.count) {\n                        // Existence filter mismatch, resetting mapping.\n                        // Make sure the mismatch is exposed in the remote event.\n                        remoteEvent.handleExistenceFilterMismatch(targetId);\n                        // Clear the resume token for the query, since we're in a\n                        // known mismatch state.\n                        var newQueryData = new QueryData(query, targetId, queryData.purpose);\n                        _this.listenTargets[targetId] = newQueryData;\n                        // Cause a hard reset by unwatching and rewatching\n                        // immediately, but deliberately don't send a resume token\n                        // so that we get a full update.\n                        // Make sure we expect that this acks are going to happen.\n                        _this.sendUnwatchRequest(targetId);\n                        // Mark the query we send as being on behalf of an existence\n                        // filter mismatch, but don't actually retain that in\n                        // listenTargets. This ensures that we flag the first\n                        // re-listen this way without impacting future listens of\n                        // this target (that might happen e.g. on reconnect).\n                        var requestQueryData = new QueryData(query, targetId, QueryPurpose.ExistenceFilterMismatch);\n                        _this.sendWatchRequest(requestQueryData);\n                    }\n                });\n                promises.push(promise);\n            }\n        });\n        return Promise.all(promises).then(function () {\n            // Update in-memory resume tokens. LocalStore will update the\n            // persistent view of these when applying the completed RemoteEvent.\n            objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                if (change.resumeToken.length > 0) {\n                    var queryData = _this.listenTargets[targetId];\n                    // A watched target might have been removed already.\n                    if (queryData) {\n                        _this.listenTargets[targetId] = queryData.update({\n                            resumeToken: change.resumeToken,\n                            snapshotVersion: change.snapshotVersion\n                        });\n                    }\n                }\n            });\n            // Finally handle remote event\n            return _this.syncEngine.applyRemoteEvent(remoteEvent);\n        });\n    };\n    /** Handles an error on a target */\n    RemoteStore.prototype.handleTargetError = function (watchChange) {\n        var _this = this;\n        assert(!!watchChange.cause, 'Handling target error without a cause');\n        var error = watchChange.cause;\n        var promiseChain = Promise.resolve();\n        watchChange.targetIds.forEach(function (targetId) {\n            promiseChain = promiseChain.then(function () {\n                if (objUtils.contains(_this.listenTargets, targetId)) {\n                    delete _this.listenTargets[targetId];\n                    return _this.syncEngine.rejectListen(targetId, error);\n                }\n                else {\n                    // A watched target might have been removed already.\n                    return Promise.resolve();\n                }\n            });\n        });\n        return promiseChain;\n    };\n    RemoteStore.prototype.cleanUpWriteStreamState = function () {\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        this.pendingWrites = [];\n    };\n    /**\n     * Notifies that there are new mutations to process in the queue. This is\n     * typically called by SyncEngine after it has sent mutations to LocalStore.\n     *\n     */\n    RemoteStore.prototype.fillWritePipeline = function () {\n        var _this = this;\n        if (!this.canWriteMutations()) {\n            return Promise.resolve();\n        }\n        else {\n            return this.localStore\n                .nextMutationBatch(this.lastBatchSeen)\n                .then(function (batch) {\n                if (batch === null) {\n                    return Promise.resolve();\n                }\n                else {\n                    _this.commit(batch);\n                    return _this.fillWritePipeline();\n                }\n            });\n        }\n    };\n    /**\n     * Returns true if the backend can accept additional write requests.\n     *\n     * When sending mutations to the write stream (e.g. in fillWritePipeline),\n     * call this method first to check if more mutations can be sent.\n     *\n     * Currently the only thing that can prevent the backend from accepting\n     * write requests is if there are too many requests already outstanding. As\n     * writes complete the backend will be able to accept more.\n     */\n    RemoteStore.prototype.canWriteMutations = function () {\n        return (this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES);\n    };\n    // For testing\n    RemoteStore.prototype.outstandingWrites = function () {\n        return this.pendingWrites.length;\n    };\n    /**\n     * Given mutations to commit, actually commits them to the Datastore. Note\n     * that this does *not* return a Promise specifically because the AsyncQueue\n     * should not block operations for this.\n     */\n    RemoteStore.prototype.commit = function (batch) {\n        assert(this.canWriteMutations(), \"commit called when batches can't be written\");\n        this.lastBatchSeen = batch.batchId;\n        this.pendingWrites.push(batch);\n        if (this.shouldStartWriteStream()) {\n            this.startWriteStream();\n        }\n        else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {\n            this.writeStream.writeMutations(batch.mutations);\n        }\n    };\n    RemoteStore.prototype.shouldStartWriteStream = function () {\n        return (this.isNetworkEnabled() &&\n            !this.writeStream.isStarted() &&\n            this.pendingWrites.length > 0);\n    };\n    RemoteStore.prototype.startWriteStream = function () {\n        assert(this.shouldStartWriteStream(), 'startWriteStream() called when shouldStartWriteStream() is false.');\n        this.writeStream.start();\n    };\n    RemoteStore.prototype.onWriteStreamOpen = function () {\n        this.writeStream.writeHandshake();\n        return Promise.resolve();\n    };\n    RemoteStore.prototype.onWriteHandshakeComplete = function () {\n        var _this = this;\n        // Record the stream token.\n        return this.localStore\n            .setLastStreamToken(this.writeStream.lastStreamToken)\n            .then(function () {\n            // Drain any pending writes.\n            //\n            // Note that at this point pendingWrites contains mutations that\n            // have already been accepted by fillWritePipeline/commitBatch. If\n            // the pipeline is full, canWriteMutations will be false, despite\n            // the fact that we actually need to send mutations over.\n            //\n            // This also means that this method indirectly respects the limits\n            // imposed by canWriteMutations since writes can't be added to the\n            // pendingWrites array when canWriteMutations is false. If the\n            // limits imposed by canWriteMutations actually protect us from\n            // DOSing ourselves then those limits won't be exceeded here and\n            // we'll continue to make progress.\n            for (var _i = 0, _a = _this.pendingWrites; _i < _a.length; _i++) {\n                var batch = _a[_i];\n                _this.writeStream.writeMutations(batch.mutations);\n            }\n        });\n    };\n    RemoteStore.prototype.onMutationResult = function (commitVersion, results) {\n        var _this = this;\n        // This is a response to a write containing mutations and should be\n        // correlated to the first pending write.\n        assert(this.pendingWrites.length > 0, 'Got result for empty pending writes');\n        var batch = this.pendingWrites.shift();\n        var success = MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);\n        return this.syncEngine.applySuccessfulWrite(success).then(function () {\n            // It's possible that with the completion of this mutation another\n            // slot has freed up.\n            return _this.fillWritePipeline();\n        });\n    };\n    RemoteStore.prototype.onWriteStreamClose = function (error) {\n        var _this = this;\n        assert(this.isNetworkEnabled(), 'onWriteStreamClose() should only be called when the network is enabled');\n        // Ignore close if there are no pending writes.\n        if (this.pendingWrites.length > 0) {\n            assert(!!error, 'We have pending writes, but the write stream closed without an error');\n            // A promise that is resolved after we processed the error\n            var errorHandling = void 0;\n            if (this.writeStream.handshakeComplete) {\n                // This error affects the actual write.\n                errorHandling = this.handleWriteError(error);\n            }\n            else {\n                // If there was an error before the handshake has finished, it's\n                // possible that the server is unable to process the stream token\n                // we're sending. (Perhaps it's too old?)\n                errorHandling = this.handleHandshakeError(error);\n            }\n            return errorHandling.then(function () {\n                // The write stream might have been started by refilling the write\n                // pipeline for failed writes\n                if (_this.shouldStartWriteStream()) {\n                    _this.startWriteStream();\n                }\n            });\n        }\n        else {\n            // No pending writes, nothing to do\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.handleHandshakeError = function (error) {\n        // Reset the token if it's a permanent error or the error code is\n        // ABORTED, signaling the write stream is no longer valid.\n        if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n            log.debug(LOG_TAG, 'RemoteStore error before completed handshake; resetting stream token: ', this.writeStream.lastStreamToken);\n            this.writeStream.lastStreamToken = emptyByteString();\n            return this.localStore.setLastStreamToken(emptyByteString());\n        }\n        else {\n            // Some other error, don't reset stream token. Our stream logic will\n            // just retry with exponential backoff.\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.handleWriteError = function (error) {\n        var _this = this;\n        if (isPermanentError(error.code)) {\n            // This was a permanent error, the request itself was the problem\n            // so it's not going to succeed if we resend it.\n            var batch = this.pendingWrites.shift();\n            // In this case it's also unlikely that the server itself is melting\n            // down -- this was just a bad request so inhibit backoff on the next\n            // restart.\n            this.writeStream.inhibitBackoff();\n            return this.syncEngine\n                .rejectFailedWrite(batch.batchId, error)\n                .then(function () {\n                // It's possible that with the completion of this mutation\n                // another slot has freed up.\n                return _this.fillWritePipeline();\n            });\n        }\n        else {\n            // Transient error, just let the retry logic kick in.\n            return Promise.resolve();\n        }\n    };\n    RemoteStore.prototype.createTransaction = function () {\n        return new Transaction(this.datastore);\n    };\n    RemoteStore.prototype.handleUserChange = function (user) {\n        log.debug(LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n        // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n        // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n        // (since mutations are per-user).\n        this.disableNetwork();\n        return this.enableNetwork();\n    };\n    return RemoteStore;\n}());\nexport { RemoteStore };\n\n//# sourceMappingURL=remote_store.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/remote_store.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventManager, QueryListener } from './event_manager';\nimport { SyncEngine } from './sync_engine';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { IndexedDbPersistence } from '../local/indexeddb_persistence';\nimport { LocalStore } from '../local/local_store';\nimport { MemoryPersistence } from '../local/memory_persistence';\nimport { NoOpGarbageCollector } from '../local/no_op_garbage_collector';\nimport { Datastore } from '../remote/datastore';\nimport { RemoteStore } from '../remote/remote_store';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { Code } from '../util/error';\nimport { debug } from '../util/log';\nimport { Deferred } from '../util/promise';\nvar LOG_TAG = 'FirestoreClient';\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\nvar FirestoreClient = /** @class */ (function () {\n    function FirestoreClient(platform, databaseInfo, credentials, \n        /**\n           * Asynchronous queue responsible for all of our internal processing. When\n           * we get incoming work from the user (via public API) or the network\n           * (incoming GRPC messages), we should always schedule onto this queue.\n           * This ensures all of our work is properly serialized (e.g. we don't\n           * start processing a new operation while the previous one is waiting for\n           * an async I/O to complete).\n           */\n        asyncQueue) {\n        this.platform = platform;\n        this.databaseInfo = databaseInfo;\n        this.credentials = credentials;\n        this.asyncQueue = asyncQueue;\n    }\n    /**\n     * Starts up the FirestoreClient, returning only whether or not enabling\n     * persistence succeeded.\n     *\n     * The intent here is to \"do the right thing\" as far as users are concerned.\n     * Namely, in cases where offline persistence is requested and possible,\n     * enable it, but otherwise fall back to persistence disabled. For the most\n     * part we expect this to succeed one way or the other so we don't expect our\n     * users to actually wait on the firestore.enablePersistence Promise since\n     * they generally won't care.\n     *\n     * Of course some users actually do care about whether or not persistence\n     * was successfully enabled, so the Promise returned from this method\n     * indicates this outcome.\n     *\n     * This presents a problem though: even before enablePersistence resolves or\n     * rejects, users may have made calls to e.g. firestore.collection() which\n     * means that the FirestoreClient in there will be available and will be\n     * enqueuing actions on the async queue.\n     *\n     * Meanwhile any failure of an operation on the async queue causes it to\n     * panic and reject any further work, on the premise that unhandled errors\n     * are fatal.\n     *\n     * Consequently the fallback is handled internally here in start, and if the\n     * fallback succeeds we signal success to the async queue even though the\n     * start() itself signals failure.\n     *\n     * @param usePersistence Whether or not to attempt to enable persistence.\n     * @returns A deferred result indicating the user-visible result of enabling\n     *     offline persistence. This method will reject this if IndexedDB fails to\n     *     start for any reason. If usePersistence is false this is\n     *     unconditionally resolved.\n     */\n    FirestoreClient.prototype.start = function (usePersistence) {\n        var _this = this;\n        // We defer our initialization until we get the current user from\n        // setUserChangeListener(). We block the async queue until we got the\n        // initial user and the initialization is completed. This will prevent\n        // any scheduled work from happening before initialization is completed.\n        //\n        // If initializationDone resolved then the FirestoreClient is in a usable\n        // state.\n        var initializationDone = new Deferred();\n        // If usePersistence is true, certain classes of errors while starting are\n        // recoverable but only by falling back to persistence disabled.\n        //\n        // If there's an error in the first case but not in recovery we cannot\n        // reject the promise blocking the async queue because this will cause the\n        // async queue to panic.\n        var persistenceResult = new Deferred();\n        var initialized = false;\n        this.credentials.setUserChangeListener(function (user) {\n            if (!initialized) {\n                initialized = true;\n                _this.initializePersistence(usePersistence, persistenceResult)\n                    .then(function () { return _this.initializeRest(user); })\n                    .then(initializationDone.resolve, initializationDone.reject);\n            }\n            else {\n                _this.asyncQueue.schedule(function () {\n                    return _this.handleUserChange(user);\n                });\n            }\n        });\n        // Block the async queue until initialization is done\n        this.asyncQueue.schedule(function () {\n            return initializationDone.promise;\n        });\n        // Return only the result of enabling persistence. Note that this does not\n        // need to await the completion of initializationDone because the result of\n        // this method should not reflect any other kind of failure to start.\n        return persistenceResult.promise;\n    };\n    /** Enables the network connection and requeues all pending operations. */\n    FirestoreClient.prototype.enableNetwork = function () {\n        var _this = this;\n        return this.asyncQueue.schedule(function () {\n            return _this.remoteStore.enableNetwork();\n        });\n    };\n    /**\n     * Initializes persistent storage, attempting to use IndexedDB if\n     * usePersistence is true or memory-only if false.\n     *\n     * If IndexedDB fails because it's already open in another tab or because the\n     * platform can't possibly support our implementation then this method rejects\n     * the persistenceResult and falls back on memory-only persistence.\n     *\n     * @param usePersistence indicates whether or not to use offline persistence\n     * @param persistenceResult A deferred result indicating the user-visible\n     *     result of enabling offline persistence. This method will reject this if\n     *     IndexedDB fails to start for any reason. If usePersistence is false\n     *     this is unconditionally resolved.\n     * @returns a Promise indicating whether or not initialization should\n     *     continue, i.e. that one of the persistence implementations actually\n     *     succeeded.\n     */\n    FirestoreClient.prototype.initializePersistence = function (usePersistence, persistenceResult) {\n        var _this = this;\n        if (usePersistence) {\n            return this.startIndexedDbPersistence()\n                .then(persistenceResult.resolve)\n                .catch(function (error) {\n                // Regardless of whether or not the retry succeeds, from an user\n                // perspective, offline persistence has failed.\n                persistenceResult.reject(error);\n                // An unknown failure on the first stage shuts everything down.\n                if (!_this.canFallback(error)) {\n                    return Promise.reject(error);\n                }\n                console.warn('Error enabling offline storage. Falling back to' +\n                    ' storage disabled: ' +\n                    error);\n                return _this.startMemoryPersistence();\n            });\n        }\n        else {\n            // When usePersistence == false, enabling offline persistence is defined\n            // to unconditionally succeed. This allows start() to have the same\n            // signature for both cases, despite the fact that the returned promise\n            // is only used in the enablePersistence call.\n            persistenceResult.resolve();\n            return this.startMemoryPersistence();\n        }\n    };\n    FirestoreClient.prototype.canFallback = function (error) {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    };\n    /**\n     * Starts IndexedDB-based persistence.\n     *\n     * @returns A promise indicating success or failure.\n     */\n    FirestoreClient.prototype.startIndexedDbPersistence = function () {\n        // TODO(http://b/33384523): For now we just disable garbage collection\n        // when persistence is enabled.\n        this.garbageCollector = new NoOpGarbageCollector();\n        var storagePrefix = IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);\n        // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.\n        var serializer = new JsonProtoSerializer(this.databaseInfo.databaseId, {\n            useProto3Json: true\n        });\n        this.persistence = new IndexedDbPersistence(storagePrefix, serializer);\n        return this.persistence.start();\n    };\n    /**\n     * Starts Memory-backed persistence. In practice this cannot fail.\n     *\n     * @returns A promise that will successfully resolve.\n     */\n    FirestoreClient.prototype.startMemoryPersistence = function () {\n        this.garbageCollector = new EagerGarbageCollector();\n        this.persistence = new MemoryPersistence();\n        return this.persistence.start();\n    };\n    /**\n     * Initializes the rest of the FirestoreClient, assuming the initial user\n     * has been obtained from the credential provider and some persistence\n     * implementation is available in this.persistence.\n     */\n    FirestoreClient.prototype.initializeRest = function (user) {\n        var _this = this;\n        return this.platform\n            .loadConnection(this.databaseInfo)\n            .then(function (connection) {\n            _this.localStore = new LocalStore(_this.persistence, user, _this.garbageCollector);\n            var serializer = _this.platform.newSerializer(_this.databaseInfo.databaseId);\n            var datastore = new Datastore(_this.databaseInfo, _this.asyncQueue, connection, _this.credentials, serializer);\n            var onlineStateChangedHandler = function (onlineState) {\n                _this.eventMgr.onOnlineStateChanged(onlineState);\n            };\n            _this.remoteStore = new RemoteStore(_this.databaseInfo, _this.asyncQueue, _this.localStore, datastore, onlineStateChangedHandler);\n            _this.syncEngine = new SyncEngine(_this.localStore, _this.remoteStore, user);\n            // Setup wiring between sync engine and remote store\n            _this.remoteStore.syncEngine = _this.syncEngine;\n            _this.eventMgr = new EventManager(_this.syncEngine);\n            // NOTE: RemoteStore depends on LocalStore (for persisting stream\n            // tokens, refilling mutation queue, etc.) so must be started after\n            // LocalStore.\n            return _this.localStore.start();\n        })\n            .then(function () {\n            return _this.remoteStore.start();\n        });\n    };\n    FirestoreClient.prototype.handleUserChange = function (user) {\n        this.asyncQueue.verifyOperationInProgress();\n        debug(LOG_TAG, 'User Changed: ' + user.uid);\n        return this.syncEngine.handleUserChange(user);\n    };\n    /** Disables the network connection. Pending operations will not complete. */\n    FirestoreClient.prototype.disableNetwork = function () {\n        var _this = this;\n        return this.asyncQueue.schedule(function () {\n            return _this.remoteStore.disableNetwork();\n        });\n    };\n    FirestoreClient.prototype.shutdown = function () {\n        var _this = this;\n        return this.asyncQueue\n            .schedule(function () {\n            _this.credentials.removeUserChangeListener();\n            return _this.remoteStore.shutdown();\n        })\n            .then(function () {\n            // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n            return _this.persistence.shutdown();\n        });\n    };\n    FirestoreClient.prototype.listen = function (query, observer, options) {\n        var _this = this;\n        var listener = new QueryListener(query, observer, options);\n        this.asyncQueue.schedule(function () {\n            return _this.eventMgr.listen(listener);\n        });\n        return listener;\n    };\n    FirestoreClient.prototype.unlisten = function (listener) {\n        var _this = this;\n        this.asyncQueue.schedule(function () {\n            return _this.eventMgr.unlisten(listener);\n        });\n    };\n    FirestoreClient.prototype.write = function (mutations) {\n        var _this = this;\n        var deferred = new Deferred();\n        this.asyncQueue.schedule(function () { return _this.syncEngine.write(mutations, deferred); });\n        return deferred.promise;\n    };\n    FirestoreClient.prototype.databaseId = function () {\n        return this.databaseInfo.databaseId;\n    };\n    FirestoreClient.prototype.transaction = function (updateFunction) {\n        var _this = this;\n        // We have to wait for the async queue to be sure syncEngine is initialized.\n        return this.asyncQueue\n            .schedule(function () {\n            return Promise.resolve();\n        })\n            .then(function () {\n            return _this.syncEngine.runTransaction(updateFunction);\n        });\n    };\n    return FirestoreClient;\n}());\nexport { FirestoreClient };\n\n//# sourceMappingURL=firestore_client.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/firestore_client.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nvar AsyncObserver = /** @class */ (function () {\n    function AsyncObserver(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    AsyncObserver.prototype.next = function (value) {\n        this.scheduleEvent(this.observer.next, value);\n    };\n    AsyncObserver.prototype.error = function (error) {\n        this.scheduleEvent(this.observer.error, error);\n    };\n    AsyncObserver.prototype.mute = function () {\n        this.muted = true;\n    };\n    AsyncObserver.prototype.scheduleEvent = function (eventHandler, event) {\n        var _this = this;\n        if (!this.muted) {\n            setTimeout(function () {\n                if (!_this.muted) {\n                    eventHandler(event);\n                }\n            }, 0);\n        }\n    };\n    return AsyncObserver;\n}());\nexport { AsyncObserver };\n\n//# sourceMappingURL=async_observer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/async_observer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { Deferred } from './promise';\nvar AsyncQueue = /** @class */ (function () {\n    function AsyncQueue() {\n        // The last promise in the queue.\n        this.tail = Promise.resolve();\n        // The number of ops that are queued to be run in the future (i.e. they had a\n        // delay that has not yet elapsed).\n        this.delayedOpCount = 0;\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n    }\n    /**\n     * Adds a new operation to the queue. Returns a promise that will be resolved\n     * when the promise returned by the new operation is (with its value).\n     *\n     * Can optionally specify a delay to wait before queuing the operation.\n     */\n    AsyncQueue.prototype.schedule = function (op, delay) {\n        var _this = this;\n        if (this.failure) {\n            fail('AsyncQueue is already failed: ' + this.failure.message);\n        }\n        if ((delay || 0) > 0) {\n            this.delayedOpCount++;\n            var deferred_1 = new Deferred();\n            setTimeout(function () {\n                _this.scheduleInternal(function () {\n                    return op().then(function (result) {\n                        deferred_1.resolve(result);\n                    });\n                });\n                _this.delayedOpCount--; // decrement once it's actually queued.\n            }, delay);\n            return deferred_1.promise;\n        }\n        else {\n            return this.scheduleInternal(op);\n        }\n    };\n    AsyncQueue.prototype.scheduleInternal = function (op) {\n        var _this = this;\n        this.tail = this.tail.then(function () {\n            _this.operationInProgress = true;\n            return op()\n                .catch(function (error) {\n                _this.failure = error;\n                _this.operationInProgress = false;\n                log.error('INTERNAL UNHANDLED ERROR: ', error.stack || error.message);\n                throw error;\n            })\n                .then(function () {\n                _this.operationInProgress = false;\n            });\n        });\n        return this.tail;\n    };\n    /**\n     * Verifies there's an operation currently in-progress on the AsyncQueue.\n     * Unfortunately we can't verify that the running code is in the promise chain\n     * of that operation, so this isn't a foolproof check, but it should be enough\n     * to catch some bugs.\n     */\n    AsyncQueue.prototype.verifyOperationInProgress = function () {\n        assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');\n    };\n    AsyncQueue.prototype.drain = function () {\n        // TODO(mikelehen): This should perhaps also drain items that are queued to\n        // run in the future (perhaps by artificially running them early), but since\n        // no tests need that yet, I didn't bother for now.\n        assert(this.delayedOpCount === 0, \"draining doesn't handle delayed ops.\");\n        return this.schedule(function () { return Promise.resolve(undefined); });\n    };\n    return AsyncQueue;\n}());\nexport { AsyncQueue };\n\n//# sourceMappingURL=async_queue.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/async_queue.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nvar User = /** @class */ (function () {\n    function User(uid) {\n        this.uid = uid;\n    }\n    User.prototype.isUnauthenticated = function () {\n        return this.uid == null;\n    };\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n    User.prototype.toKey = function () {\n        if (this.isUnauthenticated()) {\n            return 'anonymous-user';\n        }\n        else {\n            return 'uid:' + this.uid;\n        }\n    };\n    User.prototype.equals = function (otherUser) {\n        return otherUser.uid === this.uid;\n    };\n    /** A user with a null UID. */\n    User.UNAUTHENTICATED = new User(null);\n    // TODO(mikelehen): Look into getting a proper uid-equivalent for\n    // non-FirebaseAuth providers.\n    User.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\n    User.FIRST_PARTY = new User('first-party-uid');\n    return User;\n}());\nexport { User };\n\n//# sourceMappingURL=user.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/auth/user.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { makeConstructorPrivate } from '../util/api';\n/**\n * An opaque base class for FieldValue sentinel objects in our public API,\n * with public static methods for creating said sentinel objects.\n */\n// tslint:disable-next-line:class-as-namespace  We use this as a base class.\nvar FieldValueImpl = /** @class */ (function () {\n    function FieldValueImpl() {\n    }\n    FieldValueImpl.delete = function () {\n        return DeleteFieldValueImpl.instance;\n    };\n    FieldValueImpl.serverTimestamp = function () {\n        return ServerTimestampFieldValueImpl.instance;\n    };\n    return FieldValueImpl;\n}());\nexport { FieldValueImpl };\nvar DeleteFieldValueImpl = /** @class */ (function (_super) {\n    __extends(DeleteFieldValueImpl, _super);\n    function DeleteFieldValueImpl() {\n        return _super.call(this) || this;\n    }\n    /** Singleton instance. */\n    DeleteFieldValueImpl.instance = new DeleteFieldValueImpl();\n    return DeleteFieldValueImpl;\n}(FieldValueImpl));\nexport { DeleteFieldValueImpl };\nvar ServerTimestampFieldValueImpl = /** @class */ (function (_super) {\n    __extends(ServerTimestampFieldValueImpl, _super);\n    function ServerTimestampFieldValueImpl() {\n        return _super.call(this) || this;\n    }\n    /** Singleton instance. */\n    ServerTimestampFieldValueImpl.instance = new ServerTimestampFieldValueImpl();\n    return ServerTimestampFieldValueImpl;\n}(FieldValueImpl));\nexport { ServerTimestampFieldValueImpl };\n// Public instance that disallows construction at runtime. This constructor is\n// used when exporting FieldValueImpl on firebase.firestore.FieldValue and will\n// be called FieldValue publicly. Internally we still use FieldValueImpl which\n// has a type-checked private constructor. Note that FieldValueImpl and\n// PublicFieldValue can be used interchangeably in instanceof checks.\n// For our internal TypeScript code PublicFieldValue doesn't exist as a type,\n// and so we need to use FieldValueImpl as type and export it too.\n// tslint:disable-next-line:variable-name  We treat this as a class name.\nexport var PublicFieldValue = makeConstructorPrivate(FieldValueImpl, 'Use FieldValue.<field>() instead.');\n\n//# sourceMappingURL=field_value.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/field_value.js\n// module id = null\n// module chunks = ","(function() {var g,goog=goog||{},k=this;function l(a){return\"string\"==typeof a}function aa(){}\nfunction ba(a){var b=typeof a;if(\"object\"==b)if(a){if(a instanceof Array)return\"array\";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if(\"[object Window]\"==c)return\"object\";if(\"[object Array]\"==c||\"number\"==typeof a.length&&\"undefined\"!=typeof a.splice&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"splice\"))return\"array\";if(\"[object Function]\"==c||\"undefined\"!=typeof a.call&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"call\"))return\"function\"}else return\"null\";\nelse if(\"function\"==b&&\"undefined\"==typeof a.call)return\"object\";return b}function n(a){return\"array\"==ba(a)}function ca(a){var b=ba(a);return\"array\"==b||\"object\"==b&&\"number\"==typeof a.length}function da(a){return\"function\"==ba(a)}function p(a){var b=typeof a;return\"object\"==b&&null!=a||\"function\"==b}var q=\"closure_uid_\"+(1E9*Math.random()>>>0),ea=0;function fa(a,b,c){return a.call.apply(a.bind,arguments)}\nfunction ha(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function r(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf(\"native code\")?r=fa:r=ha;return r.apply(null,arguments)}\nfunction ia(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}var t=Date.now||function(){return+new Date};function u(a,b){function c(){}c.prototype=b.prototype;a.L=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Bb=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};function ja(a){if(Error.captureStackTrace)Error.captureStackTrace(this,ja);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}u(ja,Error);ja.prototype.name=\"CustomError\";function ka(a,b){for(var c=a.split(\"%s\"),d=\"\",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join(\"%s\")}var la=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g,\"\")};function ma(a,b){return a<b?-1:a>b?1:0};function na(a,b){b.unshift(a);ja.call(this,ka.apply(null,b));b.shift()}u(na,ja);na.prototype.name=\"AssertionError\";function oa(a,b){throw new na(\"Failure\"+(a?\": \"+a:\"\"),Array.prototype.slice.call(arguments,1));};function w(){0!=qa&&(ra[this[q]||(this[q]=++ea)]=this);this.i=this.i;this.v=this.v}var qa=0,ra={};w.prototype.i=!1;w.prototype.Y=function(){if(!this.i&&(this.i=!0,this.w(),0!=qa)){var a=this[q]||(this[q]=++ea);delete ra[a]}};w.prototype.w=function(){if(this.v)for(;this.v.length;)this.v.shift()()};var sa=Array.prototype.indexOf?function(a,b,c){return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(l(a))return l(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},ta=Array.prototype.forEach?function(a,b,c){Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=l(a)?a.split(\"\"):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};\nfunction ua(a){a:{var b=va;for(var c=a.length,d=l(a)?a.split(\"\"):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:l(a)?a.charAt(b):a[b]}function wa(a){if(!n(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0}function xa(a){return Array.prototype.concat.apply([],arguments)}function ya(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};var x;a:{var za=k.navigator;if(za){var Aa=za.userAgent;if(Aa){x=Aa;break a}}x=\"\"}function y(a){return-1!=x.indexOf(a)};function Ba(a,b,c){for(var d in a)b.call(c,a[d],d,a)}function Ca(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Da(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function Ea(a){var b={},c;for(c in a)b[c]=a[c];return b}var Fa=\"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\nfunction Ga(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Fa.length;f++)c=Fa[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Ha(a){Ha[\" \"](a);return a}Ha[\" \"]=aa;function Ia(a,b){var c=Ja;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)};var Ka=y(\"Opera\"),z=y(\"Trident\")||y(\"MSIE\"),La=y(\"Edge\"),Ma=y(\"Gecko\")&&!(-1!=x.toLowerCase().indexOf(\"webkit\")&&!y(\"Edge\"))&&!(y(\"Trident\")||y(\"MSIE\"))&&!y(\"Edge\"),Na=-1!=x.toLowerCase().indexOf(\"webkit\")&&!y(\"Edge\");function Oa(){var a=k.document;return a?a.documentMode:void 0}var Pa;\na:{var Qa=\"\",Ra=function(){var a=x;if(Ma)return/rv:([^\\);]+)(\\)|;)/.exec(a);if(La)return/Edge\\/([\\d\\.]+)/.exec(a);if(z)return/\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(a);if(Na)return/WebKit\\/(\\S+)/.exec(a);if(Ka)return/(?:Version)[ \\/]?(\\S+)/.exec(a)}();Ra&&(Qa=Ra?Ra[1]:\"\");if(z){var Ta=Oa();if(null!=Ta&&Ta>parseFloat(Qa)){Pa=String(Ta);break a}}Pa=Qa}var Ja={};\nfunction Ua(a){return Ia(a,function(){for(var b=0,c=la(String(Pa)).split(\".\"),d=la(String(a)).split(\".\"),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var h=c[f]||\"\",m=d[f]||\"\";do{h=/(\\d*)(\\D*)(.*)/.exec(h)||[\"\",\"\",\"\",\"\"];m=/(\\d*)(\\D*)(.*)/.exec(m)||[\"\",\"\",\"\",\"\"];if(0==h[0].length&&0==m[0].length)break;b=ma(0==h[1].length?0:parseInt(h[1],10),0==m[1].length?0:parseInt(m[1],10))||ma(0==h[2].length,0==m[2].length)||ma(h[2],m[2]);h=h[3];m=m[3]}while(0==b)}return 0<=b})}var Va;var Wa=k.document;\nVa=Wa&&z?Oa()||(\"CSS1Compat\"==Wa.compatMode?parseInt(Pa,10):5):void 0;var Xa=Object.freeze||function(a){return a};var Ya=!z||9<=Number(Va),Za=z&&!Ua(\"9\"),$a=function(){if(!k.addEventListener||!Object.defineProperty)return!1;var a=!1,b=Object.defineProperty({},\"passive\",{get:function(){a=!0}});k.addEventListener(\"test\",aa,b);k.removeEventListener(\"test\",aa,b);return a}();function A(a,b){this.type=a;this.a=this.target=b;this.Qa=!0}A.prototype.b=function(){this.Qa=!1};function ab(a,b){A.call(this,a?a.type:\"\");this.relatedTarget=this.a=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key=\"\";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.pointerId=0;this.pointerType=\"\";this.c=null;if(a){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.a=b;if(b=a.relatedTarget){if(Ma){a:{try{Ha(b.nodeName);var e=!0;break a}catch(f){}e=!1}e||(b=null)}}else\"mouseover\"==c?b=\na.fromElement:\"mouseout\"==c&&(b=a.toElement);this.relatedTarget=b;null===d?(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.key=a.key||\"\";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=\na.metaKey;this.pointerId=a.pointerId||0;this.pointerType=l(a.pointerType)?a.pointerType:bb[a.pointerType]||\"\";this.c=a;a.defaultPrevented&&this.b()}}u(ab,A);var bb=Xa({2:\"touch\",3:\"pen\",4:\"mouse\"});ab.prototype.b=function(){ab.L.b.call(this);var a=this.c;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,Za)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var cb=\"closure_listenable_\"+(1E6*Math.random()|0);function db(a){return!(!a||!a[cb])}var eb=0;function fb(a,b,c,d,e){this.listener=a;this.a=null;this.src=b;this.type=c;this.capture=!!d;this.da=e;this.key=++eb;this.X=this.ba=!1}function gb(a){a.X=!0;a.listener=null;a.a=null;a.src=null;a.da=null};function hb(a){this.src=a;this.a={};this.b=0}hb.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.a[f];a||(a=this.a[f]=[],this.b++);var h=ib(a,b,d,e);-1<h?(b=a[h],c||(b.ba=!1)):(b=new fb(b,this.src,f,!!d,e),b.ba=c,a.push(b));return b};function jb(a,b){var c=b.type;if(c in a.a){var d=a.a[c],e=sa(d,b),f;(f=0<=e)&&Array.prototype.splice.call(d,e,1);f&&(gb(b),0==a.a[c].length&&(delete a.a[c],a.b--))}}function kb(a,b,c,d,e){a=a.a[b.toString()];b=-1;a&&(b=ib(a,c,d,e));return-1<b?a[b]:null}\nfunction ib(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.X&&f.listener==b&&f.capture==!!c&&f.da==d)return e}return-1};var lb=\"closure_lm_\"+(1E6*Math.random()|0),mb={},nb=0;function ob(a,b,c,d,e){if(d&&d.once)return pb(a,b,c,d,e);if(n(b)){for(var f=0;f<b.length;f++)ob(a,b[f],c,d,e);return null}c=qb(c);return db(a)?a.$(b,c,p(d)?!!d.capture:!!d,e):rb(a,b,c,!1,d,e)}\nfunction rb(a,b,c,d,e,f){if(!b)throw Error(\"Invalid event type\");var h=p(e)?!!e.capture:!!e,m=sb(a);m||(a[lb]=m=new hb(a));c=m.add(b,c,d,h,f);if(c.a)return c;d=tb();c.a=d;d.src=a;d.listener=c;if(a.addEventListener)$a||(e=h),void 0===e&&(e=!1),a.addEventListener(b.toString(),d,e);else if(a.attachEvent)a.attachEvent(ub(b.toString()),d);else throw Error(\"addEventListener and attachEvent are unavailable.\");nb++;return c}\nfunction tb(){var a=vb,b=Ya?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}function pb(a,b,c,d,e){if(n(b)){for(var f=0;f<b.length;f++)pb(a,b[f],c,d,e);return null}c=qb(c);return db(a)?a.Ia(b,c,p(d)?!!d.capture:!!d,e):rb(a,b,c,!0,d,e)}function wb(a,b,c,d,e){if(n(b))for(var f=0;f<b.length;f++)wb(a,b[f],c,d,e);else d=p(d)?!!d.capture:!!d,c=qb(c),db(a)?a.xa(b,c,d,e):a&&(a=sb(a))&&(b=kb(a,b,c,d,e))&&xb(b)}\nfunction xb(a){if(\"number\"!=typeof a&&a&&!a.X){var b=a.src;if(db(b))jb(b.c,a);else{var c=a.type,d=a.a;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent&&b.detachEvent(ub(c),d);nb--;(c=sb(b))?(jb(c,a),0==c.b&&(c.src=null,b[lb]=null)):gb(a)}}}function ub(a){return a in mb?mb[a]:mb[a]=\"on\"+a}function yb(a,b,c,d){var e=!0;if(a=sb(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.capture==c&&!f.X&&(f=zb(f,d),e=e&&!1!==f)}return e}\nfunction zb(a,b){var c=a.listener,d=a.da||a.src;a.ba&&xb(a);return c.call(d,b)}\nfunction vb(a,b){if(a.X)return!0;if(!Ya){if(!b)a:{b=[\"window\",\"event\"];for(var c=k,d=0;d<b.length;d++)if(c=c[b[d]],null==c){b=null;break a}b=c}d=b;b=new ab(d,this);c=!0;if(!(0>d.keyCode||void 0!=d.returnValue)){a:{var e=!1;if(0==d.keyCode)try{d.keyCode=-1;break a}catch(h){e=!0}if(e||void 0==d.returnValue)d.returnValue=!0}d=[];for(e=b.a;e;e=e.parentNode)d.push(e);a=a.type;for(e=d.length-1;0<=e;e--){b.a=d[e];var f=yb(d[e],a,!0,b);c=c&&f}for(e=0;e<d.length;e++)b.a=d[e],f=yb(d[e],a,!1,b),c=c&&f}return c}return zb(a,\nnew ab(b,this))}function sb(a){a=a[lb];return a instanceof hb?a:null}var Ab=\"__closure_events_fn_\"+(1E9*Math.random()>>>0);function qb(a){if(da(a))return a;a[Ab]||(a[Ab]=function(b){return a.handleEvent(b)});return a[Ab]};function B(){w.call(this);this.c=new hb(this);this.P=this;this.J=null}u(B,w);B.prototype[cb]=!0;g=B.prototype;g.addEventListener=function(a,b,c,d){ob(this,a,b,c,d)};g.removeEventListener=function(a,b,c,d){wb(this,a,b,c,d)};\ng.dispatchEvent=function(a){var b,c=this.J;if(c)for(b=[];c;c=c.J)b.push(c);c=this.P;var d=a.type||a;if(l(a))a=new A(a,c);else if(a instanceof A)a.target=a.target||c;else{var e=a;a=new A(d,c);Ga(a,e)}e=!0;if(b)for(var f=b.length-1;0<=f;f--){var h=a.a=b[f];e=Bb(h,d,!0,a)&&e}h=a.a=c;e=Bb(h,d,!0,a)&&e;e=Bb(h,d,!1,a)&&e;if(b)for(f=0;f<b.length;f++)h=a.a=b[f],e=Bb(h,d,!1,a)&&e;return e};\ng.w=function(){B.L.w.call(this);if(this.c){var a=this.c,b=0,c;for(c in a.a){for(var d=a.a[c],e=0;e<d.length;e++)++b,gb(d[e]);delete a.a[c];a.b--}}this.J=null};g.$=function(a,b,c,d){return this.c.add(String(a),b,!1,c,d)};g.Ia=function(a,b,c,d){return this.c.add(String(a),b,!0,c,d)};g.xa=function(a,b,c,d){var e=this.c;a=String(a).toString();if(a in e.a){var f=e.a[a];b=ib(f,b,c,d);-1<b?(gb(f[b]),Array.prototype.splice.call(f,b,1),0==f.length&&(delete e.a[a],e.b--),e=!0):e=!1}else e=!1;return e};\nfunction Bb(a,b,c,d){b=a.c.a[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var h=b[f];if(h&&!h.X&&h.capture==c){var m=h.listener,v=h.da||h.src;h.ba&&jb(a.c,h);e=!1!==m.call(v,d)&&e}}return e&&0!=d.Qa};function Cb(a){return/^\\s*$/.test(a)?!1:/^[\\],:{}\\s\\u2028\\u2029]*$/.test(a.replace(/\\\\[\"\\\\\\/bfnrtu]/g,\"@\").replace(/(?:\"[^\"\\\\\\n\\r\\u2028\\u2029\\x00-\\x08\\x0a-\\x1f]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[\\s\\u2028\\u2029]*(?=:|,|]|}|$)/g,\"]\").replace(/(?:^|:|,)(?:[\\s\\u2028\\u2029]*\\[)+/g,\"\"))}function Db(a){a=String(a);if(Cb(a))try{return eval(\"(\"+a+\")\")}catch(b){}throw Error(\"Invalid JSON string: \"+a);}function Eb(a){var b=[];Fb(new Gb,a,b);return b.join(\"\")}function Gb(){}\nfunction Fb(a,b,c){if(null==b)c.push(\"null\");else{if(\"object\"==typeof b){if(n(b)){var d=b;b=d.length;c.push(\"[\");for(var e=\"\",f=0;f<b;f++)c.push(e),Fb(a,d[f],c),e=\",\";c.push(\"]\");return}if(b instanceof String||b instanceof Number||b instanceof Boolean)b=b.valueOf();else{c.push(\"{\");e=\"\";for(d in b)Object.prototype.hasOwnProperty.call(b,d)&&(f=b[d],\"function\"!=typeof f&&(c.push(e),Hb(d,c),c.push(\":\"),Fb(a,f,c),e=\",\"));c.push(\"}\");return}}switch(typeof b){case \"string\":Hb(b,c);break;case \"number\":c.push(isFinite(b)&&\n!isNaN(b)?String(b):\"null\");break;case \"boolean\":c.push(String(b));break;case \"function\":c.push(\"null\");break;default:throw Error(\"Unknown type: \"+typeof b);}}}var Ib={'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\",\"/\":\"\\\\/\",\"\\b\":\"\\\\b\",\"\\f\":\"\\\\f\",\"\\n\":\"\\\\n\",\"\\r\":\"\\\\r\",\"\\t\":\"\\\\t\",\"\\x0B\":\"\\\\u000b\"},Kb=/\\uffff/.test(\"\\uffff\")?/[\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g:/[\\\\\"\\x00-\\x1f\\x7f-\\xff]/g;\nfunction Hb(a,b){b.push('\"',a.replace(Kb,function(a){var b=Ib[a];b||(b=\"\\\\u\"+(a.charCodeAt(0)|65536).toString(16).substr(1),Ib[a]=b);return b}),'\"')};function Lb(a,b,c){this.f=c;this.c=a;this.g=b;this.b=0;this.a=null}Lb.prototype.get=function(){if(0<this.b){this.b--;var a=this.a;this.a=a.next;a.next=null}else a=this.c();return a};function Mb(){this.b=this.a=null}var C=new Lb(function(){return new Nb},function(a){a.reset()},100);Mb.prototype.add=function(a,b){var c=C.get();c.set(a,b);this.b?this.b.next=c:this.a=c;this.b=c};function Ob(){var a=Pb,b=null;a.a&&(b=a.a,a.a=a.a.next,a.a||(a.b=null),b.next=null);return b}function Nb(){this.next=this.b=this.a=null}Nb.prototype.set=function(a,b){this.a=a;this.b=b;this.next=null};Nb.prototype.reset=function(){this.next=this.b=this.a=null};function Qb(a){k.setTimeout(function(){throw a;},0)}var Rb;\nfunction Sb(){var a=k.MessageChannel;\"undefined\"===typeof a&&\"undefined\"!==typeof window&&window.postMessage&&window.addEventListener&&!y(\"Presto\")&&(a=function(){var a=document.createElement(\"IFRAME\");a.style.display=\"none\";a.src=\"\";document.documentElement.appendChild(a);var b=a.contentWindow;a=b.document;a.open();a.write(\"\");a.close();var c=\"callImmediate\"+Math.random(),d=\"file:\"==b.location.protocol?\"*\":b.location.protocol+\"//\"+b.location.host;a=r(function(a){if((\"*\"==d||a.origin==d)&&a.data==\nc)this.port1.onmessage()},this);b.addEventListener(\"message\",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if(\"undefined\"!==typeof a&&!y(\"Trident\")&&!y(\"MSIE\")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.Ca;c.Ca=null;a()}};return function(a){d.next={Ca:a};d=d.next;b.port2.postMessage(0)}}return\"undefined\"!==typeof document&&\"onreadystatechange\"in document.createElement(\"SCRIPT\")?function(a){var b=document.createElement(\"SCRIPT\");\nb.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){k.setTimeout(a,0)}};var Tb;function Ub(){if(-1!=String(k.Promise).indexOf(\"[native code]\")){var a=k.Promise.resolve(void 0);Tb=function(){a.then(Vb)}}else Tb=function(){var a=Vb;!da(k.setImmediate)||k.Window&&k.Window.prototype&&!y(\"Edge\")&&k.Window.prototype.setImmediate==k.setImmediate?(Rb||(Rb=Sb()),Rb(a)):k.setImmediate(a)}}var Wb=!1,Pb=new Mb;function Vb(){for(var a;a=Ob();){try{a.a.call(a.b)}catch(b){Qb(b)}C.g(a);C.b<C.f&&(C.b++,a.next=C.a,C.a=a)}Wb=!1};function Xb(a,b){B.call(this);this.b=a||1;this.a=b||k;this.f=r(this.jb,this);this.g=t()}u(Xb,B);g=Xb.prototype;g.Z=!1;g.K=null;g.jb=function(){if(this.Z){var a=t()-this.g;0<a&&a<.8*this.b?this.K=this.a.setTimeout(this.f,this.b-a):(this.K&&(this.a.clearTimeout(this.K),this.K=null),this.dispatchEvent(\"tick\"),this.Z&&(this.K=this.a.setTimeout(this.f,this.b),this.g=t()))}};g.start=function(){this.Z=!0;this.K||(this.K=this.a.setTimeout(this.f,this.b),this.g=t())};\nfunction Yb(a){a.Z=!1;a.K&&(a.a.clearTimeout(a.K),a.K=null)}g.w=function(){Xb.L.w.call(this);Yb(this);delete this.a};function Zb(a,b,c){if(da(a))c&&(a=r(a,c));else if(a&&\"function\"==typeof a.handleEvent)a=r(a.handleEvent,a);else throw Error(\"Invalid listener argument\");return 2147483647<Number(b)?-1:k.setTimeout(a,b||0)};function $b(a,b,c){w.call(this);this.f=null!=c?r(a,c):a;this.c=b;this.b=r(this.cb,this);this.a=[]}u($b,w);g=$b.prototype;g.ea=!1;g.W=null;g.Ya=function(a){this.a=arguments;this.W?this.ea=!0:ac(this)};g.w=function(){$b.L.w.call(this);this.W&&(k.clearTimeout(this.W),this.W=null,this.ea=!1,this.a=[])};g.cb=function(){this.W=null;this.ea&&(this.ea=!1,ac(this))};function ac(a){a.W=Zb(a.b,a.c);a.f.apply(null,a.a)};function D(a){w.call(this);this.b=a;this.a={}}u(D,w);var bc=[];D.prototype.$=function(a,b,c,d){n(b)||(b&&(bc[0]=b.toString()),b=bc);for(var e=0;e<b.length;e++){var f=ob(a,b[e],c||this.handleEvent,d||!1,this.b||this);if(!f)break;this.a[f.key]=f}return this};\nD.prototype.xa=function(a,b,c,d,e){if(n(b))for(var f=0;f<b.length;f++)this.xa(a,b[f],c,d,e);else c=c||this.handleEvent,d=p(d)?!!d.capture:!!d,e=e||this.b||this,c=qb(c),d=!!d,b=db(a)?kb(a.c,String(b),c,d,e):a?(a=sb(a))?kb(a,b,c,d,e):null:null,b&&(xb(b),delete this.a[b.key]);return this};function cc(a){Ba(a.a,function(a,c){this.a.hasOwnProperty(c)&&xb(a)},a);a.a={}}D.prototype.w=function(){D.L.w.call(this);cc(this)};\nD.prototype.handleEvent=function(){throw Error(\"EventHandler.handleEvent not implemented\");};function dc(a,b,c,d,e){this.reset(a,b,c,d,e)}dc.prototype.a=null;var ec=0;dc.prototype.reset=function(a,b,c,d,e){\"number\"==typeof e||ec++;d||t();this.b=b;delete this.a};function fc(a){this.f=a;this.b=this.c=this.a=null}function E(a,b){this.name=a;this.value=b}E.prototype.toString=function(){return this.name};var gc=new E(\"SEVERE\",1E3),hc=new E(\"WARNING\",900),ic=new E(\"INFO\",800),jc=new E(\"CONFIG\",700),kc=new E(\"FINE\",500);function lc(a){if(a.c)return a.c;if(a.a)return lc(a.a);oa(\"Root logger has no level set.\");return null}\nfc.prototype.log=function(a,b,c){if(a.value>=lc(this).value)for(da(b)&&(b=b()),a=new dc(a,String(b),this.f),c&&(a.a=c),c=\"log:\"+a.b,(a=k.console)&&a.timeStamp&&a.timeStamp(c),(a=k.msWriteProfilerMark)&&a(c),c=this;c;)c=c.a};function F(a,b){a.log(gc,b,void 0)}function G(a,b){a.log(hc,b,void 0)}var mc={},nc=null;\nfunction oc(a){nc||(nc=new fc(\"\"),mc[\"\"]=nc,nc.c=jc);var b;if(!(b=mc[a])){b=new fc(a);var c=a.lastIndexOf(\".\"),d=a.substr(c+1);c=oc(a.substr(0,c));c.b||(c.b={});c.b[d]=b;b.a=c;mc[a]=b}return b};function pc(a,b){a&&a.log(ic,b,void 0)}function H(a,b){a&&a.log(kc,b,void 0)};function qc(){this.a=oc(\"goog.labs.net.webChannel.WebChannelDebug\")}function rc(a,b,c,d){if(c)try{var e=JSON.parse(c);if(e)for(var f=0;f<e.length;f++)if(n(e[f])){var h=e[f];if(!(2>h.length)){var m=h[1];if(n(m)&&!(1>m.length)){var v=m[0];if(\"noop\"!=v&&\"stop\"!=v&&\"close\"!=v)for(var Sa=1;Sa<m.length;Sa++)m[Sa]=\"\"}}}var Jb=Eb(e)}catch(Pe){I(a,\"Exception parsing expected JS array - probably was not JS\"),Jb=c}else Jb=null;I(a,\"XMLHTTP TEXT (\"+b+\"): \"+Jb+(d?\" \"+d:\"\"))}\nfunction sc(a,b,c){(a=a.a)&&F(a,(c||\"Exception\")+b)}function I(a,b){pc(a.a,b)};var J=new B;function tc(a){A.call(this,\"serverreachability\",a)}u(tc,A);function uc(){J.dispatchEvent(new tc(J))}function vc(a){A.call(this,\"statevent\",a)}u(vc,A);function K(){J.dispatchEvent(new vc(J))}function wc(a){A.call(this,\"timingevent\",a)}u(wc,A);function xc(a,b){if(!da(a))throw Error(\"Fn must not be null and must be a function\");return k.setTimeout(function(){a()},b)};var yc={NO_ERROR:0,kb:1,rb:2,qb:3,nb:4,pb:5,sb:6,Sa:7,TIMEOUT:8,vb:9};var zc={mb:\"complete\",zb:\"success\",Ta:\"error\",Sa:\"abort\",xb:\"ready\",yb:\"readystatechange\",TIMEOUT:\"timeout\",tb:\"incrementaldata\",wb:\"progress\",ob:\"downloadprogress\",Ab:\"uploadprogress\"};function Ac(){}Ac.prototype.a=null;function Bc(a){var b;(b=a.a)||(b={},Cc(a)&&(b[0]=!0,b[1]=!0),b=a.a=b);return b};var Dc;function Ec(){}u(Ec,Ac);function Fc(a){return(a=Cc(a))?new ActiveXObject(a):new XMLHttpRequest}function Cc(a){if(!a.b&&\"undefined\"==typeof XMLHttpRequest&&\"undefined\"!=typeof ActiveXObject){for(var b=[\"MSXML2.XMLHTTP.6.0\",\"MSXML2.XMLHTTP.3.0\",\"MSXML2.XMLHTTP\",\"Microsoft.XMLHTTP\"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.b=d}catch(e){}}throw Error(\"Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed\");}return a.b}Dc=new Ec;function L(a,b,c,d,e){this.m=a;this.b=b;this.f=d;this.S=e||1;this.M=new D(this);this.P=Gc;a=this.F=new Xb;a.b=Hc;a.K&&a.Z?(Yb(a),a.start()):a.K&&Yb(a);this.h=null;this.c=!1;this.a=this.B=this.g=this.l=this.I=this.H=this.T=this.o=null;this.C=0;this.i=this.j=null;this.v=-1;this.s=!1;this.N=0;this.G=null;this.J=!1}var Gc=45E3,Hc=250;\nfunction Ic(a,b){switch(a){case 0:return\"Non-200 return code (\"+b+\")\";case 1:return\"XMLHTTP failure (no data)\";case 2:return\"HttpConnection timeout\";default:return\"Unknown error\"}}var Jc={},Kc={};g=L.prototype;g.setTimeout=function(a){this.P=a};function Lc(a,b,c){a.I=1;a.l=Mc(M(b));a.B=c;a.J=!0;Nc(a,null)}function Oc(a,b,c,d){a.I=1;a.l=Mc(M(b));a.B=null;a.J=c;Nc(a,d)}\nfunction Nc(a,b){a.H=t();Pc(a);a.g=M(a.l);Qc(a.g,\"t\",a.S);a.C=0;a.a=a.m.ra(a.m.fa()?b:null);0<a.N&&(a.G=new $b(r(a.Ra,a,a.a),a.N));a.M.$(a.a,\"readystatechange\",a.gb);b=a.h?Ea(a.h):{};a.B?(a.j||(a.j=\"POST\"),b[\"Content-Type\"]=\"application/x-www-form-urlencoded\",a.a.ta(a.g,a.j,a.B,b)):(a.j=\"GET\",a.a.ta(a.g,a.j,null,b));uc();var c=a.B;if(c){b=\"\";c=c.split(\"&\");for(var d=0;d<c.length;d++){var e=c[d].split(\"=\");if(1<e.length){var f=e[0];e=e[1];var h=f.split(\"_\");b=2<=h.length&&\"type\"==h[1]?b+(f+\"=\"+e+\"&\"):\nb+(f+\"=redacted&\")}}}else b=null;I(a.b,\"XMLHTTP REQ (\"+a.f+\") [attempt \"+a.S+\"]: \"+a.j+\"\\n\"+a.g+\"\\n\"+b)}g.gb=function(a){a=a.target;var b=this.G;b&&3==N(a)?(I(this.b,\"Throttling readystatechange.\"),b.Ya()):this.Ra(a)};\ng.Ra=function(a){try{if(a==this.a){var b=N(this.a),c=this.a.Ga();if(!(3>b||3==b&&!Ka&&!this.a.U())){this.s||4!=b||7==c||uc();Rc(this);var d=this.a.V();this.v=d;var e=this.a.U();e||I(this.b,\"No response text for uri \"+this.g+\" status \"+d);this.c=200==d;I(this.b,\"XMLHTTP RESP (\"+this.f+\") [ attempt \"+this.S+\"]: \"+this.j+\"\\n\"+this.g+\"\\n\"+b+\" \"+d);if(this.c)this.J?(Sc(this,b,e),Ka&&this.c&&3==b&&(this.M.$(this.F,\"tick\",this.fb),this.F.start())):(rc(this.b,this.f,e,null),Tc(this,e)),4==b&&Uc(this),this.c&&\n!this.s&&(4==b?this.m.wa(this):(this.c=!1,Pc(this)));else{if(400==d&&0<e.indexOf(\"Unknown SID\")){this.i=3;K();var f=this.b.a;f&&G(f,\"XMLHTTP Unknown SID (\"+this.f+\")\")}else{this.i=0;K();var h=this.b.a;h&&G(h,\"XMLHTTP Bad status \"+d+\" (\"+this.f+\")\")}Uc(this);Vc(this)}}}else{var m=this.b.a;m&&G(m,\"Called back with an unexpected xmlhttp\")}}catch(v){I(this.b,\"Failed call to OnXmlHttpReadyStateChanged_\"),this.a&&this.a.U()?sc(this.b,v,\"ResponseText: \"+this.a.U()):sc(this.b,v,\"No response text\")}finally{}};\nfunction Sc(a,b,c){for(var d=!0;!a.s&&a.C<c.length;){var e=Wc(a,c);if(e==Kc){4==b&&(a.i=4,K(),d=!1);rc(a.b,a.f,null,\"[Incomplete Response]\");break}else if(e==Jc){a.i=4;K();rc(a.b,a.f,c,\"[Invalid Chunk]\");d=!1;break}else rc(a.b,a.f,e,null),Tc(a,e)}4==b&&0==c.length&&(a.i=1,K(),d=!1);a.c=a.c&&d;d||(rc(a.b,a.f,c,\"[Invalid Chunked Response]\"),Uc(a),Vc(a))}g.fb=function(){var a=N(this.a),b=this.a.U();this.C<b.length&&(Rc(this),Sc(this,a,b),this.c&&4!=a&&Pc(this))};\nfunction Wc(a,b){var c=a.C,d=b.indexOf(\"\\n\",c);if(-1==d)return Kc;c=Number(b.substring(c,d));if(isNaN(c))return Jc;d+=1;if(d+c>b.length)return Kc;b=b.substr(d,c);a.C=d+c;return b}g.cancel=function(){this.s=!0;Uc(this)};function Pc(a){a.T=t()+a.P;Xc(a,a.P)}function Xc(a,b){if(null!=a.o)throw Error(\"WatchDog timer not null\");a.o=xc(r(a.eb,a),b)}function Rc(a){a.o&&(k.clearTimeout(a.o),a.o=null)}\ng.eb=function(){this.o=null;var a=t();if(0<=a-this.T)this.c&&(a=this.b.a)&&F(a,\"Received watchdog timeout even though request loaded successfully\"),I(this.b,\"TIMEOUT: \"+this.g),2!=this.I&&(uc(),K()),Uc(this),this.i=2,Vc(this);else{var b=this.b.a;b&&G(b,\"WatchDog timer called too early\");Xc(this,this.T-a)}};function Vc(a){a.m.Ka()||a.s||a.m.wa(a)}function Uc(a){Rc(a);var b=a.G;b&&\"function\"==typeof b.Y&&b.Y();a.G=null;Yb(a.F);cc(a.M);a.a&&(b=a.a,a.a=null,b.abort(),b.Y())}\nfunction Tc(a,b){try{a.m.Na(a,b),uc()}catch(c){sc(a.b,c,\"Error in httprequest callback\")}};function Yc(a){if(a.A&&\"function\"==typeof a.A)return a.A();if(l(a))return a.split(\"\");if(ca(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return Ca(a)}\nfunction Zc(a,b){if(a.forEach&&\"function\"==typeof a.forEach)a.forEach(b,void 0);else if(ca(a)||l(a))ta(a,b,void 0);else{if(a.O&&\"function\"==typeof a.O)var c=a.O();else if(a.A&&\"function\"==typeof a.A)c=void 0;else if(ca(a)||l(a)){c=[];for(var d=a.length,e=0;e<d;e++)c.push(e)}else c=Da(a);d=Yc(a);e=d.length;for(var f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],a)}};function O(a,b){this.b={};this.a=[];this.c=0;var c=arguments.length;if(1<c){if(c%2)throw Error(\"Uneven number of arguments\");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else if(a){a instanceof O?(c=a.O(),d=a.A()):(c=Da(a),d=Ca(a));for(var e=0;e<c.length;e++)this.set(c[e],d[e])}}g=O.prototype;g.u=function(){return this.c};g.A=function(){$c(this);for(var a=[],b=0;b<this.a.length;b++)a.push(this.b[this.a[b]]);return a};g.O=function(){$c(this);return this.a.concat()};\nfunction ad(a){a.b={};a.a.length=0;a.c=0}function bd(a,b){return P(a.b,b)?(delete a.b[b],a.c--,a.a.length>2*a.c&&$c(a),!0):!1}function $c(a){if(a.c!=a.a.length){for(var b=0,c=0;b<a.a.length;){var d=a.a[b];P(a.b,d)&&(a.a[c++]=d);b++}a.a.length=c}if(a.c!=a.a.length){var e={};for(c=b=0;b<a.a.length;)d=a.a[b],P(e,d)||(a.a[c++]=d,e[d]=1),b++;a.a.length=c}}g.get=function(a,b){return P(this.b,a)?this.b[a]:b};g.set=function(a,b){P(this.b,a)||(this.c++,this.a.push(a));this.b[a]=b};\ng.forEach=function(a,b){for(var c=this.O(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};function P(a,b){return Object.prototype.hasOwnProperty.call(a,b)};var cd=/^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$/;function dd(a,b){if(a){a=a.split(\"&\");for(var c=0;c<a.length;c++){var d=a[c].indexOf(\"=\"),e=null;if(0<=d){var f=a[c].substring(0,d);e=a[c].substring(d+1)}else f=a[c];b(f,e?decodeURIComponent(e.replace(/\\+/g,\" \")):\"\")}}};function Q(a,b){this.b=this.j=this.f=\"\";this.i=null;this.g=this.a=\"\";this.h=!1;var c;a instanceof Q?(this.h=void 0!==b?b:a.h,ed(this,a.f),this.j=a.j,fd(this,a.b),gd(this,a.i),this.a=a.a,hd(this,id(a.c)),this.g=a.g):a&&(c=String(a).match(cd))?(this.h=!!b,ed(this,c[1]||\"\",!0),this.j=jd(c[2]||\"\"),fd(this,c[3]||\"\",!0),gd(this,c[4]),this.a=jd(c[5]||\"\",!0),hd(this,c[6]||\"\",!0),this.g=jd(c[7]||\"\")):(this.h=!!b,this.c=new kd(null,0,this.h))}\nQ.prototype.toString=function(){var a=[],b=this.f;b&&a.push(ld(b,md,!0),\":\");var c=this.b;if(c||\"file\"==b)a.push(\"//\"),(b=this.j)&&a.push(ld(b,md,!0),\"@\"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),c=this.i,null!=c&&a.push(\":\",String(c));if(c=this.a)this.b&&\"/\"!=c.charAt(0)&&a.push(\"/\"),a.push(ld(c,\"/\"==c.charAt(0)?nd:od,!0));(c=this.c.toString())&&a.push(\"?\",c);(c=this.g)&&a.push(\"#\",ld(c,pd));return a.join(\"\")};\nQ.prototype.resolve=function(a){var b=M(this),c=!!a.f;c?ed(b,a.f):c=!!a.j;c?b.j=a.j:c=!!a.b;c?fd(b,a.b):c=null!=a.i;var d=a.a;if(c)gd(b,a.i);else if(c=!!a.a){if(\"/\"!=d.charAt(0))if(this.b&&!this.a)d=\"/\"+d;else{var e=b.a.lastIndexOf(\"/\");-1!=e&&(d=b.a.substr(0,e+1)+d)}e=d;if(\"..\"==e||\".\"==e)d=\"\";else if(-1!=e.indexOf(\"./\")||-1!=e.indexOf(\"/.\")){d=0==e.lastIndexOf(\"/\",0);e=e.split(\"/\");for(var f=[],h=0;h<e.length;){var m=e[h++];\".\"==m?d&&h==e.length&&f.push(\"\"):\"..\"==m?((1<f.length||1==f.length&&\"\"!=\nf[0])&&f.pop(),d&&h==e.length&&f.push(\"\")):(f.push(m),d=!0)}d=f.join(\"/\")}else d=e}c?b.a=d:c=\"\"!==a.c.toString();c?hd(b,id(a.c)):c=!!a.g;c&&(b.g=a.g);return b};function M(a){return new Q(a)}function ed(a,b,c){a.f=c?jd(b,!0):b;a.f&&(a.f=a.f.replace(/:$/,\"\"))}function fd(a,b,c){a.b=c?jd(b,!0):b}function gd(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error(\"Bad port number \"+b);a.i=b}else a.i=null}function hd(a,b,c){b instanceof kd?(a.c=b,qd(a.c,a.h)):(c||(b=ld(b,rd)),a.c=new kd(b,0,a.h))}\nfunction R(a,b,c){a.c.set(b,c)}function Qc(a,b,c){n(c)||(c=[String(c)]);sd(a.c,b,c)}function Mc(a){R(a,\"zx\",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^t()).toString(36));return a}function td(a){return a instanceof Q?M(a):new Q(a,void 0)}function ud(a,b,c,d){var e=new Q(null,void 0);a&&ed(e,a);b&&fd(e,b);c&&gd(e,c);d&&(e.a=d);return e}function jd(a,b){return a?b?decodeURI(a.replace(/%25/g,\"%2525\")):decodeURIComponent(a):\"\"}\nfunction ld(a,b,c){return l(a)?(a=encodeURI(a).replace(b,vd),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),a):null}function vd(a){a=a.charCodeAt(0);return\"%\"+(a>>4&15).toString(16)+(a&15).toString(16)}var md=/[#\\/\\?@]/g,od=/[#\\?:]/g,nd=/[#\\?]/g,rd=/[#\\?@]/g,pd=/#/g;function kd(a,b,c){this.b=this.a=null;this.c=a||null;this.f=!!c}function S(a){a.a||(a.a=new O,a.b=0,a.c&&dd(a.c,function(b,c){a.add(decodeURIComponent(b.replace(/\\+/g,\" \")),c)}))}g=kd.prototype;g.u=function(){S(this);return this.b};\ng.add=function(a,b){S(this);this.c=null;a=wd(this,a);var c=this.a.get(a);c||this.a.set(a,c=[]);c.push(b);this.b+=1;return this};function xd(a,b){S(a);b=wd(a,b);P(a.a.b,b)&&(a.c=null,a.b-=a.a.get(b).length,bd(a.a,b))}function yd(a,b){S(a);b=wd(a,b);return P(a.a.b,b)}g.forEach=function(a,b){S(this);this.a.forEach(function(c,d){ta(c,function(c){a.call(b,c,d,this)},this)},this)};\ng.O=function(){S(this);for(var a=this.a.A(),b=this.a.O(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};g.A=function(a){S(this);var b=[];if(l(a))yd(this,a)&&(b=xa(b,this.a.get(wd(this,a))));else{a=this.a.A();for(var c=0;c<a.length;c++)b=xa(b,a[c])}return b};g.set=function(a,b){S(this);this.c=null;a=wd(this,a);yd(this,a)&&(this.b-=this.a.get(a).length);this.a.set(a,[b]);this.b+=1;return this};g.get=function(a,b){a=a?this.A(a):[];return 0<a.length?String(a[0]):b};\nfunction sd(a,b,c){xd(a,b);0<c.length&&(a.c=null,a.a.set(wd(a,b),ya(c)),a.b+=c.length)}g.toString=function(){if(this.c)return this.c;if(!this.a)return\"\";for(var a=[],b=this.a.O(),c=0;c<b.length;c++){var d=b[c],e=encodeURIComponent(String(d));d=this.A(d);for(var f=0;f<d.length;f++){var h=e;\"\"!==d[f]&&(h+=\"=\"+encodeURIComponent(String(d[f])));a.push(h)}}return this.c=a.join(\"&\")};function id(a){var b=new kd;b.c=a.c;a.a&&(b.a=new O(a.a),b.b=a.b);return b}\nfunction wd(a,b){b=String(b);a.f&&(b=b.toLowerCase());return b}function qd(a,b){b&&!a.f&&(S(a),a.c=null,a.a.forEach(function(a,b){var c=b.toLowerCase();b!=c&&(xd(this,b),sd(this,c,a))},a));a.f=b};function zd(){this.a=t()}var Ad=null;zd.prototype.set=function(a){this.a=a};zd.prototype.reset=function(){this.set(t())};zd.prototype.get=function(){return this.a};function Bd(){Ad||(Ad=new zd)}function Cd(){Ad||(Ad=new zd)}u(Cd,Bd);function Dd(){}var Ed={OPEN:\"a\",lb:\"b\",Ta:\"c\",ub:\"d\"};function Fd(){A.call(this,\"d\")}u(Fd,A);function Gd(){A.call(this,\"c\")}u(Gd,A);function Hd(a,b){this.a=a;this.b=b;this.c=this.i=null;this.h=!1;this.l=null;this.f=-1;this.m=this.g=null}g=Hd.prototype;g.R=null;function Id(a){I(a.b,\"TestConnection: starting stage 2\");var b=a.a.J.a;if(null!=b)I(a.b,\"TestConnection: skipping stage 2, precomputed result is \"+b?\"Buffered\":\"Unbuffered\"),K(),b?(K(),Jd(a.a,a,!1)):(K(),Jd(a.a,a,!0));else{a.c=new L(a,a.b,0,void 0,void 0);a.c.h=a.i;b=Kd(a.a,a.g,a.l);K();Qc(b,\"TYPE\",\"xmlhttp\");var c=a.a.j,d=a.a.N;c&&d&&R(b,c,d);Oc(a.c,b,!1,a.g)}}g.ra=function(a){return this.a.ra(a)};\ng.abort=function(){this.c&&(this.c.cancel(),this.c=null);this.f=-1};g.Ka=function(){return!1};\ng.Na=function(a,b){this.f=a.v;if(0==this.R){I(this.b,\"TestConnection: Got data for stage 1\");if(!this.a.F&&(a=a.a)){var c=a.a?a.a.getResponseHeader(\"X-Client-Wire-Protocol\"):null;this.m=c?c:null;this.a.j&&((a=a.a?a.a.getResponseHeader(\"X-HTTP-Session-Id\"):null)?this.a.N=a:(a=this.b.a)&&G(a,\"Missing X_HTTP_SESSION_ID in the handshake response\"))}if(b){try{var d=this.a.la.a.parse(b)}catch(e){sc(this.b,e);Ld(this.a,this);return}this.g=d[0]}else I(this.b,\"TestConnection: Null responseText\"),Ld(this.a,\nthis)}else if(1==this.R)if(this.h)K();else if(\"11111\"==b){if(K(),this.h=!0,!z||10<=Number(Va))this.f=200,this.c.cancel(),I(this.b,\"Test connection succeeded; using streaming connection\"),K(),Jd(this.a,this,!0)}else K(),this.h=!1};\ng.wa=function(){this.f=this.c.v;this.c.c?0==this.R?(this.R=1,I(this.b,\"TestConnection: request complete for initial check\"),Id(this)):1==this.R&&(I(this.b,\"TestConnection: request complete for stage 2\"),this.h?(I(this.b,\"Test connection succeeded; using streaming connection\"),K(),Jd(this.a,this,!0)):(I(this.b,\"Test connection failed; not using streaming\"),K(),Jd(this.a,this,!1))):(I(this.b,\"TestConnection: request failed, in state \"+this.R),0==this.R?K():1==this.R&&K(),Ld(this.a,this))};g.fa=function(){return this.a.fa()};\ng.sa=function(){return this.a.sa()};function Md(){this.a=this.b=null};function T(a){this.a=new O;if(a){a=Yc(a);for(var b=a.length,c=0;c<b;c++)this.add(a[c])}}function Nd(a){var b=typeof a;return\"object\"==b&&a||\"function\"==b?\"o\"+(a[q]||(a[q]=++ea)):b.charAt(0)+a}T.prototype.u=function(){return this.a.u()};T.prototype.add=function(a){this.a.set(Nd(a),a)};T.prototype.contains=function(a){a=Nd(a);return P(this.a.b,a)};T.prototype.A=function(){return this.a.A()};function Od(a){this.f=a||Pd;this.c=k.pa&&k.pa.La&&k.pa.La()&&k.pa.La().Cb?this.f:1;this.a=null;1<this.c&&(this.a=new T);this.b=null}var Pd=10;function Qd(a,b){a.a||-1==b.indexOf(\"spdy\")&&-1==b.indexOf(\"quic\")&&-1==b.indexOf(\"h2\")||(a.c=a.f,a.a=new T,a.b&&(Rd(a,a.b),a.b=null))}function Sd(a){return a.b?!0:a.a?a.a.u()>=a.c:!1}function Td(a,b){return a.b?a.b==b:a.a?a.a.contains(b):!1}function Rd(a,b){a.a?a.a.add(b):a.b=b}\nOd.prototype.cancel=function(){this.b?(this.b.cancel(),this.b=null):this.a&&0!=this.a.a.c&&(ta(this.a.A(),function(a){a.cancel()}),ad(this.a.a))};function Ud(a,b){this.a=a;this.b=b};function Vd(a,b){this.a=a;this.b=b}Vd.prototype.stringify=function(a){return k.JSON.stringify(a,this.a)};Vd.prototype.parse=function(a){return k.JSON.parse(a,this.b)};function Wd(){this.a=new Vd}function Xd(a,b,c){var d=c||\"\";try{Zc(a,function(a,c){var e=a;p(a)&&(e=Eb(a));b.push(d+c+\"=\"+encodeURIComponent(e))})}catch(e){throw b.push(d+\"type=\"+encodeURIComponent(\"_badmap\")),e;}};function Yd(a,b){var c=new qc;I(c,\"TestLoadImage: loading \"+a);var d=new Image;d.onload=ia(Zd,c,d,\"TestLoadImage: loaded\",!0,b);d.onerror=ia(Zd,c,d,\"TestLoadImage: error\",!1,b);d.onabort=ia(Zd,c,d,\"TestLoadImage: abort\",!1,b);d.ontimeout=ia(Zd,c,d,\"TestLoadImage: timeout\",!1,b);k.setTimeout(function(){if(d.ontimeout)d.ontimeout()},1E4);d.src=a}function Zd(a,b,c,d,e){try{I(a,c),b.onload=null,b.onerror=null,b.onabort=null,b.ontimeout=null,e(d)}catch(f){sc(a,f)}};function U(a){B.call(this);this.headers=new O;this.G=a||null;this.f=!1;this.F=this.a=null;this.M=this.s=\"\";this.j=0;this.g=\"\";this.h=this.I=this.o=this.H=!1;this.l=0;this.B=null;this.N=$d;this.C=this.m=!1}u(U,B);var $d=\"\";U.prototype.b=oc(\"goog.net.XhrIo\");var ae=/^https?$/i,be=[\"POST\",\"PUT\"];g=U.prototype;\ng.ta=function(a,b,c,d){if(this.a)throw Error(\"[goog.net.XhrIo] Object is active with another request=\"+this.s+\"; newUri=\"+a);b=b?b.toUpperCase():\"GET\";this.s=a;this.g=\"\";this.j=0;this.M=b;this.H=!1;this.f=!0;this.a=this.G?Fc(this.G):Fc(Dc);this.F=this.G?Bc(this.G):Bc(Dc);this.a.onreadystatechange=r(this.Ma,this);try{H(this.b,V(this,\"Opening Xhr\")),this.I=!0,this.a.open(b,String(a),!0),this.I=!1}catch(f){H(this.b,V(this,\"Error opening Xhr: \"+f.message));ce(this,f);return}a=c||\"\";var e=new O(this.headers);\nd&&Zc(d,function(a,b){e.set(b,a)});d=ua(e.O());c=k.FormData&&a instanceof k.FormData;!(0<=sa(be,b))||d||c||e.set(\"Content-Type\",\"application/x-www-form-urlencoded;charset=utf-8\");e.forEach(function(a,b){this.a.setRequestHeader(b,a)},this);this.N&&(this.a.responseType=this.N);\"withCredentials\"in this.a&&this.a.withCredentials!==this.m&&(this.a.withCredentials=this.m);try{de(this),0<this.l&&(this.C=ee(this.a),H(this.b,V(this,\"Will abort after \"+this.l+\"ms if incomplete, xhr2 \"+this.C)),this.C?(this.a.timeout=\nthis.l,this.a.ontimeout=r(this.Ja,this)):this.B=Zb(this.Ja,this.l,this)),H(this.b,V(this,\"Sending request\")),this.o=!0,this.a.send(a),this.o=!1}catch(f){H(this.b,V(this,\"Send error: \"+f.message)),ce(this,f)}};function ee(a){return z&&Ua(9)&&\"number\"==typeof a.timeout&&void 0!==a.ontimeout}function va(a){return\"content-type\"==a.toLowerCase()}\ng.Ja=function(){\"undefined\"!=typeof goog&&this.a&&(this.g=\"Timed out after \"+this.l+\"ms, aborting\",this.j=8,H(this.b,V(this,this.g)),this.dispatchEvent(\"timeout\"),this.abort(8))};function ce(a,b){a.f=!1;a.a&&(a.h=!0,a.a.abort(),a.h=!1);a.g=b;a.j=5;fe(a);ge(a)}function fe(a){a.H||(a.H=!0,a.dispatchEvent(\"complete\"),a.dispatchEvent(\"error\"))}\ng.abort=function(a){this.a&&this.f&&(H(this.b,V(this,\"Aborting\")),this.f=!1,this.h=!0,this.a.abort(),this.h=!1,this.j=a||7,this.dispatchEvent(\"complete\"),this.dispatchEvent(\"abort\"),ge(this))};g.w=function(){this.a&&(this.f&&(this.f=!1,this.h=!0,this.a.abort(),this.h=!1),ge(this,!0));U.L.w.call(this)};g.Ma=function(){this.i||(this.I||this.o||this.h?he(this):this.bb())};g.bb=function(){he(this)};\nfunction he(a){if(a.f&&\"undefined\"!=typeof goog)if(a.F[1]&&4==N(a)&&2==a.V())H(a.b,V(a,\"Local request error detected and ignored\"));else if(a.o&&4==N(a))Zb(a.Ma,0,a);else if(a.dispatchEvent(\"readystatechange\"),4==N(a)){H(a.b,V(a,\"Request complete\"));a.f=!1;try{var b=a.V();a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.s).match(cd)[1]||null;if(!f&&k.self&&k.self.location){var h=k.self.location.protocol;\nf=h.substr(0,h.length-1)}e=!ae.test(f?f.toLowerCase():\"\")}d=e}d?(a.dispatchEvent(\"complete\"),a.dispatchEvent(\"success\")):(a.j=6,a.g=a.Ha()+\" [\"+a.V()+\"]\",fe(a))}finally{ge(a)}}}function ge(a,b){if(a.a){de(a);var c=a.a,d=a.F[0]?aa:null;a.a=null;a.F=null;b||a.dispatchEvent(\"ready\");try{c.onreadystatechange=d}catch(e){(a=a.b)&&F(a,\"Problem encountered resetting onreadystatechange: \"+e.message)}}}function de(a){a.a&&a.C&&(a.a.ontimeout=null);\"number\"==typeof a.B&&(k.clearTimeout(a.B),a.B=null)}\nfunction N(a){return a.a?a.a.readyState:0}g.V=function(){try{return 2<N(this)?this.a.status:-1}catch(a){return-1}};g.Ha=function(){try{return 2<N(this)?this.a.statusText:\"\"}catch(a){return H(this.b,\"Can not get status: \"+a.message),\"\"}};g.U=function(){try{return this.a?this.a.responseText:\"\"}catch(a){return H(this.b,\"Can not get responseText: \"+a.message),\"\"}};\ng.Za=function(a){if(this.a){var b=this.a.responseText;a&&0==b.indexOf(a)&&(b=b.substring(a.length));a:{a=b;if(k.JSON)try{var c=k.JSON.parse(a);break a}catch(d){}c=Db(a)}return c}};g.Ga=function(){return this.j};g.$a=function(){return l(this.g)?this.g:String(this.g)};function V(a,b){return b+\" [\"+a.M+\" \"+a.s+\" \"+a.V()+\"]\"};function ie(a){var b=\"\";Ba(a,function(a,d){b+=d;b+=\":\";b+=a;b+=\"\\r\\n\"});return b}function je(a,b,c){a:{for(d in c){var d=!1;break a}d=!0}if(d)return a;c=ie(c);if(l(a)){b=encodeURIComponent(String(b));c=null!=c?\"=\"+encodeURIComponent(String(c)):\"\";if(b+=c){c=a.indexOf(\"#\");0>c&&(c=a.length);d=a.indexOf(\"?\");if(0>d||d>c){d=c;var e=\"\"}else e=a.substring(d+1,c);a=[a.substr(0,d),e,a.substr(c)];c=a[1];a[1]=b?c?c+\"&\"+b:b:c;a=a[0]+(a[1]?\"?\"+a[1]:\"\")+a[2]}return a}R(a,b,c);return a};function ke(a,b,c){this.za=b||0;this.Ba=0;this.h=[];this.l=[];this.a=new qc;this.J=c||new Md;this.ia=this.ya=this.H=this.ja=this.b=this.N=this.j=this.ha=this.f=this.P=this.i=null;this.Va=this.I=0;this.ka=this.C=this.s=this.m=this.o=this.c=null;this.v=this.Aa=this.S=-1;this.ga=this.B=this.G=0;this.T=a&&a.supportsCrossDomainXhr||!1;this.M=\"\";this.g=new Od(a&&a.concurrentRequestLimit);this.la=new Wd;this.F=a&&void 0!==a.backgroundChannelTest?a.backgroundChannelTest:!0;this.Ua=a&&a.fastHandshake||!1}\ng=ke.prototype;g.oa=8;g.D=1;function le(a){I(a.a,\"disconnect()\");me(a);if(3==a.D){var b=a.I++,c=M(a.H);R(c,\"SID\",a.M);R(c,\"RID\",b);R(c,\"TYPE\",\"terminate\");ne(a,c);b=new L(a,a.a,0,b,void 0);b.I=2;b.l=Mc(M(c));c=!1;k.navigator&&k.navigator.sendBeacon&&(c=k.navigator.sendBeacon(b.l.toString(),\"\"));c||((new Image).src=b.l);b.H=t();Pc(b)}oe(a)}\nfunction me(a){a.C&&(a.C.abort(),a.C=null);a.b&&(a.b.cancel(),a.b=null);a.m&&(k.clearTimeout(a.m),a.m=null);pe(a);a.g.cancel();a.o&&(k.clearTimeout(a.o),a.o=null)}function qe(a,b){if(1E3==a.h.length){var c=\"Already have 1000 queued maps upon queueing \"+Eb(b),d=a.a.a;d&&F(d,c)}a.h.push(new Ud(a.Va++,b));3==a.D&&re(a)}g.Ka=function(){return 0==this.D};function re(a){Sd(a.g)||a.o||(a.o=xc(r(a.Pa,a),0),a.G=0)}\ng.Pa=function(a){this.o=null;I(this.a,\"startForwardChannel_\");if(1==this.D)if(a)(a=this.a.a)&&F(a,\"Not supposed to retry the open\");else{I(this.a,\"open_()\");this.I=Math.floor(1E5*Math.random());a=this.I++;var b=new L(this,this.a,0,a,void 0),c=this.i;this.P&&(c?(c=Ea(c),Ga(c,this.P)):c=this.P);null===this.f&&(b.h=c);var d=se(this),e=M(this.H);R(e,\"RID\",a);0<this.za&&R(e,\"CVER\",this.za);this.F&&this.j&&R(e,\"X-HTTP-Session-Id\",this.j);ne(this,e);this.f&&c&&je(e,this.f,c);Rd(this.g,b);this.Ua?(R(e,\"$req\",\nd),Lc(b,e,null)):Lc(b,e,d);this.D=2}else 3==this.D&&(a?te(this,a):0==this.h.length?I(this.a,\"startForwardChannel_ returned: nothing to send\"):Sd(this.g)?(a=this.a.a)&&F(a,\"startForwardChannel_ returned: connection already in progress\"):(te(this),I(this.a,\"startForwardChannel_ finished, sent request\")))};\nfunction te(a,b){if(b){a.h=a.l.concat(a.h);a.l.length=0;var c=a.I-1}else c=a.I++;b=se(a);var d=M(a.H);R(d,\"SID\",a.M);R(d,\"RID\",c);R(d,\"AID\",a.S);ne(a,d);a.f&&a.i&&je(d,a.f,a.i);c=new L(a,a.a,0,c,a.G+1);null===a.f&&(c.h=a.i);c.setTimeout(Math.round(1E4)+Math.round(1E4*Math.random()));Rd(a.g,c);Lc(c,d,b)}function ne(a,b){a.c&&Zc({},function(a,d){R(b,d,a)})}\nfunction se(a){var b=Math.min(a.h.length,1E3),c=a.c?r(a.c.Wa,a.c,a):null,d=a.h,e=[\"count=\"+b];if(0<b){var f=d[0].a;e.push(\"ofs=\"+f)}else f=0;for(var h=0;h<b;h++){var m=d[h].a,v=d[h].b;m-=f;try{Xd(v,e,\"req\"+m+\"_\")}catch(Sa){c&&c(v)}}c=e.join(\"&\");a.l=a.l.concat(a.h.splice(0,b));return c}function ue(a){if(!a.b&&!a.m){a.ga=1;var b=a.Oa;Tb||Ub();Wb||(Tb(),Wb=!0);Pb.add(b,a);a.B=0}}\nfunction ve(a){if(a.b||a.m)return(a=a.a.a)&&F(a,\"Request already in progress\"),!1;if(3<=a.B)return!1;I(a.a,\"Going to retry GET\");a.ga++;a.m=xc(r(a.Oa,a),we(a,a.B));a.B++;return!0}\ng.Oa=function(){this.m=null;I(this.a,\"Creating new HttpRequest\");this.b=new L(this,this.a,0,\"rpc\",this.ga);null===this.f&&(this.b.h=this.i);this.b.N=0;var a=M(this.ya);R(a,\"RID\",\"rpc\");R(a,\"SID\",this.M);R(a,\"CI\",this.ka?\"0\":\"1\");R(a,\"AID\",this.S);ne(this,a);R(a,\"TYPE\",\"xmlhttp\");this.f&&this.i&&je(a,this.f,this.i);Oc(this.b,a,!0,this.ia);I(this.a,\"New Request created\")};\nfunction Jd(a,b,c){I(a.a,\"Test Connection Finished\");var d=b.m;d&&Qd(a.g,d);a.ka=c;a.v=b.f;I(a.a,\"connectChannel_()\");a.H=xe(a,a.ja);re(a)}function Ld(a,b){I(a.a,\"Test Connection Failed\");a.v=b.f;W(a,2)}\ng.Na=function(a,b){if(0!=this.D&&(this.b==a||Td(this.g,a)))if(this.v=a.v,Td(this.g,a)&&3==this.D){try{var c=this.la.a.parse(b)}catch(f){c=null}if(n(c)&&3==c.length)if(b=c,0==b[0])a:if(I(this.a,\"Server claims our backchannel is missing.\"),this.m)I(this.a,\"But we are currently starting the request.\");else{if(this.b)if(this.b.H+3E3<a.H)pe(this),this.b.cancel(),this.b=null;else break a;else(a=this.a.a)&&G(a,\"We do not have a BackChannel established\");ve(this);K()}else this.Aa=b[1],a=this.Aa-this.S,0<\na&&(b=b[2],I(this.a,b+\" bytes (in \"+a+\" arrays) are outstanding on the BackChannel\"),37500>b&&this.ka&&0==this.B&&!this.s&&(this.s=xc(r(this.ab,this),6E3)));else I(this.a,\"Bad POST response data returned\"),W(this,11)}else if(this.b==a&&pe(this),!/^[\\s\\xa0]*$/.test(b))for(b=c=this.la.a.parse(b),c=0;c<b.length;c++){var d=b[c];this.S=d[0];d=d[1];if(2==this.D)if(\"c\"==d[0]){this.M=d[1];this.ia=d[2];var e=d[3];null!=e&&(this.oa=e,I(this.a,\"VER=\"+this.oa));d=d[4];null!=d&&(this.Ba=d,I(this.a,\"SVER=\"+this.Ba));\nthis.F&&(d=a.a)&&((e=d.a?d.a.getResponseHeader(\"X-Client-Wire-Protocol\"):null)&&Qd(this.g,e),this.j&&((d=d.a?d.a.getResponseHeader(\"X-HTTP-Session-Id\"):null)?(this.N=d,R(this.H,this.j,d)):(d=this.a.a)&&G(d,\"Missing X_HTTP_SESSION_ID in the handshake response\")));this.D=3;this.c&&this.c.Fa(this);this.ya=Kd(this,this.ia,this.ja);ue(this)}else\"stop\"!=d[0]&&\"close\"!=d[0]||W(this,7);else 3==this.D&&(\"stop\"==d[0]||\"close\"==d[0]?\"stop\"==d[0]?W(this,7):le(this):\"noop\"!=d[0]&&this.c&&this.c.Ea(this,d),this.B=\n0)}};g.ab=function(){null!=this.s&&(this.s=null,this.b.cancel(),this.b=null,ve(this),K())};function pe(a){null!=a.s&&(k.clearTimeout(a.s),a.s=null)}\ng.wa=function(a){I(this.a,\"Request complete\");if(this.b==a){pe(this);this.b=null;var b=2}else if(Td(this.g,a))b=this.g,b.b&&b.b==a?b.b=null:b.a&&b.a.contains(a)&&bd(b.a.a,Nd(a)),b=1;else return;this.v=a.v;if(0!=this.D)if(a.c)1==b?(t(),J.dispatchEvent(new wc(J)),re(this),this.l.length=0):ue(this);else{var c=a.i;if(3==c||0==c&&0<this.v)I(this.a,\"Not retrying due to error type\");else{I(this.a,\"Maybe retrying, last error: \"+Ic(c,this.v));var d;if(d=1==b)Sd(this.g)||this.o?((a=this.a.a)&&F(a,\"Request already in progress\"),\nd=!1):1==this.D||2==this.D||2<=this.G?d=!1:(I(this.a,\"Going to retry POST\"),this.o=xc(r(this.Pa,this,a),we(this,this.G)),this.G++,d=!0);if(d||2==b&&ve(this))return;I(this.a,\"Exceeded max number of retries\")}I(this.a,\"Error: HTTP request failed\");switch(c){case 1:W(this,5);break;case 4:W(this,10);break;case 3:W(this,6);break;default:W(this,2)}}};function we(a,b){var c=5E3+Math.floor(1E4*Math.random());a.sa()||(I(a.a,\"Inactive channel\"),c*=2);return c*b}\nfunction W(a,b){I(a.a,\"Error code \"+b);if(2==b){var c=null;a.c&&(c=null);var d=r(a.ib,a);c||(c=new Q(\"//www.google.com/images/cleardot.gif\"),k.location&&\"http\"==k.location.protocol||ed(c,\"https\"),Mc(c));Yd(c.toString(),d)}else K();I(a.a,\"HttpChannel: error - \"+b);a.D=0;a.c&&a.c.Da(a,b);oe(a);me(a)}g.ib=function(a){a?I(this.a,\"Successfully pinged google.com\"):I(this.a,\"Failed to ping google.com\");K()};\nfunction oe(a){a.D=0;a.v=-1;if(a.c)if(0==a.l.length&&0==a.h.length)a.c.na(a);else{I(a.a,\"Number of undelivered maps, pending: \"+a.l.length+\", outgoing: \"+a.h.length);var b=ya(a.l),c=ya(a.h);a.l.length=0;a.h.length=0;a.c.na(a,b,c)}}function xe(a,b){b=ye(a,null,b);I(a.a,\"GetForwardChannelUri: \"+b);return b}function Kd(a,b,c){b=ye(a,a.fa()?b:null,c);I(a.a,\"GetBackChannelUri: \"+b);return b}\nfunction ye(a,b,c){var d=td(c);if(\"\"!=d.b)b&&fd(d,b+\".\"+d.b),gd(d,d.i);else{var e=k.location,f;b?f=b+\".\"+e.hostname:f=e.hostname;d=ud(e.protocol,f,e.port,c)}a.ha&&Ba(a.ha,function(a,b){R(d,b,a)});b=a.j;c=a.N;b&&c&&R(d,b,c);R(d,\"VER\",a.oa);ne(a,d);return d}g.ra=function(a){if(a&&!this.T)throw Error(\"Can't create secondary domain capable XhrIo object.\");a=new U;a.m=this.T;return a};g.sa=function(){return!!this.c&&!0};g.fa=function(){return this.T};new Cd;function ze(){}g=ze.prototype;g.Fa=function(){};\ng.Ea=function(){};g.Da=function(){};g.na=function(){};g.Wa=function(){};function Ae(a){for(var b=arguments[0],c=1;c<arguments.length;c++){var d=arguments[c];if(0==d.lastIndexOf(\"/\",0))b=d;else{var e;(e=\"\"==b)||(e=b.length-1,e=0<=e&&b.indexOf(\"/\",e)==e);e?b+=d:b+=\"/\"+d}}return b};function Be(){if(z&&!(10<=Number(Va)))throw Error(\"Environmental error: no available transport.\");}Be.prototype.a=function(a,b){return new X(a,b)};\nfunction X(a,b){B.call(this);this.a=new ke(b,20);this.b=a;this.s=b&&b.testUrl?b.testUrl:Ae(this.b,\"test\");this.f=oc(\"goog.labs.net.webChannel.WebChannelBaseTransport\");this.g=b&&b.messageUrlParams||null;a=b&&b.messageHeaders||null;b&&b.clientProtocolHeaderRequired&&(a?a[\"X-Client-Protocol\"]=\"webchannel\":a={\"X-Client-Protocol\":\"webchannel\"});this.a.i=a;this.a.P=b&&b.initMessageHeaders||null;(a=b&&b.httpHeadersOverwriteParam)&&!/^[\\s\\xa0]*$/.test(a)&&(this.a.f=a);this.o=b&&b.supportsCrossDomainXhr||\n!1;this.m=b&&b.sendRawJson||!1;(b=b&&b.httpSessionIdParam)&&!/^[\\s\\xa0]*$/.test(b)&&(this.a.j=b,a=this.g,null!==a&&b in a&&(a=this.g,b in a&&delete a[b],(a=this.f)&&G(a,\"Ignore httpSessionIdParam also specified with messageUrlParams: \"+b)));this.h=new Ce(this)}u(X,B);\nX.prototype.j=function(){this.a.c=this.h;this.o&&(this.a.T=!0);var a=this.a,b=this.s,c=this.b,d=this.g||void 0;I(a.a,\"connect()\");K();a.ja=c;a.ha=d||{};a.F&&(I(a.a,\"connect() bypassed channel-test.\"),a.J.b=[],a.J.a=!1);I(a.a,\"connectTest_()\");a.C=new Hd(a,a.a);null===a.f&&(a.C.i=a.i);c=b;a.f&&a.i&&(c=je(b,a.f,a.i));a=a.C;a.l=c;b=xe(a.a,a.l);K();c=a.a.J.b;null!=c?(a.g=c[0],a.R=1,Id(a)):(Qc(b,\"MODE\",\"init\"),!a.a.F&&a.a.j&&Qc(b,\"X-HTTP-Session-Id\",a.a.j),a.c=new L(a,a.b,0,void 0,void 0),a.c.h=a.i,Oc(a.c,\nb,!1,null),a.R=0)};X.prototype.close=function(){le(this.a)};X.prototype.l=function(a){if(this.m){var b={};b.__data__=Eb(a);qe(this.a,b)}else qe(this.a,a)};X.prototype.w=function(){this.a.c=null;delete this.h;le(this.a);delete this.a;X.L.w.call(this)};function De(a){Fd.call(this);this.data=a}u(De,Fd);function Ee(){Gd.call(this);this.status=1}u(Ee,Gd);function Ce(a){this.a=a}u(Ce,ze);Ce.prototype.Fa=function(){pc(this.a.f,\"WebChannel opened on \"+this.a.b);this.a.dispatchEvent(\"a\")};\nCe.prototype.Ea=function(a,b){this.a.dispatchEvent(new De(b))};Ce.prototype.Da=function(a,b){pc(this.a.f,\"WebChannel aborted on \"+this.a.b+\" due to channel error: \"+b);this.a.dispatchEvent(new Ee)};Ce.prototype.na=function(){pc(this.a.f,\"WebChannel closed on \"+this.a.b);this.a.dispatchEvent(\"b\")};var Fe=ia(function(a,b){function c(){}c.prototype=a.prototype;var d=new c;a.apply(d,Array.prototype.slice.call(arguments,1));return d},Be);function Ge(){this.b=[];this.a=[]}function He(a){0==a.b.length&&(a.b=a.a,a.b.reverse(),a.a=[]);return a.b.pop()}Ge.prototype.u=function(){return this.b.length+this.a.length};Ge.prototype.contains=function(a){return 0<=sa(this.b,a)||0<=sa(this.a,a)};Ge.prototype.A=function(){for(var a=[],b=this.b.length-1;0<=b;--b)a.push(this.b[b]);var c=this.a.length;for(b=0;b<c;++b)a.push(this.a[b]);return a};function Ie(a,b){w.call(this);this.h=a||0;this.c=b||10;if(this.h>this.c)throw Error(Je);this.a=new Ge;this.b=new T;this.g=null;this.aa()}u(Ie,w);var Je=\"[goog.structs.Pool] Min can not be greater than max\";g=Ie.prototype;g.ca=function(){var a=t();if(!(null!=this.g&&0>a-this.g)){for(var b;0<this.a.u()&&(b=He(this.a),!this.va(b));)this.aa();!b&&this.u()<this.c&&(b=this.qa());b&&(this.g=a,this.b.add(b));return b}};g.hb=function(a){return bd(this.b.a,Nd(a))?(this.ma(a),!0):!1};\ng.ma=function(a){bd(this.b.a,Nd(a));this.va(a)&&this.u()<this.c?this.a.a.push(a):Ke(a)};g.aa=function(){for(var a=this.a;this.u()<this.h;){var b=this.qa();a.a.push(b)}for(;this.u()>this.c&&0<this.a.u();)Ke(He(a))};g.qa=function(){return{}};function Ke(a){if(\"function\"==typeof a.Y)a.Y();else for(var b in a)a[b]=null}g.va=function(a){return\"function\"==typeof a.Xa?a.Xa():!0};g.contains=function(a){return this.a.contains(a)||this.b.contains(a)};g.u=function(){return this.a.u()+this.b.u()};\ng.w=function(){Ie.L.w.call(this);if(0<this.b.u())throw Error(\"[goog.structs.Pool] Objects not released\");delete this.b;for(var a=this.a;0!=a.b.length||0!=a.a.length;)Ke(He(a));delete this.a};function Le(a,b){this.a=a;this.b=b};function Me(a){this.a=[];if(a)a:{if(a instanceof Me){var b=a.O();a=a.A();if(0>=this.u()){for(var c=this.a,d=0;d<b.length;d++)c.push(new Le(b[d],a[d]));break a}}else b=Da(a),a=Ca(a);for(d=0;d<b.length;d++)Ne(this,b[d],a[d])}}function Ne(a,b,c){var d=a.a;d.push(new Le(b,c));b=d.length-1;a=a.a;for(c=a[b];0<b;)if(d=b-1>>1,a[d].a>c.a)a[b]=a[d],b=d;else break;a[b]=c}Me.prototype.A=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].b);return b};\nMe.prototype.O=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].a);return b};Me.prototype.u=function(){return this.a.length};function Oe(){Me.call(this)}u(Oe,Me);function Y(a,b){this.f=new Oe;Ie.call(this,a,b)}u(Y,Ie);g=Y.prototype;g.ca=function(a,b){if(!a)return Y.L.ca.call(this);Ne(this.f,void 0!==b?b:100,a);this.ua()};g.ua=function(){for(var a=this.f;0<a.u();){var b=this.ca();if(b){var c=a,d=c.a,e=d.length;var f=d[0];if(0>=e)f=void 0;else{if(1==e)wa(d);else{d[0]=d.pop();d=0;c=c.a;e=c.length;for(var h=c[d];d<e>>1;){var m=2*d+1,v=2*d+2;m=v<e&&c[v].a<c[m].a?v:m;if(c[m].a>h.a)break;c[d]=c[m];d=m}c[d]=h}f=f.b}f.apply(this,[b])}else break}};\ng.ma=function(a){Y.L.ma.call(this,a);this.ua()};g.aa=function(){Y.L.aa.call(this);this.ua()};g.w=function(){Y.L.w.call(this);k.clearTimeout(void 0);wa(this.f.a);this.f=null};function Z(a,b,c,d){this.l=a;this.j=!!d;Y.call(this,b,c)}u(Z,Y);Z.prototype.qa=function(){var a=new U,b=this.l;b&&b.forEach(function(b,d){a.headers.set(d,b)});this.j&&(a.m=!0);return a};Z.prototype.va=function(a){return!a.i&&!a.a};Be.prototype.createWebChannel=Be.prototype.a;X.prototype.send=X.prototype.l;X.prototype.open=X.prototype.j;X.prototype.close=X.prototype.close;yc.NO_ERROR=0;yc.TIMEOUT=8;yc.HTTP_ERROR=6;zc.COMPLETE=\"complete\";Dd.EventType=Ed;Ed.OPEN=\"a\";Ed.CLOSE=\"b\";Ed.ERROR=\"c\";Ed.MESSAGE=\"d\";B.prototype.listen=B.prototype.$;Z.prototype.getObject=Z.prototype.ca;Z.prototype.releaseObject=Z.prototype.hb;U.prototype.listenOnce=U.prototype.Ia;U.prototype.getLastError=U.prototype.$a;U.prototype.getLastErrorCode=U.prototype.Ga;\nU.prototype.getStatus=U.prototype.V;U.prototype.getStatusText=U.prototype.Ha;U.prototype.getResponseJson=U.prototype.Za;U.prototype.getResponseText=U.prototype.U;U.prototype.getResponseText=U.prototype.U;U.prototype.send=U.prototype.ta;module.exports={createWebChannelTransport:Fe,ErrorCode:yc,EventType:zc,WebChannel:Dd,XhrIoPool:Z};}).call(typeof window !== 'undefined' ? window : this)\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../webchannel-wrapper/dist/index.js\n// module id = 115\n// module chunks = 1"],"sourceRoot":""}